## в RS Interview Topics

## Какие базовые структуры данных вы знаете, и как они организованы?

### Массив (Array):

Хранит коллекцию элементов в смежных областях памяти. Элементы одного типа хранятся вместе, что обеспечивает легкий доступ к каждому элементу по индексу. Массивы могут быть фиксированной или изменяемой длины.
const simpleArray = [];
// Добавление элементов в массив
simpleArray[0] = “один”;
simpleArray[1] = “два”;
simpleArray[2] = “три”;
Массивы (Arrays) широко используются для хранения упорядоченной коллекции элементов. Они обеспечивают доступ к данным и позволяют итерироваться по элементам. В веб-разработке массивы часто используются для хранения элементов интерфейса, таких как пункты меню и изображения. Они также подходят для обработки данных, таких как сортировка, фильтрация и поиск, а также для хранения структурированных данных, например, таблиц и матриц.

```jsx
const simpleArray = [];
// Добавление элементов в массив
simpleArray[0] = “один”;
simpleArray[1] = “два”;
simpleArray[2] = “три”;
```

Массивы (Arrays) широко используются для хранения упорядоченной коллекции элементов. Они обеспечивают доступ к данным и позволяют итерироваться по элементам. В веб-разработке массивы часто используются для хранения элементов интерфейса, таких как пункты меню и изображения. Они также подходят для обработки данных, таких как сортировка, фильтрация и поиск, а также для хранения структурированных данных, например, таблиц и матриц.

### Стек (Stack):

Хранит коллекцию элементов в линейном порядке, определяемом порядком операций. “последний вошел, первый вышел” (LIFO)
const stack = [];
// Добавление элементов в стек (push)
stack.push(“элемент 1”);
stack.push(“элемент 2”);
stack.push(“элемент 3”);
// Удаление элементов из стека (pop)
const removedElement = stack.pop();
Стек вызовов функций в JavaScript используется для управления вызовами функций. При вызове функции создается новый фрейм стека для хранения ее данных. После завершения функции, соответствующий фрейм удаляется из стека. Это происходит по принципу LIFO. В браузерной разработке стеки используются для обработки событий, таких как клики мыши и нажатия клавиш. События обрабатываются в порядке их поступления, следуя принципу LIFO. Управление историей браузера осуществляется с помощью стека. Веб-браузеры используют его для отслеживания переходов между страницами. При переходе на новую страницу или выполнении навигационных действий добавляется новый URL в стек, что позволяет перемещаться по истории браузера. Стеки также используются при реализации различных алгоритмов и структур данных, таких как обход деревьев и вычисление арифметических выражений в обратной польской записи.

```jsx
const stack = [];
// Добавление элементов в стек (push)
stack.push(“элемент 1”);
stack.push(“элемент 2”);
stack.push(“элемент 3”);
// Удаление элементов из стека (pop)
const removedElement = stack.pop();
```

Стек вызовов функций в JavaScript используется для управления вызовами функций. При вызове функции создается новый фрейм стека для хранения ее данных. После завершения функции, соответствующий фрейм удаляется из стека. Это происходит по принципу LIFO. В браузерной разработке стеки используются для обработки событий, таких как клики мыши и нажатия клавиш. События обрабатываются в порядке их поступления, следуя принципу LIFO. Управление историей браузера осуществляется с помощью стека. Веб-браузеры используют его для отслеживания переходов между страницами. При переходе на новую страницу или выполнении навигационных действий добавляется новый URL в стек, что позволяет перемещаться по истории браузера. Стеки также используются при реализации различных алгоритмов и структур данных, таких как обход деревьев и вычисление арифметических выражений в обратной польской записи.

### Очередь (Queue):

Хранит коллекцию элементов, аналогично стеку, но порядок операций здесь всегда “первый вошел, первый вышел”.
const queue = [];
// Добавление элементов в очередь (enqueue)
queue.push(“элемент 1”);
queue.push(“элемент 2”);
queue.push(“элемент 3”);
// Удаление элементов из очереди (dequeue)
const removedElement = queue.shift();
В браузерной разработке очереди используются для управления событиями и обработки асинхронных задач, таких как выполнение JavaScript кода, запросы к серверу и анимации. В Node.js и веб-приложениях очереди используются для обработки задач в фоновом режиме, например, запросов к базе данных или сообщений от пользователей. Очереди также используются для обработки данных в реальном времени, таких как сообщения в чате или обновления данных на веб-странице. Они также применяются при реализации различных алгоритмов, таких как поиск в ширину при обходе графов и FIFO планирование задач в операционных системах.

```jsx
const queue = [];
// Добавление элементов в очередь (enqueue)
queue.push(“элемент 1”);
queue.push(“элемент 2”);
queue.push(“элемент 3”);
// Удаление элементов из очереди (dequeue)
const removedElement = queue.shift();
```

В браузерной разработке очереди используются для управления событиями и обработки асинхронных задач, таких как выполнение JavaScript кода, запросы к серверу и анимации. В Node.js и веб-приложениях очереди используются для обработки задач в фоновом режиме, например, запросов к базе данных или сообщений от пользователей. Очереди также используются для обработки данных в реальном времени, таких как сообщения в чате или обновления данных на веб-странице. Они также применяются при реализации различных алгоритмов, таких как поиск в ширину при обходе графов и FIFO планирование задач в операционных системах.

### Связанный список (Linked List):

Хранит коллекцию элементов в линейном порядке. Каждый элемент, или узел, содержит элемент данных и ссылку на следующий элемент в списке.
// Создание узла списка
function createNode(data) {
return {
data: data, // Данные узла
next: null // Ссылка на следующий узел (изначально null)
};
}
// Пример связанного списка
const node1 = createNode(“узел 1”);
const node2 = createNode(“узел 2”);
const node3 = createNode(“узел 3”);
// Связывание узлов в список
node1.next = node2;
node2.next = node3;
// Перебор элементов связанного списка
let currentNode = node1;
while (currentNode) {
console.log(currentNode.data);
console.log(currentNode.next);
currentNode = currentNode.next;
}
Связанные списки обладают динамическим размером, который может изменяться по мере необходимости, в отличие от массивов. Эффективное добавление и удаление элементов делает их предпочтительными для операций вставки и удаления в начале или середине списка. Управление памятью упрощается, так как элементы списка могут быть разбросаны по памяти, не требуя непрерывного блока памяти. Они также используются для реализации других структур данных, таких как стеки и очереди. Кроме того, связанные списки могут быть полезны для работы с большими объемами данных, где требуется эффективное добавление и удаление элементов без перераспределения всего блока памяти, как это происходит с массивами.
Разновидности:
Односвязный список (Singly Linked List): Каждый узел списка содержит данные и ссылку (указатель) на следующий узел в списке. Последний узел указывает на null, что указывает на конец списка.
Двусвязный список (Doubly Linked List): Каждый узел списка содержит данные, ссылку на следующий узел и ссылку на предыдущий узел в списке. Это позволяет эффективно перемещаться как вперед, так и назад по списку.
Кольцевой список (Circular Linked List): В этом списке последний узел ссылается на первый узел, образуя цикл. Это позволяет обходить список бесконечно, просто следуя по ссылкам. /// и еще есть …

```jsx
// Создание узла списка
function createNode(data) {
  return {
    data: data, // Данные узла
    next: null, // Ссылка на следующий узел (изначально null)
  };
}
// Пример связанного списка
const node1 = createNode("узел 1");
const node2 = createNode("узел 2");
const node3 = createNode("узел 3");
// Связывание узлов в список
node1.next = node2;
node2.next = node3;
// Перебор элементов связанного списка
let currentNode = node1;
while (currentNode) {
  console.log(currentNode.data);
  console.log(currentNode.next);
  currentNode = currentNode.next;
}

```

Связанные списки обладают динамическим размером, который может изменяться по мере необходимости, в отличие от массивов. Эффективное добавление и удаление элементов делает их предпочтительными для операций вставки и удаления в начале или середине списка. Управление памятью упрощается, так как элементы списка могут быть разбросаны по памяти, не требуя непрерывного блока памяти. Они также используются для реализации других структур данных, таких как стеки и очереди. Кроме того, связанные списки могут быть полезны для работы с большими объемами данных, где требуется эффективное добавление и удаление элементов без перераспределения всего блока памяти, как это происходит с массивами.
Разновидности:
Односвязный список (Singly Linked List): Каждый узел списка содержит данные и ссылку (указатель) на следующий узел в списке. Последний узел указывает на null, что указывает на конец списка.
Двусвязный список (Doubly Linked List): Каждый узел списка содержит данные, ссылку на следующий узел и ссылку на предыдущий узел в списке. Это позволяет эффективно перемещаться как вперед, так и назад по списку.
Кольцевой список (Circular Linked List): В этом списке последний узел ссылается на первый узел, образуя цикл. Это позволяет обходить список бесконечно, просто следуя по ссылкам. /// и еще есть …

### Дерево (Tree):

Хранит коллекцию элементов иерархически. У каждого узла есть ключевое значение, а родительские узлы связаны с дочерними.
// Создание узла дерева
function createNode(value) {
return {
data: value, // Данные узла
children: [] // Массив дочерних узлов (изначально пуст)
};
}
// Пример дерева
const tree = createNode(“корень”);
const child1 = createNode(“первый потомок”);
const child2 = createNode(“второй потомок”);
const grandchild = createNode(“внук”);
// Связывание узлов в дерево
tree.children.push(child1);
tree.children.push(child2);
child2.children.push(grandchild);
// Функция для рекурсивного обхода дерева
function traverse(node) {
console.log(node.data);
if (node.children.length === 0) return; // Базовый случай: у узла нет детей
node.children.forEach(child => traverse(child)); // Рекурсивный случай: обходим детей
}
// Обход дерева
traverse(tree);
Деревья организуют данные иерархически, как файловая система компьютера или структура документов HTML/XML веб-страницы. Они также используются для реализации алгоритмов и структур данных, например, бинарных деревьев поиска. В веб-разработке деревья представляют структуру веб-страницы через объектную модель документа (DOM), где каждый HTML элемент - это узел в дереве. Деревья также применяются в интерфейсах пользователя для организации компонентов, таких как меню и деревья файлов. Они используются в алгоритмах обхода и поиска данных, например, поиск в ширину или поиск в глубину. В JavaScript деревья могут быть реализованы с использованием объектов или классов для представления узлов и их отношений.

```jsx

// Создание узла дерева
function createNode(value) {
  return {
    data: value, // Данные узла
    children: [], // Массив дочерних узлов (изначально пуст)
  };
}
// Пример дерева
const tree = createNode("корень");
const child1 = createNode("первый потомок");
const child2 = createNode("второй потомок");
const grandchild = createNode("внук");
// Связывание узлов в дерево
tree.children.push(child1);
tree.children.push(child2);
child2.children.push(grandchild);
// Функция для рекурсивного обхода дерева
function traverse(node) {
  console.log(node.data);
  if (node.children.length === 0) return; // Базовый случай: у узла нет детей
  node.children.forEach((child) => traverse(child)); // Рекурсивный случай: обходим детей
}
// Обход дерева
traverse(tree);

```

Деревья организуют данные иерархически, как файловая система компьютера или структура документов HTML/XML веб-страницы. Они также используются для реализации алгоритмов и структур данных, например, бинарных деревьев поиска. В веб-разработке деревья представляют структуру веб-страницы через объектную модель документа (DOM), где каждый HTML элемент - это узел в дереве. Деревья также применяются в интерфейсах пользователя для организации компонентов, таких как меню и деревья файлов. Они используются в алгоритмах обхода и поиска данных, например, поиск в ширину или поиск в глубину. В JavaScript деревья могут быть реализованы с использованием объектов или классов для представления узлов и их отношений.

### Граф (Graph):

Хранит коллекцию элементов нелинейным образом. Состоит из конечного набора вершин (узлов) и связей (ребер) между ними.
// Создание пустого графа
const graph = {};
// Добавление вершин и рёбер
graph[“A”] = [“B”, “C”];
graph[“B”] = [“A”, “D”];
graph[“C”] = [“A”, “D”];
graph[“D”] = [“B”, “C”];
// Вывод всех вершин и их соседей
for (const vertex in graph) {
const neighbors = graph[vertex];
console.log(`Вершина ${vertex} соединена с вершинами: ${neighbors.join(", ")}`);
}
Графы моделируют отношения и связи между объектами, как в социальных сетях для представления дружеских связей или в графах зависимостей программного обеспечения для описания связей между компонентами. В алгоритмах поиска и обхода графов, таких как поиск в ширину или в глубину, используются для нахождения кратчайшего пути или обхода всех вершин. В анализе данных и машинном обучении графы помогают анализировать структуру сетей, выявлять сообщества или влиятельные узлы. Они также используются для моделирования задач оптимизации, например, задачи раскроя или планирования производства. Визуализация данных с помощью графов помогает отображать связи между объектами, будь то структура социальных связей, иерархия сайтов или каталогов.

```jsx
// Создание пустого графа
const graph = {};
// Добавление вершин и рёбер
graph["A"] = ["B", "C"];
graph["B"] = ["A", "D"];
graph["C"] = ["A", "D"];
graph["D"] = ["B", "C"];
// Вывод всех вершин и их соседей
for (const vertex in graph) {
  const neighbors = graph[vertex];
  console.log(
    `Вершина ${vertex} соединена с вершинами: ${neighbors.join(", ")}`
  );
}

```

Графы моделируют отношения и связи между объектами, как в социальных сетях для представления дружеских связей или в графах зависимостей программного обеспечения для описания связей между компонентами. В алгоритмах поиска и обхода графов, таких как поиск в ширину или в глубину, используются для нахождения кратчайшего пути или обхода всех вершин. В анализе данных и машинном обучении графы помогают анализировать структуру сетей, выявлять сообщества или влиятельные узлы. Они также используются для моделирования задач оптимизации, например, задачи раскроя или планирования производства. Визуализация данных с помощью графов помогает отображать связи между объектами, будь то структура социальных связей, иерархия сайтов или каталогов.

### Хеш-таблица (Hash Table):

Хранит коллекцию элементов в ассоциативном массиве, который сопоставляет ключи и значения. Использует хеш-функцию для преобразования индекса в массиве бакетов, содержащих соответствующий элемент данных.
class HashTable {
constructor() {
this.table = {};
}
// Метод для добавления информации о котике в хеш-таблицу
addCat(name, details) {
this.table[name] = details;
}
// Метод для получения информации о котике по его имени
getCat(name) {
return this.table[name];
}
}
// Создаем хеш-таблицу для котиков
const catTable = new HashTable();
// Добавляем информацию о котиках в хеш-таблицу
catTable.addCat(“Fluffy”, { age: 3, color: “white” });
catTable.addCat(“Whiskers”, { age: 5, color: “gray” });
catTable.addCat(“Mittens”, { age: 2, color: “black” });
// Получаем информацию о котике по его имени
console.log(catTable.getCat(“Fluffy”));
Хеш-таблицы используются для эффективного хранения данных, особенно когда требуется быстрый доступ по ключу, например, для кэширования, пользовательских данных или конфигурационных параметров. Благодаря эффективной хеш-функции, доступ к данным в хеш-таблице происходит быстро, что делает их превосходным выбором для работы с большими объемами данных, к которым нужен быстрый доступ. Хеш-таблицы также могут использоваться для генерации уникальных идентификаторов или URL, а также для реализации других структур данных, например, множеств или множеств с поддержкой быстрого поиска и удаления элементов. Они помогают оптимизировать использование памяти, поскольку позволяют быстро находить данные по ключу без необходимости больших объемов оперативной памяти для хранения индексов.
Коллизия - это ситуация, когда два или более ключа объекта или элементы структуры данных хеш-таблицы сопоставляются с одним и тем же индексом массива (бакетом) после применения хеш-функции. JavaScript автоматически обрабатывает коллизии, используя внутренние механизмы хранения данных, которые могут включать в себя метод цепочек или другие стратегии управления коллизиями.

```jsx
class HashTable {
constructor() {
this.table = {};
}
// Метод для добавления информации о котике в хеш-таблицу
addCat(name, details) {
this.table[name] = details;
}
// Метод для получения информации о котике по его имени
getCat(name) {
return this.table[name];
}
}
// Создаем хеш-таблицу для котиков
const catTable = new HashTable();
// Добавляем информацию о котиках в хеш-таблицу
catTable.addCat(“Fluffy”, { age: 3, color: “white” });
catTable.addCat(“Whiskers”, { age: 5, color: “gray” });
catTable.addCat(“Mittens”, { age: 2, color: “black” });
// Получаем информацию о котике по его имени
console.log(catTable.getCat(“Fluffy”));
```

Хеш-таблицы используются для эффективного хранения данных, особенно когда требуется быстрый доступ по ключу, например, для кэширования, пользовательских данных или конфигурационных параметров. Благодаря эффективной хеш-функции, доступ к данным в хеш-таблице происходит быстро, что делает их превосходным выбором для работы с большими объемами данных, к которым нужен быстрый доступ. Хеш-таблицы также могут использоваться для генерации уникальных идентификаторов или URL, а также для реализации других структур данных, например, множеств или множеств с поддержкой быстрого поиска и удаления элементов. Они помогают оптимизировать использование памяти, поскольку позволяют быстро находить данные по ключу без необходимости больших объемов оперативной памяти для хранения индексов.
Коллизия - это ситуация, когда два или более ключа объекта или элементы структуры данных хеш-таблицы сопоставляются с одним и тем же индексом массива (бакетом) после применения хеш-функции. JavaScript автоматически обрабатывает коллизии, используя внутренние механизмы хранения данных, которые могут включать в себя метод цепочек или другие стратегии управления коллизиями.

## Basic sorting and searching algorithms

Основные алгоритмы сортировки включают в себя:

### Пузырьковая сортировка (Bubble Sort) O(n^2):

Проходит через список множество раз, сравнивая каждую пару соседних элементов и меняя их местами, если они находятся в неправильном порядке.

Он подходит в следующих случаях:
Когда нужно отсортировать небольшой массив данных.
Когда требуется реализация сортировки с минимальным объемом кода или простой логикой.
Но он неэффективен в случаях:
Для больших массивов данных, так как его временная сложность составляет O(n^2), что делает его медленным на больших объемах данных.
Когда нужно сортировать данные, требующие высокой производительности, так как другие алгоритмы, такие как быстрая сортировка или сортировка слиянием, работают значительно быстрее на больших наборах данных.
let bubbleSort = (arr) => {
const sortArr = […arr]
let len = sortArr.length;
for (let i = 0; i < len; i++) {
for (let j = 0; j < len; j++) {
if (sortArr[j] > sortArr[j + 1]) {
let temp = sortArr[j];
sortArr[j] = sortArr[j + 1];
sortArr[j + 1] = temp;
}
}
}
return sortArr;
};
// Пример использования
let arr = [5, 3, 8, 1, 2];
console.log(bubbleSort(arr));

```jsx
let bubbleSort = (arr) => {
  const sortArr = [...arr];
  let len = sortArr.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len; j++) {
      if (sortArr[j] > sortArr[j + 1]) {
        let temp = sortArr[j];
        sortArr[j] = sortArr[j + 1];
        sortArr[j + 1] = temp;
      }
    }
  }
  return sortArr;
};
// Пример использования
let arr = [5, 3, 8, 1, 2];
console.log(bubbleSort(arr));

```

О малое (O-нотация):
Время выполнения сортировки пузырьком зависит от размера входного списка. В худшем случае (когда список уже отсортирован в обратном порядке), алгоритм будет иметь квадратичное время выполнения, т.е. O(n^2). Это означает, что время выполнения будет расти пропорционально квадрату размера входного списка.
О большое (Ω-нотация):
В лучшем случае (когда список уже отсортирован), сортировка пузырьком все равно проходит через весь список, чтобы убедиться, что он отсортирован. Поэтому даже в лучшем случае алгоритм имеет линейное время выполнения, т.е. Ω(n). Это означает, что время выполнения не может быть лучше, чем линейная функция от размера входного списка.
Таким образом, для сортировки пузырьком:
О малое (O-нотация) говорит нам о худшем случае, когда время выполнения квадратично от размера входного списка.
О большое (Ω-нотация) указывает на лучший случай, когда время выполнения линейно от размера входного списка.

### Сортировка выбором (Selection Sort) O(n^2):

Выбирает минимальный элемент из оставшихся и перемещает его в начало списка. Сортировка выбором полезна в случаях, когда нужно отсортировать небольшой массив данных или когда производительность не является критическим фактором. Этот метод эффективен для сортировки небольших списков или массивов, но не рекомендуется для сортировки больших объемов данных из-за его низкой эффективности по времени выполнения.
function selectionSort(arr) {
const len = arr.length;
for (let i = 0; i < len - 1; i++) {
let minIndex = i;
for (let j = i + 1; j < len; j++) {
if (arr[j] < arr[minIndex]) {
minIndex = j;
}
}
if (minIndex !== i) {
[arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; // Меняем местами элементы
}
}
return arr;
}
// Пример использования
const arr = [64, 25, 12, 22, 11];
console.log(“Исходный массив:” + arr);
console.log(“Отсортированный массив:” + selectionSort(arr));

```jsx
function selectionSort(arr) {
  const len = arr.length;
  for (let i = 0; i < len - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; // Меняем местами элементы
    }
  }
  return arr;
}
// Пример использования
const arr = [64, 25, 12, 22, 11];
console.log("Исходный массив:" + arr);
console.log("Отсортированный массив:" + selectionSort(arr));

```

### Сортировка вставками (Insertion Sort) O(n^2):

Проходит по списку и вставляет каждый элемент на свое место в уже отсортированную часть списка. Сортировка вставками (Insertion Sort) полезна в случаях, когда требуется сортировать небольшие массивы или когда массив уже частично отсортирован.
function insertionSort(arr) {
const len = arr.length;
for (let i = 1; i < len; i++) {
let current = arr[i];
let j = i - 1;
while (j >= 0 && arr[j] > current) {
arr[j + 1] = arr[j];
j–;
}
arr[j + 1] = current;
}
return arr;
}
// Пример использования
const arr = [12, 11, 13, 5, 6];
console.log(“Исходный массив:” + arr);
console.log(“Отсортированный массив:” + insertionSort(arr));

```jsx
function insertionSort(arr) {
  const len = arr.length;
  for (let i = 1; i < len; i++) {
    let current = arr[i];
    let j = i - 1;
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = current;
  }
  return arr;
}
// Пример использования
const arr = [12, 11, 13, 5, 6];
console.log("Исходный массив:" + arr);
console.log("Отсортированный массив:" + insertionSort(arr));

```

### Быстрая сортировка (Quick Sort) в среднем O(n log n):

Разделяет список на две части вокруг опорного элемента, затем рекурсивно сортирует каждую из частей. Сортировка Quick Sort эффективна в большинстве случаев и широко используется из-за своей скорости и производительности. Она особенно полезна для сортировки больших объемов данных.
function quickSort(arr) {
if (arr.length <= 1) {
return arr;
}
const pivot = arr[0];
const left = [];
const right = [];

```
for (let i = 1; i < arr.length; i++) {
    if (arr[i] < pivot) {
        left.push(arr[i]);
    } else {
        right.push(arr[i]);
    }
}
return quickSort(left).concat(pivot, quickSort(right));
```

}
const arr = [10, 7, 8, 9, 1, 5];
const sortedArr = quickSort(arr);
console.log(sortedArr); // Output: [1, 5, 7, 8, 9, 10]

### Сортировка слиянием (Merge Sort) O(n log n)::

Разделяет список на две равные части, рекурсивно сортирует каждую часть, а затем объединяет их в один отсортированный список. Merge Sort является стабильным методом сортировки, что означает, что порядок элементов с одинаковыми значениями не меняется. Это может быть важно для определенных типов данных или сценариев.
function mergeSort(arr) {
if (arr.length <= 1) {
return arr;
}
const middle = Math.floor(arr.length / 2);
const left = arr.slice(0, middle);
const right = arr.slice(middle);
return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
let result = [];
let leftIndex = 0;
let rightIndex = 0;
while (leftIndex < left.length && rightIndex < right.length) {
if (left[leftIndex] < right[rightIndex]) {
result.push(left[leftIndex]);
leftIndex++;
} else {
result.push(right[rightIndex]);
rightIndex++;
}
}
return result.concat(left.slice(leftIndex), right.slice(rightIndex));
}
const arr = [38, 27, 43, 3, 9, 82, 10];
const sortedArr = mergeSort(arr);
console.log(sortedArr); // Output: [3, 9, 10, 27, 38, 43, 82]

Основные алгоритмы поиска включают в себя:

### Линейный поиск (Linear Search):O(n)

Проходит по списку последовательно и ищет заданный элемент.
function linearSearch(arr, target) {
for (let i = 0; i < arr.length; i++) {
if (arr[i] === target) {
return i; // Возвращаем индекс найденного элемента
}
}
return -1; // Возвращаем -1, если элемент не найден
}
const arr = [5, 3, 9, 2, 7];
const target = 9;
const index = linearSearch(arr, target);
console.log(“Index of”, target, “is”, index);

### Бинарный поиск (Binary Search) O(log n):

Работает на отсортированном списке и делит его на две части, сравнивая искомый элемент с элементом в середине списка и продолжая поиск только в той части, где может быть найден элемент. Упорядоченные массивы: Бинарный поиск эффективен для поиска элементов в упорядоченных массивах, так как основан на делении массива на половины и исключении половины элементов на каждой итерации. Большие объемы данных: При работе с большими объемами данных бинарный поиск может значительно сократить количество операций поиска по сравнению с линейным поиском.
function binarySearch(arr, target) {
let left = 0;
let right = arr.length - 1;
while (left <= right) {
let mid = Math.floor((left + right) / 2);
if (arr[mid] === target) {
return mid; // Возвращаем индекс найденного элемента
} else if (arr[mid] < target) {
left = mid + 1;
} else {
right = mid - 1;
}
}
return -1; // Возвращаем -1, если элемент не найден
}
const arr = [2, 5, 7, 9, 12, 15, 17];
const target = 9;
const index = binarySearch(arr, target);
console.log(“Index of”, target, “is”, index);

///Сортировка подсчётом (Counting Sort) - это алгоритм сортировки, который работает для ограниченного диапазона целых чисел. Он основан на подсчёте количества элементов каждого значения в массиве и последующем формировании отсортированного массива на основе этих подсчётов.

## Binary number system

Двоичная система счисления, использующая только цифры 0 и 1, является основной для компьютеров, включая JavaScript, по нескольким причинам. В компьютерах все данные хранятся и обрабатываются в виде двоичных чисел, а JavaScript также работает с этой системой. Она поддерживает арифметические операции, хранение данных в памяти и битовые операции, что полезно для работы с флагами и состояниями.
Можно использовать встроенный метод toString(), указав основание системы счисления в качестве параметра.
let decimal = 10;
let binary = decimal.toString(2);
console.log(binary); // Вывод: “1010”

# Как подключить JS в HTML?

1. **Обычный встроенный `<script>` в `<head>` или `<body>`**:
    - Если `<script>` размещен в начале `<head>`, скрипт будет загружен и выполнен сразу же, при этом блокируя дальнейший парсинг HTML, пока скрипт не будет загружен и выполнен. Это может замедлить отображение страницы, если скрипт тяжелый.
2. **Внешний файл JavaScript с `defer`**:
    - Скрипт будет загружен параллельно с парсингом HTML, но выполнится только после того, как весь HTML-документ будет полностью загружен и обработан, перед событием `DOMContentLoaded`. Это позволяет избежать блокировки парсинга HTML.
3. **Внешний файл JavaScript с `async`**:
    - Скрипт будет загружен параллельно с парсингом HTML и выполнится сразу после завершения загрузки, независимо от того, завершен ли парсинг HTML. Это может привести к выполнению скрипта до завершения загрузки всей страницы, что может повлиять на работу скрипта, если он зависит от контента, который еще не загружен.
4. **Встроенный JavaScript код**:
    - Встроенный код `<script>` будет выполнен сразу же, в том месте, где он находится в HTML, блокируя дальнейший парсинг HTML.

Для оптимальной загрузки и исполнения JavaScript кода обычно рекомендуется:

- Размещать `<script>` с атрибутом `defer` в `<head>` для того, чтобы скрипты выполнялись после загрузки и парсинга всего HTML.
- Либо размещать `<script>` перед закрывающим тегом `</body>`, что также позволяет скриптам выполняться после загрузки основного контента страницы.

## Что такое режим use strict

`"use strict"` — это директива в JavaScript, которая была введена в ECMAScript 5 (ES5) и используется для включения строгого режима. Строгий режим изменяет семантику JavaScript таким образом, чтобы улучшить производительность, упростить отладку и сделать язык более безопасным.

### Основные особенности строгого режима:

1. **Запрещение использования необъявленных переменных**: В строгом режиме любые переменные должны быть объявлены с использованием `var`, `let` или `const` перед использованием.
    
    ```jsx
    "use strict";
    x = 10; // Ошибка: x не объявлена
    ```
    
2. **Запрет на дублирование параметров функции**: Функция не может иметь параметры с одинаковыми именами.
    
    ```jsx
    "use strict";
    function sum(a, a, c) { // Ошибка: дублирующиеся параметры
        return a + a + c;
    }
    ```
    
3. **Отмена неявного приведения контекста `this` к глобальному объекту**: В строгом режиме, если `this` не определён, он остаётся `undefined`, вместо привязки к глобальному объекту.
    
    ```jsx
    "use strict";
    function fun() {
        console.log(this); // undefined
    }
    fun();
    ```
    
4. **Запрещение удаления переменных, функций и аргументов**: Нельзя использовать оператор `delete` для удаления переменных, функций или параметров функции.
    
    ```jsx
    "use strict";
    var x = 1;
    delete x; // Ошибка: нельзя удалить переменную
    ```
    
5. **Запрет на присваивание значения неизменяемым свойствам**: Нельзя изменять значение свойств, которые не могут быть изменены, например, свойства, которые имеют `writable: false`.
    
    ```jsx
    "use strict";
    var obj = {};
    Object.defineProperty(obj, 'x', { value: 42, writable: false });
    obj.x = 9; // Ошибка: свойство x нельзя изменить
    ```
    
6. **Запрет на использование ключевых слов будущих версий ECMAScript**: Некоторые ключевые слова, зарезервированные для будущих версий языка, не могут быть использованы в качестве имён переменных или функций.
    
    ```jsx
    "use strict";
    var public = 1; // Ошибка: "public" - зарезервированное слово
    ```
    

### Зачем используется строгий режим?

- **Безопасность**: Строгий режим помогает предотвратить случайные ошибки и небезопасные действия, улучшая таким образом безопасность кода.
- **Производительность**: Некоторые оптимизации компиляторов JavaScript могут работать лучше при строгом режиме, что может привести к повышению производительности.
- **Совместимость с будущими версиями языка**: Строгий режим запрещает использование некоторых ключевых слов и синтаксических конструкций, зарезервированных для будущих версий ECMAScript, что помогает избежать проблем при переходе на новые версии языка.

### Применение строгого режима

Строгий режим может быть включен для всего скрипта или для отдельной функции, добавив строку `"use strict";` в начале скрипта или функции.

- **Для всего скрипта**:
    
    ```jsx
    "use strict";
    // весь код в этом файле будет выполняться в строгом режиме
    ```
    
- **Для отдельной функции**:
    
    ```jsx
    function myFunction() {
        "use strict";
        // код внутри этой функции будет выполняться в строгом режиме
    }
    ```
    

Использование строгого режима помогает писать более чистый и надёжный код, избегая множества распространённых ошибок JavaScript.

## Data types

Примитивные типы данных:
1 Number: Представляет числовые значения, как целые, так и дробные. Пример: 42, 3.14.
2 String: Представляет последовательность символов. Пример: “Hello, world!”.
3 Boolean: Представляет логическое значение true или false.
4 Null: Представляет отсутствие значения или пустое значение. typeof выдает объект из-за исторических причин для сохранения совместимости существующего кода
5 Undefined: Представляет переменную, которая была объявлена, но ей не было присвоено значение.
6 BigInt: Представляет целые числа произвольной длины.
7 Symbol: Представляет уникальные и неизменяемые значения, используемые для идентификации объектов.
Ссылочные типы данных:
1 Object: Представляет коллекцию ключ-значение или объекты.
2 Array: Представляет упорядоченную коллекцию элементов.
3 Function: Представляет блок кода, который можно вызывать.
4 Date: Представляет дату и время.
5 RegExp: Представляет шаблон для поиска или замены текста в строке.

NaN

NaN - это специальное значение в JavaScript, которое обозначает “Не число” (Not a Number). Оно используется для представления результата математических операций, которые не могут быть определены как число.
Примеры операций, которые могут привести к NaN:
Деление на ноль: 0 / 0.
Деление бесконечности на бесконечность: Infinity / Infinity.
Попытка выполнить математическую операцию с нечисловым значением, например, умножить число на строку: 5 * “hello”.
Попытка выполнить математическую операцию с неопределенным значением или значением, которое не является числом: Math.sqrt(-1).
NaN имеет несколько особенностей:
Любая операция с NaN, включая сравнения, возвращает false.
NaN не равно ни одному другому значению, даже себе: NaN === NaN вернёт false. Для проверки на NaN используется функция isNaN() или оператор Number.isNaN().
При использовании в математических операциях, NaN распространяется и может “заразить” любое другое число, сделав их NaN.

Примитивные типы данных и ссылочные типы данных различаются по способу хранения и передачи значений в памяти. Вот подробное объяснение этих различий:

### Примитивные типы данных

**Примитивные типы данных** (или просто примитивы) представляют собой простые значения, которые хранятся непосредственно. Примеры примитивных типов в JavaScript включают:

**Особенности примитивных типов данных:**

1. **Хранение значения**:
    - Примитивы хранятся непосредственно в переменной. Значение примитива копируется при присваивании или передаче функции.
2. **Неизменяемость (иммутабельность)**:
    - Примитивные значения неизменяемы. Например, строки и числа не могут быть изменены после создания. Если вы измените строку или число, вы получите новое значение, а не измените исходное.
3. **Сравнение**:
    - Примитивные значения сравниваются по значению. Два примитива равны, если их значения равны.

### Ссылочные типы данных

**Ссылочные типы данных** (или объекты) представляют собой сложные структуры данных, которые хранятся в памяти по ссылке. Примеры ссылочных типов в JavaScript включают

**Особенности ссылочных типов данных:**

1. **Хранение значения**:
    - Ссылочные типы хранятся в переменной как ссылка на место в памяти, где хранится фактическое значение. Когда вы присваиваете или передаете ссылочный тип, вы работаете с ссылкой, а не с самим значением.
2. **Изменяемость (мутируемость)**:
    - Объекты и массивы изменяемы. Вы можете изменять их содержимое, и изменения будут видны во всех переменных, которые ссылаются на тот же объект.
3. **Сравнение**:
    - Ссылочные значения сравниваются по ссылке, а не по значению. Два объекта равны только тогда, когда они ссылаются на один и тот же объект в памяти.

### Ключевые различия

1. **Хранение и передача**:
    - Примитивы хранятся непосредственно в переменной, а ссылочные типы — по ссылке на место в памяти.
2. **Копирование**:
    - Присваивание примитива создает копию значения, тогда как присваивание ссылочного типа создает копию ссылки.
3. **Изменяемость**:
    - Примитивы неизменяемы, тогда как объекты и массивы изменяемы.
4. **Сравнение**:
    - Примитивные значения сравниваются по значению, а ссылочные — по ссылке.

### В чем отличие null и underfind

null и undefined - это два разных значения в JavaScript, и они оба представляют отсутствие значения, но в разных контекстах.
undefined:
undefined означает, что переменная была объявлена, но ей не было присвоено значение.
Когда переменной объявленной без присвоения значения, ее тип и значение по умолчанию будут undefined.
Также undefined является значением, возвращаемым функцией, если она ничего не возвращает явно.
null:
null также представляет отсутствие значения, но используется, когда программист явно присваивает переменной “ничего” или “пустоту”.
Это явное присвоение значения, и если переменной присвоено null, это означает, что она не указывает на какой-либо объект или значение.
Во многих случаях undefined сигнализирует о том, что что-то не было инициализировано, в то время как null часто используется для явного указания на отсутствие значения. Однако, в некоторых ситуациях, они могут быть взаимозаменяемыми. Когда вы объявляете переменную без присвоения значения, она автоматически получает значение undefined.

- **Нестрогое сравнение**: `null == undefined` возвращает `true`. `null` и `undefined` считаются равными, если типы могут быть приведены к общему значению. Это правило специально определено для упрощения проверки на отсутствие значений
- **Строгое сравнение**: `null === undefined` возвращает `false`. `null` и `undefined` не равны, так как их типы разные и преобразование типов не происходит.

### Что такое typeof

`typeof` — это оператор в JavaScript, который используется для определения типа операнда. Он возвращает строку, указывающую тип переданного значения.

## Variables

В JavaScript переменные можно создавать с помощью ключевых слов var, let и const.
var было первым ключевым словом для объявления переменных в JavaScript.
Переменные, объявленные с помощью var, имеют функциональную область видимости (function scope), что означает, что они видны только внутри функции, в которой они были объявлены.
let было введено в ECMAScript 6 (ES6) и стало предпочтительным способом объявления переменных в современном JavaScript.
Переменные, объявленные с помощью let, имеют блочную область видимости (block scope), что означает, что они видны только в блоке кода, в котором они были объявлены.
const также было введено в ECMAScript 6 (ES6) и используется для объявления переменных с неизменяемым значением (констант).
Переменные, объявленные с помощью const, также имеют блочную область видимости (block scope).
Константы должны быть инициализированы при объявлении и их значение не может быть изменено.

- **`var`**: Объявления переменных поднимаются в начало функции или глобальной области видимости. Значение переменной будет `undefined` до строки инициализации.
- **`let`** и **`const`**: Объявления переменных поднимаются в начало блока, но переменные находятся в временной мёртвой зоне до строки инициализации. Попытка доступа к таким переменным до инициализации вызывает `ReferenceError`.

## Type conversions

Преобразование типов данных (type conversions) в JavaScript происходит при необходимости привести значение одного типа к другому типу. JavaScript автоматически выполняет преобразования типов во время выполнения операций или при сравнении значений разных типов.
- Преобразование в строку (String Conversion):
Происходит при конкатенации с строкой (+ оператор).
let number = 123;
let string = ‘Number:’ + number;
- Преобразование в число (Number Conversion):
Происходит при арифметических операциях или вызове функции Number().
let string = ‘456’;
let number = Number(string);
let number = +string;
let number = 2;
let result = string * number;
let result = string - number;
- Преобразование в логическое значение (Boolean Conversion):
Происходит при использовании логических операторов (!, &&, ||), операторов сравнения или вызове функции Boolean().
let value = 0;
let boolean = Boolean(value);
- Явное преобразование (Explicit Conversion):
Происходит при использовании явных преобразований с помощью методов String(), Number() и Boolean().

```jsx
let number = 123;
let string = ‘Number:’ + number;
```

- Преобразование в число (Number Conversion):
Происходит при арифметических операциях или вызове функции Number().

```jsx
let string = ‘456’;
let number = Number(string);
let number = +string;
let number = 2;
let result = string * number;
let result = string - number;
```

- Преобразование в логическое значение (Boolean Conversion):
Происходит при использовании логических операторов (!, &&, ||), операторов сравнения или вызове функции Boolean().

```jsx
let value = 0;
let boolean = Boolean(value);
```

- Явное преобразование (Explicit Conversion):
Происходит при использовании явных преобразований с помощью методов String(), Number() и Boolean().

## Ternary, Nullish Coalescing, Optional Chaining, and Logical Operators – Syntax and Use Cases

Тернарный оператор (Ternary Operator) в JavaScript — это условный оператор, который позволяет выполнить различные действия в зависимости от условия.
let age = 20;
let message = (age >= 18) ? ‘Совершеннолетний’ : ‘Несовершеннолетний’;

Nullish Coalescing Operator (оператор слияния на основе нулевого значения) в JavaScript используется для выбора значения из двух вариантов, основываясь на том, является ли первый операнд null или undefined. Этот оператор полезен, когда вам нужно выбрать значение по умолчанию, но при этом не следует использовать пустые строки, нулевые значения или другие “ложные” значения. В отличие от оператора ||, который возвращает второй операнд, если первый является “ложным” значением (false, 0, ’‘, NaN, null или undefined), оператор ?? возвращает второй операнд только в случае, если первый строго равен null или undefined.
let value1 = null;
let value2 = ’значение по умолчанию’;
let result = value1 ?? value2;

Optional Chaining (опциональная цепочка) - это новая возможность в JavaScript, которая позволяет безопасно доступаться к вложенным свойствам объекта или вызывать методы у объектов, которые могут быть null или undefined, без необходимости проверки каждого уровня вложенности. Основная цель - избежать ошибок TypeError, которые могут возникнуть при попытке доступа к свойствам или вызове методов у нулевых или undefined значений.
let user = {
name: ‘John’,
address: {
city: ‘New York’
}
};
// Без optional chaining
let city = user.address ? user.address.city : ‘unknown’;
console.log(city); // Вывод: ‘New York’
// С optional chaining
let city2 = user.address?.city;
console.log(city2); // Вывод: ‘New York’
// Если свойство address отсутствует, city будет равен undefined
let city3 = user.address?.city?.toUpperCase();
console.log(city3); // Вывод: undefined

Logical Operators – Syntax and Use Cases
Логические операторы в JavaScript используются для выполнения логических операций с булевыми значениями.
1. Логическое И (&&)
Синтаксис: условие1 && условие2
Использование: Возвращает true, если оба условия истинны, и false в противном случае.
2. Логическое ИЛИ (||)
Синтаксис: условие1 || условие2
Использование: Возвращает true, если хотя бы одно из условий истинно, и false в противном случае.
3. Логическое НЕ (!)
Синтаксис: !условие
Использование: Инвертирует значение условия. Если условие истинно, то !условие будет ложным, и наоборот.
Логические операторы часто используются в условных выражениях (if, else, while, for и т.д.) для выполнения различных действий в зависимости от условий. Они также могут быть использованы в составных условиях для более сложных логических проверок.

Сравнение объектов c примитивами по значению
const a = {c: 5};
const b = {c: 5};
console.log(JSON.stringify(a) === JSON.stringify(b));

## Loops - for, while, do while

Цикл for: Цикл, который выполняет итерации по заданному количеству раз.
for (инициализация; условие; шаг) {
}
Цикл while: Цикл, который выполняет итерации, пока условие истинно.
while (условие) {
}
Цикл do…while: Цикл, который выполняет итерации, пока условие истинно, но по крайней мере одну итерацию выполнит даже если условие неверно.
do {
} while (условие);

## Switch case - examples where it can be useful

Конструкция switch в JavaScript полезна в ситуациях, когда у вас есть одно выражение, которое нужно сравнить с несколькими возможными значениями.
switch (new Date().getDay()) {
case 0:
console.log(‘Воскресенье’);
break;
case 1:
console.log(‘Понедельник’);
break;
case 2:
console.log(‘Вторник’);
break;
// и так далее…
default:
console.log(‘Неизвестный день’);
}
switch может работать только с определенными типами данных (например, числами, строками и некоторыми другими), в то время как if-else может проверять любые логические условия.

## задачки

как скопировать массив с примитивами
const copiedArray = […originalArray]; // оператора spread
const copiedArray = Array.from(originalArray);
const copiedArray = originalArray.slice();

как скопировать объект с примитивами
const copiedObject = {…originalObject};
const copiedObject = Object.assign({}, originalObject);

распарсить строку в объект https://www.youtube.com/watch?student=Vasya&Github=Vasya99&status=true
const parseString = (string) => {
return string
.split(“?”)[1]
.split(“&”)
.reduce((acc, currentValue) => {
const [key, value] = currentValue.split(“=”);
acc[key] = value;
return acc;
}, {});
};

## Event Loop

Number.isFinite(value): Проверяет, является ли переданное значение конечным числом (не Infinity или -Infinity).
Number.isInteger(value): Проверяет, является ли переданное значение целым числом.
Number.isNaN(value): Проверяет, является ли переданное значение NaN (не числом).
Number.isSafeInteger(value): Проверяет, является ли переданное значение “безопасным” целым числом в пределах -(2^53 - 1) и 2^53 - 1.
Number.parseFloat(string): Преобразует строку в число с плавающей точкой.
Number.parseInt(string): Преобразует строку в целое число.

## String methods & String templates

charAt(index): Возвращает символ в указанной позиции.
charCodeAt(index): Возвращает код символа в указанной позиции.
concat(string2, string3, …, stringN): Объединяет строки.
includes(searchString, position): Проверяет, содержит ли строка указанную подстроку.
indexOf(searchValue, fromIndex): Возвращает индекс первого вхождения подстроки.
lastIndexOf(searchValue, fromIndex): Возвращает индекс последнего вхождения подстроки.
slice(start, end): Извлекает часть строки и возвращает новую строку.
split(separator, limit): Разбивает строку на массив подстрок.
substring(start, end): Возвращает подстроку между указанными индексами.
toLowerCase(): Преобразует строку в нижний регистр.
toUpperCase(): Преобразует строку в верхний регистр.
trim(): Удаляет пробельные символы в начале и конце строки.
startsWith(searchString, position): Проверяет, начинается ли строка с указанной подстроки.
endsWith(searchString, length): Проверяет, заканчивается ли строка указанной подстрокой.
repeat(count): Повторяет строку указанное количество раз.
replace(searchValue, replaceValue): Заменяет подстроку другой строкой.
match(regexp): Выполняет поиск совпадений с указанным регулярным выражением.
padStart(targetLength, padString): Дополняет строку указанным символом слева до указанной длины.
padEnd(targetLength, padString): Дополняет строку указанным символом справа до указанной длины.
trimStart() / trimLeft(): Удаляет пробельные символы в начале строки.
trimEnd() / trimRight(): Удаляет пробельные символы в конце строки.

## Strict comparison

Строгое сравнение, часто называемое “строгой равенством”, - это метод сравнения в языках программирования, таких как JavaScript, который проверяет как значения, так и типы операндов, которые сравниваются.
В отличие от строгого сравнения, нестрогое или абстрактное сравнение (двойное равенство ==) выполняет приведение типов, то есть пытается преобразовать значения в один и тот же тип перед их сравнением. Это может привести к неожиданным результатам и обычно считается менее надежным, чем строгое сравнение.

### в чем отличие null и underfind

### Что возвращает асинхронная функция, что такое Promise

Асинхронная функция в JavaScript возвращает объект Promise. Promise - это объект, представляющий успешное выполнение или ошибку асинхронной операции и позволяющий обработать результат в будущем. Promise может находиться в одном из трех состояний: ожидание (pending), выполнено (fulfilled) или отклонено (rejected).

Если асинхронная функция не содержит оператора return или завершается без явного возврата значения, она также будет возвращать объект Promise с состоянием “выполнено” (fulfilled), и результатом этого Promise будет undefined. То есть, по умолчанию, если асинхронная функция завершается без явного возврата значения, её Promise будет разрешен значением undefined.

 Может ли Promise никогда не закончиться? Да, Promise в JavaScript может никогда не закончиться, если она не будет разрешена (fulfilled) или отклонена (rejected). Promise представляет собой объект, который представляет промежуточное состояние асинхронной операции и позволяет обрабатывать результат этой операции, когда она завершится.

Promise может "зависнуть" в состоянии ожидания (pending), если асинхронная операция внутри Promise не завершится. Это может произойти по разным причинам:

1. **Не завершающая операция**: Если в коде, который выполняется внутри Promise, нет корректного завершения, то Promise может остаться в состоянии ожидания. Например, если внутри Promise есть бесконечный цикл или операция, которая никогда не завершается, Promise останется в состоянии ожидания.
2. **Ошибки в коде**: Если произошла ошибка внутри асинхронной операции, которая не обрабатывается должным образом, Promise также может остаться в состоянии ожидания.
3. **Недостаток ресурсов**: Если асинхронная операция требует ресурсов, которые в данный момент недоступны, Promise может не завершиться до тех пор, пока ресурсы не станут доступны.

Для предотвращения таких ситуаций важно правильно обрабатывать все возможные состояния и исключения внутри Promise, а также учитывать возможность "зависания" асинхронных операций.

- Промис создаётся с функцией, которая не вызывает ни `resolve`, ни `reject`.
- Следовательно, промис остаётся в состоянии "ожидания" (pending) навсегда.

```jsx
const neverEndingPromise = new Promise((resolve, reject) => {
   // Промис никогда не переходит в состояние fulfilled или rejected
});
// Пример использования (эти строки никогда не будут выполнены)
neverEndingPromise.then(
  () => console.log("Promise resolved"),
  () => console.log("Promise rejected")
);
```

Как принудительно закончить Promise через 5 секунд? 

Классический `Promise` в JavaScript не предоставляет прямого способа прерывания или завершения. Однако, вы можете реализовать таймер с помощью функции `setTimeout` и использовать `Promise.race` для управления временем ожидания.

Вот пример того, как можно сделать это:

```jsx
function createNeverEndingPromise() {
  return new Promise((resolve, reject) => {
    // Здесь ничего не делаем, чтобы промис висел в состоянии "ожидание"
  });
}
function withTimeout(promise, timeout) {
  return Promise.race([
    promise,
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Promise timed out')), timeout)
    )
  ]);
}
// Используем промис, который никогда не завершается
const neverEndingPromise = createNeverEndingPromise();
// Добавляем тайм-аут на 5 секунд
withTimeout(neverEndingPromise, 5000)
  .then(() => {
    console.log('Promise resolved');
  })
  .catch((error) => {
    console.log('Error:', error.message); // В этом случае: 'Promise timed out'
  });
```

### Методы Promise

### 1. `Promise.resolve(value)`

Возвращает промис, который переходит в состояние "исполнен" с заданным значением. Если переданное значение уже является промисом, возвращается тот же промис.

- **Аргументы**: `value` — значение, которое будет использоваться для разрешения промиса.
- **Возвращает**: Промис, который будет исполнен с указанным значением.

**Пример:**

```jsx
Promise.resolve(42).then(value => {
  console.log(value); // 42
});
```

### 2. `Promise.reject(reason)`

Возвращает промис, который переходит в состояние "отклонён" с указанной причиной.

- **Аргументы**: `reason` — причина отклонения промиса.
- **Возвращает**: Промис, который будет отклонён с указанной причиной.

**Пример:**

```jsx
Promise.reject(new Error('Something went wrong')).catch(error => {
  console.log(error.message); // 'Something went wrong'
});
```

### 3. `Promise.all(iterable)`

Принимает итерируемый объект (например, массив) промисов и возвращает новый промис, который исполняется, когда все промисы в итерируемом объекте выполнены, либо отклоняется, если любой из промисов отклонён.

- **Аргументы**: `iterable` — итерируемый объект (например, массив) промисов.
- **Возвращает**: Промис, который исполнится с массивом результатов всех промисов, если все промисы были исполнены успешно, или отклонится, если любой из промисов был отклонён.

**Пример:**

```jsx
Promise.all([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)])
  .then(values => {
    console.log(values); // [1, 2, 3]
  });
```

### 4. `Promise.allSettled(iterable)`

Принимает итерируемый объект промисов и возвращает промис, который исполняется, когда все промисы в итерируемом объекте завершены (независимо от их состояния). Результат будет массивом объектов, каждый из которых имеет статус и значение или причину.

- **Аргументы**: `iterable` — итерируемый объект промисов.
- **Возвращает**: Промис, который исполнится с массивом объектов, содержащих информацию о выполнении каждого промиса (успешно или с ошибкой).

**Пример:**

```jsx
Promise.allSettled([
  Promise.resolve(1),
  Promise.reject(new Error('Failed')),
  Promise.resolve(3)
]).then(results => {
  console.log(results);
  /*
  [
    { status: 'fulfilled', value: 1 },
    { status: 'rejected', reason: Error('Failed') },
    { status: 'fulfilled', value: 3 }
  ]
  */
});
```

### 5. `Promise.any(iterable)`

Принимает итерируемый объект промисов и возвращает новый промис, который исполняется, когда первый из промисов в итерируемом объекте исполняется успешно. Если все промисы отклонены, возвращается ошибка `AggregateError`.

- **Аргументы**: `iterable` — итерируемый объект промисов.
- **Возвращает**: Промис, который исполнится с результатом первого успешно исполненного промиса или отклонится с `AggregateError`, если все промисы были отклонены.

**Пример:**

```jsx
Promise.any([
  Promise.reject(new Error('Failed 1')),
  Promise.reject(new Error('Failed 2')),
  Promise.resolve(3)
]).then(value => {
  console.log(value); // 3
});
```

### 6. `Promise.race(iterable)`

Принимает итерируемый объект промисов и возвращает новый промис, который исполняется или отклоняется, как только первый промис в итерируемом объекте выполнится или отклонится.

- **Аргументы**: `iterable` — итерируемый объект промисов.
- **Возвращает**: Промис, который исполняется или отклоняется первым из промисов в итерируемом объекте.

**Пример:**

```jsx
Promise.race([
  new Promise((resolve, reject) => setTimeout(reject, 100, 'Error')),
  new Promise((resolve) => setTimeout(resolve, 50, 'Success'))
]).then(value => {
  console.log(value); // 'Success'
}).catch(error => {
  console.log(error);
});
```

### 7. `Promise.prototype.then(onFulfilled, onRejected)`

Метод, который добавляет обработчики к промису, и возвращает новый промис, который будет разрешён результатом вызова обработчика.

- **Аргументы**:
    - `onFulfilled` — функция, которая будет вызвана, если промис будет выполнен успешно.
    - `onRejected` — функция, которая будет вызвана, если промис будет отклонён.
- **Возвращает**: Новый промис, который будет разрешён результатом вызова обработчика `onFulfilled` или `onRejected`.

**Пример:**

```jsx
const promise = Promise.resolve(42);
promise.then(value => {
  console.log(value); // 42
});
```

### 8. `Promise.prototype.catch(onRejected)`

Метод, который добавляет обработчик для отклонённого промиса и возвращает новый промис с результатом вызова обработчика.

- **Аргументы**:
    - `onRejected` — функция, которая будет вызвана, если промис будет отклонён.
- **Возвращает**: Новый промис, который будет разрешён результатом вызова обработчика `onRejected`.

**Пример:**

```jsx
const promise = Promise.reject(new Error('Oops'));
promise.catch(error => {
  console.log(error.message); // 'Oops'
});
```

### 9. `Promise.prototype.finally(onFinally)`

Метод, который добавляет обработчик, который будет вызван независимо от того, завершился промис успешно или с ошибкой.

- **Аргументы**:
    - `onFinally` — функция, которая будет вызвана после завершения промиса, независимо от его состояния.
- **Возвращает**: Новый промис, который будет разрешён с результатом оригинального промиса.

**Пример:**

```jsx
const promise = Promise.resolve(42);
promise.finally(() => {
  console.log('Cleanup code');
}).then(value => {
  console.log(value); // 42
});
```

### что такое замыкание в JavaScript

Замыкание (closure) в JavaScript — это особенность языка, которая позволяет функции сохранять доступ к переменным из внешней области видимости, даже после завершения выполнения этой функции. Замыкания создаются тогда, когда функция определена внутри другой функции (родительской) и имеет доступ к переменным родительской функции.

Пример замыкания:
function outerFunction() {
var outerVariable = 10;
function innerFunction() {
console.log(outerVariable);
}
return innerFunction;
}
var closure = outerFunction();
closure(); // Выведет 10

```
function outerFunction() {
  var outerVariable = 10;
  function innerFunction() {
    console.log(outerVariable);
  }
  return innerFunction;
}
var closure = outerFunction();
closure(); // Выведет 10
```

В приведенном примере innerFunction является замыканием, потому что она определена внутри outerFunction и имеет доступ к переменной outerVariable из внешней области видимости. Когда outerFunction вызывается и возвращает innerFunction, создается замыкание closure. Затем вызов closure() сохраняет доступ к переменной outerVariable, и она может быть использована внутри innerFunction.

Замыкания в JavaScript часто используются для создания приватных переменных, сохранения состояния функции между вызовами, а также для создания функций обратного вызова и функций высшего порядка.

### Что такое микро и макро таски?

### Get и POST в чем их различие?

Они определяют тип запроса, который клиент отправляет серверу, и обычно используются в различных контекстах.
GET:
Используется для запроса данных от сервера.
Параметры передаются в URL (через строку запроса).
Данные ограничены по длине (ограничение URL-длины браузера).
Данные передаются открыто, видны в URL.
Часто используется для запросов, которые не изменяют состояние на сервере
POST:
Используется для отправки данных на сервер для обработки.
Параметры передаются в теле запроса.
Данные могут быть более объемными и безопасными, так как они не отображаются в URL.
Обычно используется для запросов, которые изменяют состояние на сервере (например, отправка данных формы).

### Можно ли передать данные в GET запросе?

Данные передаются через строку запроса (query string), которая добавляется к URL. Эти данные обычно представлены в виде параметров ключ-значение. Данные, передаваемые в GET-запросе, видны в URL, и они могут быть легко увидены пользователями, что может быть проблематичным с точки зрения безопасности, особенно если эти данные содержат чувствительную информацию, такую как пароли. Поэтому, для передачи более конфиденциальных данных, часто используется метод POST

## JSCORE

JavaScript Topics:

Advanced Expressions

### Understanding Object.is (optional).

Object.is() в JavaScript - это метод, который используется для сравнения двух значений на строгое равенство, без приведения типов. В отличие от операторов сравнения (=== и ==), Object.is() обрабатывает специальные значения, такие как NaN и -0, более точно.

### Differences between let, var, and const.

Концепция временной мертвой зоны (Temporal Dead Zone, TDZ) является важной особенностью в JavaScript, которая возникает при доступе к переменным, объявленным с использованием ключевых слов let и const, до их инициализации. В это время попытка доступа к таким переменным вызовет ошибку времени выполнения. Это происходит потому, что хотя переменные, объявленные с помощью var, поднимаются (hoisted) и инициализируются значением undefined, переменные, объявленные с let и const, также поднимаются, но не инициализируются, и любая попытка доступа к ним до их фактической инициализации приведет к ошибке ReferenceError.

Вот пример, иллюстрирующий временную мертвую зону:
console.log(x); // Вызовет ReferenceError
let x = 10;
В этом примере, хотя x объявлена позже в коде, попытка доступа к ней до ее объявления приведет к ошибке ReferenceError из-за нахождения переменной во временной мертвой зоне.

### Concepts of Hoisting.

Поднятие (hoisting) - это механизм в JavaScript, который поднимает объявления переменных и функций вверх внутри их области видимости перед выполнением кода. Это означает, что даже если вы обращаетесь к переменной или функции до их фактического объявления в коде, JavaScript все равно “поднимет” их объявления вверх области видимости.
Поднятие переменных (var):
Переменные, объявленные с помощью ключевого слова var, поднимаются в начало своей области видимости. Однако, они инициализируются значением undefined, если им не было присвоено другое значение.
Пример:
console.log(x); // undefined
var x = 10;
console.log(x); // 10
Поднятие функций:
Объявления функций также поднимаются вверх в своей области видимости.
Пример:
sayHello(); // “Hello!”
function sayHello() {
console.log(“Hello!”);
}
Поднятие let и const:
Переменные, объявленные с помощью let и const, также поднимаются в начало своей области видимости, но они остаются в “зоне временной мертвой зоны” (Temporal Dead Zone, TDZ) до момента их фактического объявления. Попытка доступа к таким переменным до их инициализации вызовет ошибку.
Пример:
console.log(y); // Throws a ReferenceError
let y = 10;

### The role of polyfills.

Полифиллы представляют собой кодовые фрагменты или скрипты, которые эмулируют функциональность новых функций в старых браузерах, что позволяет разработчикам писать код с использованием последних стандартов и обеспечивать совместимость с широким спектром браузеров.

Вот более подробное объяснение роли полифиллов:
Заполнение пробелов в поддержке браузеров:
Полифиллы заполняют пробелы в поддержке браузеров, предоставляя реализации JavaScript для функций, которые не поддерживаются нативно в старых браузерах. Например, если браузер не поддерживает объект Promise, можно использовать полифилл, чтобы обеспечить необходимую функциональность.
Обеспечение кросс-браузерной совместимости:
При помощи полифиллов разработчики могут обеспечить однородное поведение и функциональность своих веб-приложений в разных браузерах, независимо от того, поддерживают ли эти браузеры определенные функции нативно или нет. Это помогает обеспечить однородный пользовательский опыт для всех пользователей, независимо от используемого ими браузера.
Возможность прогрессивного улучшения:
Полифиллы позволяют применять прогрессивное улучшение, позволяя разработчикам использовать современные технологии веба, обеспечивая при этом обратную совместимость со старыми браузерами. Разработчики могут писать код, используя последние стандарты, и затем использовать полифиллы для обеспечения поддержки старых браузеров, тем самым гарантируя, что пользователи с новыми браузерами получают расширенные возможности, а пользователи со старыми браузерами всё равно получают функциональный опыт.
Снижение необходимости в коде, специфичном для браузера:
Вместо написания кода, специфичного для браузера, для обработки поддержки функций, разработчики могут полагаться на полифиллы для обеспечения однородной функциональности в разных браузерах. Это снижает сложность разработки и поддержки, позволяя разработчикам писать код на стандартизированных API и функциях.
Содействие внедрению новых стандартов:
Полифиллы могут помочь в внедрении новых веб-стандартов, позволяя разработчикам использовать новые функции в своих проектах даже до их широкой поддержки в браузерах. Это стимулирует экспериментирование и инновации в веб-разработке, так как разработчики могут начать использовать новые возможности без ожидания универсальной поддержки браузерами.

Functions

### Чему равен this? Что такое контекст?

Контекст определяет, к какому объекту ссылается `this` внутри функции или метода. Значение `this` зависит от того, как была вызвана функция.

`this` в JavaScript — это специальное ключевое слово, которое ссылается на контекст выполнения функции. Значение `this` зависит от того, как функция была вызвана, и может принимать разные значения в разных контекстах. Рассмотрим основные контексты и нюансы работы `this`.

### Основные контексты `this`

1. **Глобальный контекст (вне функции)**:
    - В глобальной области видимости (вне любой функции) `this` ссылается на глобальный объект (`window` в браузерах и `global` в Node.js).
    
    ```jsx
    console.log(this); // В браузере: Window, в Node.js: global
    ```
    
2. **Методы объекта**:
    - Когда функция вызывается как метод объекта, `this` ссылается на объект, которому принадлежит метод.
    
    ```jsx
    const person = {
      name: 'Alice',
      greet() {
        console.log(this.name); // 'Alice'
      }
    };
    person.greet();
    ```
    
3. **Конструктор (функция с `new`)**:
    - Когда функция вызывается как конструктор с помощью ключевого слова `new`, `this` ссылается на новый объект, создаваемый этой функцией.
    
    ```jsx
    function Person(name) {
      this.name = name;
    }
    const alice = new Person('Alice');
    console.log(alice.name); // 'Alice'
    ```
    
4. **Функции в строгом режиме (strict mode)**:
    - В строгом режиме (`'use strict';`), если функция вызывается как обычная функция, `this` будет `undefined`.
    
    ```jsx
    'use strict';
    function show() {
      console.log(this); // undefined
    }
    show();
    ```
    
5. **Стрелочные функции**:
    - В стрелочных функциях значение `this` наследуется от окружающего контекста, в котором функция была создана. Стрелочные функции не имеют собственного `this`.
    
    ```jsx
    const person = {
      name: 'Alice',
      greet() {
        const innerFunction = () => {
          console.log(this.name); // 'Alice'
        };
        innerFunction();
      }
    };
    person.greet();
    ```
    
6. **Методы `call` и `apply`**:
    - Метод `call` и метод `apply` позволяют явно указать значение `this` при вызове функции.
    
    ```jsx
    function greet() {
      console.log(this.name);
    }
    const person = { name: 'Alice' };
    greet.call(person); // 'Alice'
    greet.apply(person); // 'Alice'
    ```
    
7. **Метод `bind`**:
    - Метод `bind` создаёт новую функцию с привязанным значением `this`. Он не вызывает функцию, а возвращает новую функцию с установленным значением `this`.
    
    ```jsx
    function greet() {
      console.log(this.name);
    }
    const person = { name: 'Alice' };
    const boundGreet = greet.bind(person);
    boundGreet(); // 'Alice'
    ```
    

### Нюансы

1. **Функция в методе объекта**:
    - Если метод объекта вызывается в контексте другого объекта, `this` будет ссылаться на новый объект.
    
    ```jsx
    const obj1 = {
      value: 1,
      method() {
        console.log(this.value);
      }
    };
    const obj2 = {
      value: 2,
      method: obj1.method
    };
    obj2.method(); // 2, так как `this` указывает на `obj2`
    ```
    
2. **`this` в колбэках**:
    - В колбэках, особенно при передаче функции как аргумента, значение `this` может потеряться, если не использовать привязку с `bind` или не использовать стрелочные функции.
    
    ```jsx
    function Timer() {
      this.seconds = 0;
      setInterval(function() {
        this.seconds++;
        console.log(this.seconds);
      }, 1000);
    }
    const timer = new Timer(); // `this` в setInterval не указывает на объект Timer
    ```
    
    Чтобы исправить это, можно использовать стрелочную функцию:
    
    ```jsx
    function Timer() {
      this.seconds = 0;
      setInterval(() => {
        this.seconds++;
        console.log(this.seconds);
      }, 1000);
    }
    const timer = new Timer(); // `this` указывает на объект Timer
    ```
    
3. **Методы класса**:
    - В методах класса `this` ссылается на экземпляр класса.
    
    ```jsx
    class Person {
      constructor(name) {
        this.name = name;
      }
      greet() {
        console.log(this.name);
      }
    }
    const alice = new Person('Alice');
    alice.greet(); // 'Alice'
    ```
    
4. **Функции, используемые как обработчики событий**:
    - В обработчиках событий `this` указывает на элемент, на котором событие произошло.
    
    ```jsx
    document.getElementById('myButton').addEventListener('click', function() {
      console.log(this); // элемент, на который был клик
    });
    ```
    

## Чем отличается call apply и bind

В JavaScript методы `call`, `apply` и `bind` используются для управления контекстом выполнения функции, то есть значением `this`. Вот подробное объяснение каждого из них и их отличий.

### Метод `call`

Метод `call` вызывает функцию с указанным значением `this` и аргументами, переданными по отдельности.

**Синтаксис:**

```jsx
func.call(thisArg, arg1, arg2, ...)
```

**Пример:**

```jsx
function greet(greeting, punctuation) {
  console.log(greeting + ', ' + this.name + punctuation);
}
const person = { name: 'Alice' };
greet.call(person, 'Hello', '!'); // Output: Hello, Alice!
```

### Метод `apply`

Метод `apply` вызывает функцию с указанным значением `this` и аргументами, переданными в виде массива (или псевдомассива).

**Синтаксис:**

```jsx
func.apply(thisArg, [argsArray])
```

**Пример:**

```jsx
function greet(greeting, punctuation) {
  console.log(greeting + ', ' + this.name + punctuation);
}
const person = { name: 'Alice' };
greet.apply(person, ['Hello', '!']); // Output: Hello, Alice!
```

### Метод `bind`

Метод `bind` создает новую функцию, которая при вызове будет иметь указанное значение `this` и заданные аргументы.

**Синтаксис:**

```jsx
const boundFunc = func.bind(thisArg, arg1, arg2, ...)
```

**Пример:**

```jsx
function greet(greeting, punctuation) {
  console.log(greeting + ', ' + this.name + punctuation);
}
const person = { name: 'Alice' };
const boundGreet = greet.bind(person, 'Hello');
boundGreet('!'); // Output: Hello, Alice!
```

### Ключевые отличия

1. **Мгновенное выполнение:**
    - `call` и `apply` вызывают функцию немедленно.
    - `bind` возвращает новую функцию, которую можно вызвать позже.
2. **Передача аргументов:**
    - `call` принимает аргументы, передаваемые по отдельности.
    - `apply` принимает аргументы в виде массива.
    - `bind` принимает аргументы по отдельности и фиксирует их для новой функции.
3. **Применение:**
    - Используйте `call`, когда у вас есть список аргументов.
    - Используйте `apply`, когда у вас есть массив аргументов или псевдомассив.
    - Используйте `bind`, когда вы хотите создать новую функцию с зафиксированным контекстом `this` и/или частичными аргументами.

### Примеры использования

### Пример использования `call`:

```jsx
const person = { name: 'Alice' };
function greet(greeting) {
  console.log(greeting + ', ' + this.name);
}
reet.call(person, 'Hello'); // Output: Hello, Alice
```

### Пример использования `apply`:

```jsx
const person = { name: 'Alice' };
function greet(greeting, punctuation) {
  console.log(greeting + ', ' + this.name + punctuation);
}
greet.apply(person, ['Hello', '!']); // Output: Hello, Alice!
```

### Пример использования `bind`:

```jsx
const person = { name: 'Alice' };
function greet(greeting, punctuation) {
  console.log(greeting + ', ' + this.name + punctuation);
}
const boundGreet = greet.bind(person, 'Hello');
boundGreet('!'); // Output: Hello, Alice!
```

### Differences and uses of arrow functions, function expressions, and function declarations. Какие есть виды функций? Какие способы создания функций?

Объявления функций (function declarations):
Синтаксис: Объявление функций происходит с использованием ключевого слова function, за которым следует имя функции и список параметров в круглых скобках.
Поднятие (hoisting): Функции, объявленные таким образом, поднимаются вверх своей области видимости, что позволяет вызывать их до фактического объявления в коде.
this: Привязка this зависит от того, как функция вызывается. В методах объекта this указывает на сам объект.
Использование: Объявления функций удобны для определения и использования функций в глобальной области видимости или в области видимости блока кода.
function greet() {
console.log(“Hello,” + this.name + “!”);
}
const obj = {
name: “John”,
sayHello: greet
};

Синтаксис: Объявление функций происходит с использованием ключевого слова function, за которым следует имя функции и список параметров в круглых скобках.
Поднятие (hoisting): Функции, объявленные таким образом, поднимаются вверх своей области видимости, что позволяет вызывать их до фактического объявления в коде.
this: Привязка this зависит от того, как функция вызывается. В методах объекта this указывает на сам объект.
Использование: Объявления функций удобны для определения и использования функций в глобальной области видимости или в области видимости блока кода.

```tsx
function greet() {
  console.log("Hello," + this.name + "!");
}
const obj = {
  name: "John",
  sayHello: greet,
};
obj.sayHello(); // Выведет "Hello, John!"
```

### Выражения функций (function expressions):

Синтаксис: Функции определяются как часть выражения и могут быть присвоены переменной или использованы в качестве аргумента функции.
Поднятие (hoisting): Функции, определенные как выражения, не поднимаются вверх, и их необходимо определять перед использованием.
this: Привязка this также зависит от контекста вызова функции.
Использование: Выражения функций часто используются для определения анонимных функций или для передачи функций в качестве аргументов другим функциям.

```
const greet = function () {
  console.log("Hello," + this.name + "!");
};
const obj = {
  name: "John",
  sayHello: greet,
};
obj.sayHello(); // Выведет "Hello, John!"
```

### Стрелочные функции (arrow functions)

Синтаксис: Стрелочные функции имеют более короткий синтаксис с использованием оператора =>.
Лексическое this: Значение this внутри стрелочной функции берется из лексического контекста, в котором она была определена, а не из контекста вызова. Это означает, что this в стрелочной функции наследуется из окружающей области видимости.
Отсутствие arguments: Стрелочные функции также не имеют своего собственного объекта arguments.
Использование: Стрелочные функции обычно используются для написания более короткого и читаемого кода, особенно в обработчиках событий и внутри других функций.

```
const greet = () => {
  console.log("Hello," + this.name + "!");
};
const obj = {
  name: "John",
  sayHello: greet,
};
obj.sayHello(); // Выведет "Hello, undefined!"
```

Важно помнить, что использование различных типов функций зависит от конкретной задачи и требований проекта. Если вам нужна привязка this к объекту, обычно предпочтительнее использовать объявления функций или выражения функций. Однако, если вам нужно использовать лексическое this или если вы хотите написать более краткий и читаемый код, стрелочные функции могут быть хорошим выбором.

### Functional Scope

Функциональная область видимости (Functional Scope) относится к области видимости переменных, определенных внутри функций в JavaScript. Каждая функция создает свою собственную область видимости, в которой переменные, объявленные внутри функции, могут быть доступны только из этой функции и из вложенных функций.

### Global scope vs functional scope.

Глобальная область видимости охватывает всю программу JavaScript, включая все функции и переменные, определенные в глобальной области.
Доступность переменных: Переменные, объявленные без ключевого слова var, let или const, автоматически становятся глобальными и доступны из любой части программы.

Функциональная область видимости создается при объявлении функции и ограничивает доступность переменных внутри этой функции и вложенных в нее функций.
Доступность переменных: Переменные, объявленные внутри функции с помощью ключевых слов var, let или const, видны только внутри этой функции и не доступны из внешних областей видимости.
Функциональная область видимости также позволяет создавать замыкания, когда внутренняя функция сохраняет ссылку на переменные из внешней функции, даже после завершения выполнения внешней функции.

### Variable visibility areas.

Глобальная область видимости (Global Scope):
Переменные, объявленные в глобальной области видимости, доступны во всем скрипте.
Они могут быть использованы в любой части программы, включая функции и блоки кода.
Переменные, объявленные без ключевых слов var, let или const, автоматически становятся глобальными.

Функциональная область видимости (Functional Scope):
Переменные, объявленные внутри функций, имеют функциональную область видимости и доступны только внутри этой функции и вложенных в нее функций.
Они недоступны вне функции, в которой они были объявлены.
Переменные, объявленные с помощью ключевых слов var, let или const внутри функции, будут видны только внутри этой функции.

Блочная область видимости (Block Scope):
Введена в ECMAScript 6 (ES6) с использованием ключевых слов let и const.
Переменные, объявленные с помощью let или const, имеют блочную область видимости и доступны только в блоке кода, в котором они были объявлены.
Блоки кода могут быть областью видимости для условных операторов if, циклов for, while, блоков функций и т. д.

### Working with nested scopes.

Доступ к переменным внешних областей видимости:
Вложенная функция или блок кода может получить доступ к переменным из внешней области видимости.
Это происходит благодаря механизму замыканий, когда вложенная функция сохраняет ссылку на область видимости внешней функции.
Пример:
function outerFunction() {
let outerVar = ‘I am from outer function’;
function innerFunction() {
console.log(outerVar); // Доступ к outerVar из внутренней функции
}
innerFunction();
}
outerFunction(); // Выведет “I am from outer function”
Замыкания (Closures):
Когда функция объявлена внутри другой функции, она захватывает (замыкает) область видимости внешней функции, что позволяет ей сохранить доступ к переменным этой внешней функции даже после завершения выполнения внешней функции.
Это позволяет создавать гибкие и мощные конструкции в JavaScript.
Понимание областей видимости:
При работе с вложенными областями видимости важно понимать, что внутренняя область видимости имеет доступ к переменным из внешней области, но не наоборот.
То есть переменные, объявленные внутри вложенной функции, не будут доступны во внешней области видимости.

### Functions Parameters / Arguments

Параметры функции:
Параметры функции - это переменные, которые объявляются в скобках при определении функции и используются для передачи данных внутрь функции.
Параметры являются локальными переменными внутри функции и доступны только внутри этой функции.
Функция может иметь любое количество параметров или не иметь их вовсе.
Аргументы функции:
Аргументы функции - это значения, передаваемые при вызове функции и соответствующие параметрам функции.
Аргументы могут быть любого типа данных: строки, числа, массивы, объекты и т. д.
Количество аргументов должно соответствовать количеству параметров функции при вызове, иначе будут использоваться значения по умолчанию (если они определены) или будет считаться, что параметры, для которых нет аргументов, равны undefined.
Использование параметров и аргументов:
Параметры и аргументы используются для передачи данных в функцию.
Параметры функции можно использовать внутри функции так же, как локальные переменные.
Значения аргументов можно использовать для выполнения операций внутри функции или для передачи в другие функции.
Значения по умолчанию для параметров:
В JavaScript можно установить значения по умолчанию для параметров функции, которые будут использоваться, если вызванная функция не передает аргумент для этого параметра или передает undefined

### Defining function parameters.

Определение параметров:
Параметры функции указываются в скобках после имени функции при ее определении.
Каждый параметр представляет собой локальную переменную внутри функции, которая будет использоваться для хранения переданных значений.
Вы можете указать любое количество параметров для функции, от нуля и более.
Использование параметров:
Параметры функции могут использоваться внутри функции точно так же, как обычные локальные переменные.
Вы можете использовать параметры для выполнения операций внутри функции или для передачи в другие функции.
Значения по умолчанию:
Вы можете установить значения по умолчанию для параметров функции, которые будут использоваться, если вызванная функция не передает аргумент для этого параметра или передает undefined.
Значения по умолчанию указываются в определении функции с помощью оператора присваивания (=).
Деструктуризация параметров:
Вы можете использовать деструктуризацию объектов для работы с параметрами функции.
Это позволяет передавать объект в качестве аргумента и извлекать значения из этого объекта внутри функции.

### Differences in parameters passing by value and by reference.

Передача параметров по значению:
При передаче параметров по значению копия значения передается в функцию, а не сама переменная.
Это означает, что изменения, внесенные в параметр внутри функции, не влияют на оригинальную переменную, из которой был передан аргумент.
Пример:
function increment(x) {
x = x + 1;
console.log(x); // Выведет значение, увеличенное на 1
}
let num = 5;
increment(num); // Передача значения переменной num в функцию
console.log(num); // Выведет оригинальное значение переменной num (5), не изменившееся
Передача параметров по ссылке:
При передаче параметров по ссылке передается ссылка на объект в памяти, а не его копия.
Это означает, что если вы измените свойство объекта внутри функции, это изменение отразится на оригинальном объекте, из которого был передан аргумент.
Пример:
function changeName(person) {
person.name = ‘Alice’;
console.log(person); // Выведет объект с измененным свойством name
}
let user = { name: ‘Bob’ };
changeName(user); // Передача ссылки на объект user в функцию
console.log(user); // Выведет объект с измененным свойством name (‘Alice’)

Передача по значению применяется к простым типам данных, таким как числа и строки.
Передача по ссылке применяется к сложным типам данных, таким как объекты и массивы.
Понимание этих различий поможет в избежании неожиданных побочных эффектов и правильном управлении данными в вашем коде.

### Handling a dynamic amount of function parameters.

Обработка динамического количества параметров функции является важной возможностью в JavaScript, которая позволяет функции принимать переменное количество аргументов без необходимости предварительного определения их числа. Давайте рассмотрим различные методы обработки динамического количества параметров подробнее:
Использование объекта arguments:
В JavaScript любая функция имеет доступ к объекту arguments, который представляет собой массивоподобный объект, содержащий все переданные функции аргументы.
arguments можно использовать для доступа к переданным аргументам внутри функции, независимо от их количества.
Пример использования arguments:
function sum() {
let result = 0;
for (let i = 0; i < arguments.length; i++) {
result += arguments[i];
}
return result;
}
console.log(sum(1, 2, 3)); // Выведет 6
console.log(sum(1, 2, 3, 4, 5)); // Выведет 15
Использование оператора rest (…):
В современном JavaScript есть более удобный способ работы с динамическим количеством параметров - оператор rest (…).
Оператор rest позволяет собирать оставшиеся аргументы функции в массив, что делает код более читаемым и удобным.
Пример использования оператора rest:
function sum(…args) {
return args.reduce((acc, current) => acc + current, 0);
}
console.log(sum(1, 2, 3)); // Выведет 6
console.log(sum(1, 2, 3, 4, 5)); // Выведет 15
Выбор между arguments и оператором rest:
В большинстве случаев предпочтительнее использовать оператор rest, так как он более читаемый и имеет более явное поведение.
Однако arguments все еще полезен, если вам нужно работать с аргументами как с массивом в старом коде или если вам нужна поддержка старых версий JavaScript.

Closures Advanced
### Understanding context and lexical environments.
Контекст выполнения (Execution Context) - это абстрактное понятие, которое описывает среду, в которой выполняется код JavaScript.
Каждый раз, когда JavaScript интерпретирует и выполняет код, он создает новый контекст выполнения.
Контекст выполнения содержит информацию о переменных, функциях, объектах и других данных, доступных в текущем контексте выполнения.
Каждая функция создает свой собственный контекст выполнения при вызове.
В JavaScript существует глобальный контекст выполнения, а также контекст выполнения функций.
Лексическая среда (Lexical Environment) представляет собой структуру данных, которая связывает идентификаторы (например, переменные и функции) с их значениями во время выполнения кода.
Каждая функция в JavaScript имеет свою собственную лексическую среду, которая содержит ссылку на лексическую среду, в которой эта функция была определена.
Это позволяет функциям иметь доступ к переменным и функциям из своего лексического окружения, даже если они вызываются в другом месте.
Концепция лексической среды играет ключевую роль в работе замыканий в JavaScript.
Пример:
function outerFunction() {
let outerVar = ‘Outer Variable’;

```
function innerFunction() {
    let innerVar = 'Inner Variable';
    console.log(outerVar); // Доступ к outerVar из лексического окружения внешней функции
}

innerFunction();
```

}
outerFunction(); // Выведет ‘Outer Variable’
Здесь функция innerFunction имеет доступ к переменной outerVar, объявленной в лексическом окружении функции outerFunction. Это происходит потому, что лексическая среда innerFunction сохраняет ссылку на лексическую среду outerFunction.

### Differences between scope and context.

Область видимости (Scope) определяет доступность переменных, объектов и функций в программе в том или ином контексте исполнения.
Область видимости определяется местоположением, где переменная была объявлена, и определяет, где именно эта переменная может быть использована.
Типы областей видимости:
Глобальная область видимости (Global Scope) - переменные, объявленные вне любой функции или блока кода, доступны в любом месте программы.
Локальная область видимости (Local Scope) - переменные, объявленные внутри функции или блока кода, доступны только внутри этой функции или блока кода.
Пример:
// Глобальная область видимости
let globalVar = ‘I am global’;
function exampleFunction() {
// Локальная область видимости
let localVar = ‘I am local’;
console.log(globalVar); // Можно использовать переменную из глобальной области
}
console.log(globalVar); // Выведет ‘I am global’
console.log(localVar); // Ошибка: localVar не определен в этой области видимости
Контекст (Context) в JavaScript обычно относится к значению this внутри функции или метода объекта.
Значение this зависит от того, как функция вызывается, и может относиться к глобальному объекту, объекту, метод которого вызывается, или быть определенным явным образом при вызове функции.
Типы контекстов:
Глобальный контекст (Global Context) - контекст выполнения, когда код выполняется в глобальной области видимости. В этом контексте this обычно ссылается на глобальный объект, такой как window в браузере.
Контекст функции (Function Context) - контекст, в котором код выполняется внутри функции. this внутри функции зависит от способа вызова функции.
Пример:
let obj = {
name: ‘John’,
greet: function() {
console.log(‘Hello,’ + this.name);
}
};
obj.greet(); // Выведет ‘Hello, John’, здесь this ссылается на объект obj

Область видимости (scope) определяет доступность переменных в программе, в то время как контекст (context) определяет значение this внутри функций и методов.

### The mechanism of lexical environment traversal.

Механизм обхода лексической среды (lexical environment traversal) относится к способу, с помощью которого JavaScript ищет переменные в лексических областях видимости во время выполнения кода. Давайте разберемся, как это происходит более подробно:
Создание лексической среды:
Когда функция создается в JavaScript, ей присваивается своя собственная лексическая среда (lexical environment).
Эта лексическая среда содержит информацию о всех переменных, объявленных внутри функции, а также ссылку на лексическую среду внешней функции (если такая имеется).
Обход лексической среды:
При выполнении кода JavaScript интерпретатор ищет переменные в лексической среде текущей функции.
Если переменная не найдена в текущей лексической среде, интерпретатор переходит к родительской лексической среде и продолжает поиск там.
Этот процесс продолжается до тех пор, пока переменная не будет найдена или до тех пор, пока не будет достигнута глобальная область видимости.
Использование ссылки на родительскую лексическую среду:
Каждая лексическая среда сохраняет ссылку на свою родительскую лексическую среду.
Это позволяет JavaScript обеспечивать цепочку обхода лексических сред, когда переменные не могут быть найдены в текущей области видимости.
Завершение поиска:
Если переменная найдена в лексической среде, поиск завершается, и переменная используется в соответствующем контексте.
Если переменная не найдена ни в одной лексической среде, это приведет к ошибке ReferenceError.
Пример:
let globalVar = ‘Global Variable’;
function outerFunction() {
let outerVar = ‘Outer Variable’;

```
function innerFunction() {
    console.log(globalVar); // Найдет переменную в глобальной области видимости
    console.log(outerVar); // Найдет переменную во внешней лексической среде
}

innerFunction();
```

}
outerFunction();
В этом примере при вызове innerFunction, JavaScript сначала ищет переменную globalVar в глобальной области видимости, а затем переменную outerVar во внешней лексической среде outerFunction, поскольку она не найдена внутри innerFunction.

Вот краткое пояснение различий между скоупом, контекстом выполнения и лексической средой:

Скоуп (Scope):

Скоуп определяет область видимости переменных в коде.
Он указывает, где и какие переменные можно использовать в определенной части кода.
Скоуп зависит от структуры иерархии блоков и функций в исходном коде.
Лексическая среда (Lexical Environment):

Лексическая среда определяет, где были объявлены переменные и функции в исходном коде.
Она связывает идентификаторы (например, имена переменных и функций) с их соответствующими значениями и местами в коде, где они были определены.
Контекст выполнения (Execution Context):

Контекст выполнения управляет выполнением кода в конкретный момент времени.
Он содержит информацию о текущей области видимости, значении this, активации функций и других аспектах выполнения кода.
Каждый раз, когда функция вызывается, создается новый контекст выполнения, который добавляется в стек вызовов.
Итак, основное различие состоит в том, что скоуп определяет доступность переменных в коде, лексическая среда определяет, где переменные были определены в исходном коде, а контекст выполнения управляет выполнением кода в конкретный момент времени.

### Connection between function and its lexical environment.

Создание лексической среды:
Когда функция создается в JavaScript, ей автоматически присваивается своя собственная лексическая среда.
Лексическая среда функции включает в себя все переменные, объявленные внутри функции, а также ссылку на лексическую среду внешней функции, в которой эта функция была определена.
Захват переменных (Variable capturing):
Когда функция сохраняет ссылку на переменную из внешней области видимости, этот процесс называется захватом переменной (variable capturing).
При создании замыкания (closure) функция сохраняет ссылку на переменные из своей лексической среды, которые ей могут понадобиться в будущем.
Использование переменных из лексической среды:
Функция может использовать переменные из своей лексической среды независимо от того, где она вызывается.
Это позволяет функциям сохранять доступ к переменным и значениям из контекста, в котором они были определены, даже после того, как этот контекст завершил свою работу.
Пример:
function outerFunction() {
let outerVar = ‘Outer Variable’;
function innerFunction() {
console.log(outerVar); // Функция innerFunction имеет доступ к переменной outerVar из лексической среды outerFunction
}
return innerFunction;
}
let closure = outerFunction();
closure(); // Выведет ‘Outer Variable’
В этом примере функция innerFunction является замыканием, потому что она сохраняет ссылку на переменную outerVar из лексической среды outerFunction, даже после того, как outerFunction завершила свою работу. Когда closure() вызывается в глобальной области видимости, она все еще имеет доступ к переменной outerVar, что позволяет ей вывести её значение.

Advanced Functions
### this in functions
this представляет ссылку на текущий объект, к которому привязан контекст выполнения функции.
this позволяет функции получать доступ к своему контексту выполнения и работать с соответствующими данными.
Значение this в различных ситуациях:
В глобальной области видимости:
В глобальной области видимости this ссылается на глобальный объект, такой как window в браузере или global в Node.js.
В методах объекта:
В методах объекта this ссылается на объект, который вызывает метод.
В конструкторах:
В конструкторах this ссылается на созданный экземпляр объекта, который создается при вызове конструктора с оператором new.
В функциях:
В обычных функциях (не методах объекта и не стрелочных функциях) значение this зависит от того, как функция вызывается:
Если функция вызывается как часть объекта (например, obj.method()), то this ссылается на объект, к которому привязан метод.
Если функция вызывается без объекта (например, function()), то this ссылается на глобальный объект (в строгом режиме это будет undefined).
В стрелочных функциях:
В стрелочных функциях this привязано к значению this окружающего контекста, в котором они были созданы. Они не имеют своего собственного контекста выполнения.
Как изменить значение this:
Методы call(), apply() и bind():
Эти методы позволяют явно устанавливать значение this при вызове функции.
Использование замыканий:
Замыкания могут использоваться, чтобы сохранить значение this и обращаться к нему внутри функции.
Примеры:
let obj = {
name: ‘John’,
greet: function() {
console.log(‘Hello,’ + this.name);
}
};
obj.greet(); // Выведет ‘Hello, John’
function Person(name) {
this.name = name;
this.sayName = function() {
console.log(‘My name is’ + this.name);
};
}
let person1 = new Person(‘Alice’);
person1.sayName(); // Выведет ‘My name is Alice’
let sayNameFunc = person1.sayName;
sayNameFunc(); // Выведет ‘My name is undefined’ или приведет к ошибке в строгом режиме
В этом примере значение this в методе greet объекта obj ссылается на сам объект obj, в то время как в конструкторе Person оно ссылается на созданный экземпляр объекта. Однако, когда метод sayName присваивается переменной и вызывается без объекта (sayNameFunc()), значение this становится неопределенным или ссылается на глобальный объект.

Методы call(), apply() и bind() предоставляют способы явного управления значением this при вызове функции в JavaScript. Давайте рассмотрим их функционал более подробно:
1. call():
Метод call() вызывает функцию с заданным значением this и аргументами, переданными в виде списка.
Синтаксис: function.call(thisArg, arg1, arg2, …).
thisArg: значение, которое будет использоваться как this внутри функции.
arg1, arg2, …: аргументы, которые будут переданы в вызываемую функцию.
По сути, call() позволяет вызвать функцию с заданным контекстом выполнения и набором аргументов.
Пример использования call():
function greet() {
console.log(‘Hello,’ + this.name);
}
let person = { name: ‘John’ };
greet.call(person); // Выведет ‘Hello, John’
2. apply():
Метод apply() работает аналогично методу call(), за исключением того, что аргументы передаются в виде массива.
Синтаксис: function.apply(thisArg, [argsArray]).
thisArg: значение, которое будет использоваться как this внутри функции.
argsArray: массив аргументов, которые будут переданы в вызываемую функцию.
Пример использования apply():
function greet() {
console.log(‘Hello,’ + this.name);
}
let person = { name: ‘Alice’ };
let args = [‘Bob’]; // Аргументы передаются в виде массива
greet.apply(person, args); // Выведет ‘Hello, Alice’
3. bind():
Метод bind() создает новую функцию с определенным значением this, которое не может быть изменено ни при каких обстоятельствах.
Синтаксис: function.bind(thisArg[, arg1[, arg2[, …]]]).
thisArg: значение, которое будет привязано к this в новой функции.
При вызове новой функции, значение this будет установлено в thisArg, а также переданные аргументы будут привязаны к новой функции.
Пример использования bind():
function greet() {
console.log(‘Hello,’ + this.name);
}

let person = { name: ‘Kate’ };
let greetPerson = greet.bind(person);
greetPerson(); // Выведет ‘Hello, Kate’
Эти методы полезны, когда требуется явно установить значение this внутри функции или когда нужно создать функцию с привязанными аргументами, которую можно вызывать позднее.

### Reference Type & losing this

Reference Type & Losing this - это ключевая проблема в JavaScript, которая часто возникает при передаче методов объекта как колбэков или при работе с асинхронным кодом. Давайте подробно рассмотрим эту проблему:
1. Объекты как ссылочный тип:
В JavaScript объекты передаются по ссылке, а не по значению. Это значит, что переменные, содержащие объекты, на самом деле хранят не сами объекты, а ссылки на них.
2. Потеря контекста this:
Когда метод объекта передается как колбэк функции, контекст this теряется.
В колбэках this ссылается на глобальный объект или на undefined, если используется строгий режим (‘use strict’;).
3. Пример потери контекста this:
let obj = {
name: ‘John’,
greet: function() {
console.log(‘Hello,’ + this.name);
}
};
setTimeout(obj.greet, 1000); // В этом случае контекст `this` потеряется
В этом примере, когда метод greet объекта obj передается как колбэк функции setTimeout, он вызывается в контексте глобального объекта или undefined, а не объекта obj. Поэтому вы получите ошибку или неправильный результат.
4. Решение проблемы:
Существует несколько способов решить проблему потери контекста this:
Использование методов call(), apply() или bind() для явного установления контекста.
Использование стрелочных функций, которые не создают собственный контекст this и захватывают контекст родительской области видимости.
Примеры решений:
Использование метода bind():
setTimeout(obj.greet.bind(obj), 1000);
Использование стрелочной функции:
setTimeout(() => obj.greet(), 1000);
Эти методы позволяют сохранить контекст this и гарантировать корректное поведение при вызове методов объекта как колбэков.

### Understand difference between function and method

Функция (Function):
Функция - это блок кода, который можно вызывать для выполнения определенной задачи.
Функция может быть объявлена глобально или внутри другой функции, а также может быть анонимной.
Она может принимать параметры (аргументы), а также возвращать результат.
Пример функции:
function greet(name) {
console.log(‘Hello,’ + name);
}
greet(‘John’); // Вызов функции
2. Метод (Method):
Метод - это функция, связанная с объектом и вызываемая как свойство этого объекта.
Методы представляют собой действия или операции, которые объект может выполнять.
Методы определяются как свойства объекта и могут иметь доступ к другим свойствам и методам этого объекта через ключевое слово this.
Пример метода:
let obj = {
name: ‘John’,
greet: function() {
console.log(‘Hello,’ + this.name);
}
};
obj.greet(); // Вызов метода объекта
3. Различия между функцией и методом:
Контекст вызова: Функции могут быть вызваны независимо от объекта и не привязаны к какому-либо контексту. Методы вызываются в контексте объекта и имеют доступ к его свойствам и методам через this.
Объявление: Функции могут быть объявлены глобально или внутри других функций. Методы объявляются как свойства объекта.
Вызов: Функции вызываются напрямую, в то время как методы вызываются через объект, к которому они принадлежат.

### Understand how this works, realize this possible issues

Как работает this:
Контекст выполнения: Значение this зависит от контекста, в котором функция вызывается.
Значение this:
В методах объекта this ссылается на сам объект.
В глобальной области видимости и внутри обычных функций this ссылается на глобальный объект (например, window в браузере).
В строгом режиме (‘use strict’;) внутри обычных функций this ссылается на undefined.
В стрелочных функциях this ссылается на значение this окружающего контекста.
2. Возможные проблемы с this:
2.1 Потеря контекста:
Проблема: Контекст this теряется, когда функция передается как колбэк или вызывается в другом контексте.
Решение: Использование методов bind(), call() или apply(), чтобы явно установить контекст.
2.2 Привязка контекста к вложенным функциям:
Проблема: Вложенные функции могут иметь другой контекст this, если они вызываются отдельно от своего родительского объекта.
Решение: Использование лексической привязки this через стрелочные функции или сохранение контекста в переменных внутри замыканий.
2.3 Контекст в асинхронном коде:
Проблема: Контекст this может измениться в асинхронных операциях, таких как setTimeout, setInterval или обработчики событий.
Решение: Использование стрелочных функций, чтобы сохранить контекст или использование методов привязки контекста.
2.4 Использование в качестве метода объекта:
Проблема: Если функция используется как метод объекта, но вызывается независимо от объекта, контекст this может быть неправильно установлен.
Решение: Убедитесь, что функция вызывается от имени объекта, к которому она принадлежит.

### Manage this

Использование методов привязки контекста:
1.1 Метод bind():
bind() создает новую функцию, которая, при вызове, имеет указанный контекст this, с определенными начальными аргументами.
Пример использования:
function greet() {
console.log(‘Hello,’ + this.name);
}

let obj = { name: ‘John’ };
let boundGreet = greet.bind(obj);
boundGreet(); // Выведет ‘Hello, John’
1.2 Методы call() и apply():
call() и apply() позволяют вызывать функцию с заданным значением this, а также передавать аргументы в виде списка или массива соответственно.
Примеры использования:
function greet() {
console.log(‘Hello,’ + this.name);
}
let obj1 = { name: ‘Alice’ };
let obj2 = { name: ‘Bob’ };
greet.call(obj1); // Выведет ‘Hello, Alice’
greet.apply(obj2); // Выведет ‘Hello, Bob’
2. Использование стрелочных функций:
Стрелочные функции не создают собственного контекста this, а используют контекст окружающего кода.
Пример использования:
let obj = {
name: ‘Kate’,
greet: function() {
setTimeout(() => {
console.log(‘Hello,’ + this.name);
}, 1000);
}
};

obj.greet(); // Выведет ‘Hello, Kate’ через 1 секунду
3. Сохранение контекста в переменных:
Если необходимо сохранить контекст this для использования во вложенных функциях или асинхронных операциях, его можно сохранить в переменной.
Пример использования:
let obj = {
name: ‘Alex’,
greet: function() {
let self = this; // Сохранение контекста в переменной
setTimeout(function() {
console.log(‘Hello,’ + self.name);
}, 1000);
}
};
obj.greet(); // Выведет ‘Hello, Alex’ через 1 секунду

### Be able to replace this value

Метод bind():
function greet() {
console.log(‘Hello,’ + this.name);
}

let obj = { name: ‘John’ };
let boundGreet = greet.bind(obj);
boundGreet(); // Выведет ‘Hello, John’
1.2. Методы call() и apply():
function greet() {
console.log(‘Hello,’ + this.name);
}
let obj = { name: ‘Alice’ };
greet.call(obj); // Выведет ‘Hello, Alice’
greet.apply(obj); // Выведет ‘Hello, Alice’
2. Стрелочные функции:
let obj = {
name: ‘Kate’,
greet: function() {
setTimeout(() => {
console.log(‘Hello,’ + this.name);
}, 1000);
}
};
obj.greet(); // Выведет ‘Hello, Kate’ через 1 секунду
3. Сохранение контекста в переменной:
let obj = {
name: ‘Alex’,
greet: function() {
let self = this; // Сохранение контекста в переменной
setTimeout(function() {
console.log(‘Hello,’ + self.name);
}, 1000);
}
};
obj.greet(); // Выведет ‘Hello, Alex’ через 1 секунду
Эти методы позволяют явно устанавливать значение this и гарантировать корректное выполнение функций в различных контекстах.

### Be able to use call and apply Function built-in methods

Метод call():
Метод call() вызывает функцию с указанным значением this и переданными аргументами. Синтаксис:
functionName.call(thisArg, arg1, arg2, …)
thisArg: Значение, которое будет использоваться в качестве this внутри функции.
arg1, arg2, …: Аргументы, которые будут переданы в вызываемую функцию.
Пример использования call():
function greet() {
console.log(‘Hello,’ + this.name);
}

let obj = { name: ‘John’ };
greet.call(obj); // Выведет ‘Hello, John’
2. Метод apply():
Метод apply() работает аналогично методу call(), за исключением того, что аргументы передаются в виде массива. Синтаксис:
functionName.apply(thisArg, [arg1, arg2, …])
thisArg: Значение, которое будет использоваться в качестве this внутри функции.
[arg1, arg2, …]: Массив аргументов, который будет передан в вызываемую функцию.
Пример использования apply():
function greet() {
console.log(‘Hello,’ + this.name);
}

let obj = { name: ‘Alice’ };
let args = [‘Bob’];
greet.apply(obj, args); // Выведет ‘Hello, Alice’
Общие сведения:
call() и apply() полезны, когда нужно использовать функцию с определенным контекстом, например, вызвать метод объекта с контекстом этого объекта.
Оба метода могут быть использованы для вызова функций с контекстом, не связанным с объектом.
apply() особенно удобен, когда количество аргументов для передачи в функцию заранее неизвестно и они представлены в виде массива.

### Know how to bind this scope to function

Привязка области видимости this к функции в JavaScript является важным инструментом для управления контекстом выполнения функций. Это позволяет явно указать, к чему должен относиться this внутри функции, независимо от того, как она была вызвана. Давайте рассмотрим несколько способов привязки this к функции:
1. Метод bind():
Метод bind() создает новую функцию с указанным значением this, которая не изменяется при ее вызове. Синтаксис:
const boundFunc = func.bind(thisArg);
func: Функция, к которой будет привязан контекст this.
thisArg: Значение, которое будет использоваться в качестве this внутри привязанной функции.
Пример использования bind():
const obj = {
name: ‘John’,
greet: function() {
console.log(‘Hello,’ + this.name);
}
};

const boundGreet = obj.greet.bind(obj);
boundGreet(); // Выведет ‘Hello, John’
2. Стрелочные функции:
Стрелочные функции не создают собственного контекста this и используют контекст окружающего кода. Это делает их удобным способом привязки контекста this. Пример:
const obj = {
name: ‘Alice’,
greet: function() {
setTimeout(() => {
console.log(‘Hello,’ + this.name);
}, 1000);
}
};

obj.greet(); // Выведет ‘Hello, Alice’ через 1 секунду
3. Использование замыканий:
Можно сохранить контекст this в замыкании и использовать его внутри функции. Пример:
const obj = {
name: ‘Kate’,
greet: function() {
const self = this;
setTimeout(function() {
console.log(‘Hello,’ + self.name);
}, 1000);
}
};
obj.greet(); // Выведет ‘Hello, Kate’ через 1 секунду

Привязка контекста this к функции позволяет эффективно управлять контекстом выполнения функций в JavaScript. Используйте метод bind(), стрелочные функции или замыкания в зависимости от вашего контекста и требований, чтобы гарантировать корректное поведение функций.

### Binding, binding one function twice

Привязка одной функции несколько раз:
Вы можете привязать одну и ту же функцию к разным контекстам несколько раз. Каждый вызов метода bind() создает новую функцию с привязанным контекстом. Рассмотрим пример:
const obj1 = { name: ‘Alice’ };
const obj2 = { name: ‘Bob’ };
function greet() {
console.log(‘Hello,’ + this.name);
}
// Привязываем функцию greet к объектам obj1 и obj2
const greetToAlice = greet.bind(obj1);
const greetToBob = greet.bind(obj2);
// Вызываем привязанные функции с разными контекстами
greetToAlice(); // Выведет ‘Hello, Alice’
greetToBob(); // Выведет ‘Hello, Bob’
В этом примере функция greet привязывается дважды к разным объектам obj1 и obj2, создавая две новые функции greetToAlice и greetToBob. Каждая из этих функций вызывается с соответствующим контекстом this.

ECMAScript Intermediate
### Function default parameters.
Функциональные параметры по умолчанию (default parameters) - это возможность задать значения по умолчанию для аргументов функции. Если аргумент не был передан при вызове функции, его значение будет заменено значением по умолчанию. Это удобно, когда вы хотите обеспечить гибкость функции, предоставив значения по умолчанию для некоторых аргументов.
Вот пример использования параметров по умолчанию:
function greet(name = ‘World’) {
console.log(‘Hello,’ + name + ‘!’);
}
greet(); // Выведет ‘Hello, World!’
greet(‘Alice’); // Выведет ‘Hello, Alice!’
В этом примере функция greet() имеет один аргумент name, для которого задано значение по умолчанию ‘World’. Если аргумент name не передается при вызове функции, он автоматически принимает значение ‘World’.
Подробнее о функциональных параметрах по умолчанию:
Значения по умолчанию могут быть любыми выражениями:
function sum(a, b = 2 * a) {
return a + b;
}
console.log(sum(2)); // Выведет 6, так как b = 2 * 2 = 4
Параметры по умолчанию могут ссылаться на предыдущие параметры:
function greet(name, greeting = ‘Hello’) {
console.log(greeting + ‘,’ + name + ‘!’);
}
greet(‘Alice’); // Выведет ‘Hello, Alice!’
Параметры по умолчанию не ограничены только примитивными значениями:
function getDefault() {
return ‘World’;
}
function greet(name = getDefault()) {
console.log(‘Hello,’ + name + ‘!’);
}
greet(); // Выведет ‘Hello, World!’
Параметры по умолчанию вычисляются только при необходимости:
let defaultValue = ‘World’;
function greet(name = defaultValue) {
console.log(‘Hello,’ + name + ‘!’);
}
greet(); // Выведет ‘Hello, World!’
defaultValue = ‘Alice’;
greet(); // Выведет ‘Hello, Alice!’

### Using spread operator for function arguments.

Оператор расширения (spread operator) для аргументов функции в JavaScript позволяет передавать переменное количество аргументов в функцию без явного определения их количества. Это делает функции более гибкими и удобными для использования с различными типами данных. Давайте рассмотрим, как использовать оператор расширения для аргументов функции подробнее:
Оператор расширения для массивов:
function sum(a, b, c) {
return a + b + c;
}
const numbers = [1, 2, 3];
console.log(sum(…numbers)); // Выведет 6
В этом примере массив numbers расширяется в качестве аргументов функции sum(). Это эквивалентно вызову sum(1, 2, 3), где значения из массива numbers используются в качестве аргументов.
Оператор расширения для объединения массивов:
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combinedArray = […arr1, …arr2];
console.log(combinedArray); // Выведет [1, 2, 3, 4, 5, 6]
В этом примере массивы arr1 и arr2 объединяются в один массив combinedArray с использованием оператора расширения.
Оператор расширения для объектов:
const obj1 = { foo: ‘bar’ };
const obj2 = { baz: ‘qux’ };
const mergedObject = { …obj1, …obj2 };
console.log(mergedObject); // Выведет { foo: ‘bar’, baz: ‘qux’ }
В этом примере объекты obj1 и obj2 объединяются в один объект mergedObject с использованием оператора расширения.
Применение оператора расширения в функциях:
function greet(…names) {
names.forEach(name => {
console.log(‘Hello,’ + name + ‘!’);
});
}
greet(‘Alice’, ‘Bob’, ‘Charlie’); // Выведет ‘Hello, Alice!’, ‘Hello, Bob!’, ‘Hello, Charlie!’
В этом примере оператор расширения …names позволяет передавать переменное количество аргументов в функцию greet(). Все переданные аргументы сохраняются в массиве names, который затем можно перебрать и обработать.

### Comparing arguments and rest parameters.

Аргументы функции (Function Arguments):
Аргументы функции - это значения, переданные при вызове функции. Они доступны через встроенный объект arguments. Основные особенности аргументов функции:
arguments - это объект, представляющий все аргументы, переданные функции.
arguments - это массивоподобный объект, но не массив. Он имеет свойства, похожие на массив, но не имеет методов массива, таких как forEach, map и т. д.
Количество аргументов может отличаться от количества объявленных параметров в определении функции.
Можно получить доступ к аргументам по индексу: arguments[0], arguments[1], и т. д.
Пример использования аргументов функции:
function sum() {
let result = 0;
for (let i = 0; i < arguments.length; i++) {
result += arguments[i];
}
return result;
}
console.log(sum(1, 2, 3)); // Выведет 6
2. Параметры остаточных параметров (Rest Parameters):
Параметры остаточных параметров - это специальный тип параметров функции, который позволяет собирать остаточные аргументы функции в один массив. Основные особенности параметров остаточных параметров:
Они представлены тремя точками (…) перед последним параметром функции.
Они собирают все остальные аргументы, переданные функции, и помещают их в массив.
Можно использовать любое имя для параметра остаточных параметров.
Они позволяют избежать использования объекта arguments.
Пример использования параметров остаточных параметров:
function sum(…numbers) {
return numbers.reduce((total, num) => total + num, 0);
}
console.log(sum(1, 2, 3)); // Выведет 6
Сравнение:
Гибкость: Параметры остаточных параметров предоставляют более гибкий способ работы с переменным количеством аргументов, в то время как аргументы функции более ограничены.
Массив vs. объект: Параметры остаточных параметров собирают аргументы в массив, тогда как аргументы функции представлены объектом arguments.
Доступность: Параметры остаточных параметров доступны только для параметров функции, в то время как аргументы функции могут использоваться в любом месте функции.
В общем, параметры остаточных параметров обеспечивают более современный и гибкий подход к обработке переменного числа аргументов в функции, в то время как использование аргументов функции может быть менее удобным из-за их ограниченной функциональности.

### Array concatenation with spread operator.

Оператор расширения (spread operator) в JavaScript также может использоваться для объединения (конкатенации) массивов. Он позволяет развернуть (распаковать) элементы одного массива и вставить их в другой массив. Это делает оператор расширения мощным инструментом для работы с массивами. Рассмотрим его подробнее:
Пример использования оператора расширения для конкатенации массивов:
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const concatenatedArray = […arr1, …arr2];
console.log(concatenatedArray); // Выведет [1, 2, 3, 4, 5, 6]
В этом примере оператор расширения …arr1 разворачивает (распаковывает) элементы массива arr1, а оператор расширения …arr2 разворачивает элементы массива arr2. Затем эти элементы объединяются в один новый массив concatenatedArray.
Применение оператора расширения к пустым массивам:
const arr1 = [1, 2, 3];
const arr2 = [];
const concatenatedArray = […arr1, …arr2];
console.log(concatenatedArray); // Выведет [1, 2, 3]
В этом примере оператор расширения также может использоваться с пустым массивом arr2. В этом случае пустой массив не добавляет никаких элементов в конечный массив concatenatedArray.
Применение оператора расширения к массиву с элементами и значениями:
const arr1 = [1, 2, 3];
const value = 4;
const concatenatedArray = […arr1, value];
console.log(concatenatedArray); // Выведет [1, 2, 3, 4]
В этом примере оператор расширения также может использоваться для добавления значения value в конец массива arr1, создавая новый массив concatenatedArray.
Преимущества использования оператора расширения для конкатенации массивов:
Более компактный и читаемый синтаксис по сравнению с использованием методов массивов, таких как concat().
Возможность быстрого и гибкого объединения массивов с элементами и значениями.
Использование оператора расширения для конкатенации массивов предоставляет простой и эффективный способ создания новых массивов на основе существующих массивов и значений.

### Destructuring assignments for variables and function arguments.

Деструктуризация (Destructuring) в JavaScript - это способ извлечения значений из массивов или объектов и присвоения их переменным в одной строке кода. Деструктуризация часто используется для удобного доступа к элементам массивов или свойствам объектов. Давайте подробнее рассмотрим деструктуризацию для переменных и аргументов функций:
Деструктуризация для переменных:
Деструктуризация массивов:
const numbers = [1, 2, 3];
const [a, b, c] = numbers;
console.log(a); // Выведет 1
console.log(b); // Выведет 2
console.log(c); // Выведет 3
Деструктуризация объектов:
const person = { name: ‘Alice’, age: 30 };
const { name, age } = person;
console.log(name); // Выведет ‘Alice’
console.log(age); // Выведет 30
Деструктуризация для аргументов функций:
Деструктуризация массивов:
function sum([a, b, c]) {
return a + b + c;
}
console.log(sum([1, 2, 3])); // Выведет 6
Деструктуризация объектов:
function greet({ name, age }) {
console.log(`Hello, ${name}! You are ${age} years old.`);
}
greet({ name: ‘Alice’, age: 30 }); // Выведет ‘Hello, Alice! You are 30 years old.’
Преимущества деструктуризации:
Краткость и ясность: Позволяет избежать длинных последовательностей обращений к свойствам объекта или элементам массива.
Удобство работы с данными: Упрощает доступ к структурированным данным, делая код более понятным и читаемым.
Повышение производительности: Меньше кода означает меньше вероятности ошибок и более быструю разработку.

### for..of loop (optional).

Цикл for…of в JavaScript предоставляет простой и удобный способ перебора элементов итерируемых объектов, таких как массивы, строки, коллекции и другие объекты, которые поддерживают протокол итераторов. Давайте подробно рассмотрим его использование:
Использование for…of с массивами:
const array = [1, 2, 3, 4];
for (const element of array) {
console.log(element); // Выведет каждый элемент массива по очереди
}
Использование for…of со строками:
const str = “Hello”;
for (const char of str) {
console.log(char); // Выведет каждый символ строки по очереди
}
Использование for…of с коллекциями:
const set = new Set([1, 2, 3, 4]);
for (const item of set) {
console.log(item); // Выведет каждый элемент множества по очереди
}
Примечания:
При использовании for…of не требуется явно указывать индексы или ключи элементов объекта, как это делается в цикле for…in.
Цикл for…of автоматически обходит все элементы итерируемого объекта, начиная с первого и заканчивая последним.
Использование for…of удобно, когда вам нужно пройти по всем элементам массива, строки или других коллекций без необходимости следить за индексами или ключами.

Objects Built-in Methods
### Utilizing Object.keys and Object.values.
Object.keys() и Object.values() - это методы встроенного объекта JavaScript Object, которые используются для работы с объектами. Давайте рассмотрим их подробнее:
Метод Object.keys() возвращает массив строк, содержащих имена собственных перечисляемых свойств объекта. Вот как он используется:
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
console.log(keys); // Выведет [‘a’, ‘b’, ‘c’]
В этом примере метод Object.keys() возвращает массив строк, содержащих имена свойств объекта obj.
Примечания по Object.keys():
Метод Object.keys() возвращает только собственные перечисляемые свойства объекта, игнорируя унаследованные свойства и свойства, которые не перечисляемы.
Результат будет массивом строк, содержащим имена свойств объекта в том же порядке, в котором они были определены (если движок JavaScript поддерживает этот порядок).
Метод Object.values() возвращает массив значений собственных перечисляемых свойств объекта в том же порядке, что и с помощью цикла for…in (при условии, что движок JavaScript поддерживает этот порядок). Вот пример:
const obj = { a: 1, b: 2, c: 3 };
const values = Object.values(obj);
console.log(values); // Выведет [1, 2, 3]
В этом примере метод Object.values() возвращает массив значений свойств объекта obj.
Примечания по Object.values():
Метод Object.values() возвращает только значения собственных перечисляемых свойств объекта, игнорируя унаследованные свойства и свойства, которые не перечисляемы.
Примечания по обоим методам:
Эти методы очень полезны для итерации по свойствам объекта и работы с ними в функциональном стиле, используя методы массива, такие как map(), filter() и reduce().
Оба метода работают в современных версиях всех основных браузеров и движков JavaScript, включая Node.js. Однако, если вы используете старые версии JavaScript или необходима поддержка старых браузеров, проверьте совместимость методов перед использованием.

### Working with static Object methods.

### 1. Использование точечной нотации

Это самый распространенный способ добавления свойства к объекту. Если свойство уже существует, его значение будет обновлено.

**Пример:**

```jsx
const obj = {};
obj.newProperty = 'value';
console.log(obj.newProperty); // Output: 'value'
```

### 2. Использование квадратных скобок

Этот способ позволяет добавлять свойства с именами, которые не могут быть валидными идентификаторами JavaScript, например, строки с пробелами или символами.

**Пример:**

```jsx
const obj = {};
obj['new property'] = 'value';
console.log(obj['new property']); // Output: 'value'
```

### 3. Метод `Object.defineProperty`

Этот метод позволяет добавлять свойства с определенными дескрипторами, такими как `writable`, `enumerable` и `configurable`. Данный метод предоставляет большую гибкость и контроль над свойствами.

**Пример:**

```jsx
const obj = {};
Object.defineProperty(obj, 'newProperty', {
  value: 'value',
  writable: true,
  enumerable: true,
  configurable: true
});
console.log(obj.newProperty); // Output: 'value'
```

### 4. Метод `Object.defineProperties`

Этот метод позволяет добавлять несколько свойств одновременно с их дескрипторами.

**Пример:**

```jsx
const obj = {};
Object.defineProperties(obj, {
  'firstProperty': {
    value: 'value1',
    writable: true,
    enumerable: true,
    configurable: true
  },
  'secondProperty': {
    value: 'value2',
    writable: true,
    enumerable: true,
    configurable: true
  }
});
console.log(obj.firstProperty); // Output: 'value1'
console.log(obj.secondProperty); // Output: 'value2'
```

### 5. Использование метода `Object.assign`

Этот метод копирует все перечисляемые собственные свойства одного или более исходных объектов в целевой объект. Подходит для добавления сразу нескольких свойств.

**Пример:**

```jsx
const obj = {};
Object.assign(obj, { newProperty: 'value', anotherProperty: 'anotherValue' });
console.log(obj.newProperty); // Output: 'value'
console.log(obj.anotherProperty); // Output: 'anotherValue'
```

### 6. Использование метода `Object.create`

Этот метод создает новый объект с указанным объектом прототипа и свойствами.

**Пример:**

```jsx
const obj = Object.create({}, {
  newProperty: {
    value: 'value',
    writable: true,
    enumerable: true,
    configurable: true
  }
});
console.log(obj.newProperty); // Output: 'value'
```

МЕТОДЫ ОБЪЕКТА

1. Object.keys()
Этот метод возвращает массив строк, содержащих имена собственных перечисляемых свойств объекта.
Пример использования:
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
console.log(keys); // [‘a’, ‘b’, ‘c’]
2. Object.values()
Этот метод возвращает массив значений собственных перечисляемых свойств объекта.
Пример использования:
const obj = { a: 1, b: 2, c: 3 };
const values = Object.values(obj);
console.log(values); // [1, 2, 3]
3. Object.entries()
Этот метод возвращает массив пар ключ-значение для каждого собственного перечисляемого свойства объекта в виде массива.
Пример использования:
const obj = { a: 1, b: 2, c: 3 };
const entries = Object.entries(obj);
console.log(entries); // [[‘a’, 1], [‘b’, 2], [‘c’, 3]]
4. Object.assign()
Этот метод используется для копирования значений всех перечисляемых собственных свойств из одного или нескольких исходных объектов в целевой объект.
Пример использования:
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };
const merged = Object.assign(target, source);
console.log(merged); // { a: 1, b: 4, c: 5 }
5. Object.freeze()
Этот метод “замораживает” объект, что означает, что нельзя добавлять новые свойства, изменять существующие свойства или удалять их.
Пример использования
const obj = { a: 1, b: 2 };
Object.freeze(obj);
obj.c = 3; // Ошибка в строгом режиме
console.log(obj); // { a: 1, b: 2 }
6. Object.seal()
Этот метод запечатывает объект, что означает, что нельзя добавлять новые свойства и удалять существующие свойства, но можно изменять существующие свойства.
Пример использования:
const obj = { a: 1, b: 2 };
Object.seal(obj);
obj.c = 3; // Ошибка в строгом режиме
delete obj.a; // Ошибка в строгом режиме
console.log(obj); // { a: 1, b: 2 }
7. Object.create()
Этот метод создает новый объект с указанным прототипом и набором собственных свойств.
Пример использования:
const obj = Object.create({ a: 1, b: 2 });
console.log(obj); // {}
console.log(obj.a); // 1
Примечание:
Все эти методы Object являются статическими, поэтому они вызываются напрямую через объект Object, а не через экземпляр объекта.

### Property flags and descriptors.

Свойства объектов в JavaScript могут иметь различные характеристики, называемые флагами свойств и дескрипторами. Они определяют поведение и доступ к свойствам объектов. Давайте рассмотрим их подробнее:
1. Флаги свойств:
Writable (записываемость): Определяет, можно ли изменять значение свойства. Если установлен в true, значение свойства можно изменять. По умолчанию true.
Enumerable (перечисляемость): Определяет, будет ли свойство перечисляться при итерации через цикл for…in или методы Object.keys() и Object.values(). Если установлен в true, свойство будет перечисляемым. По умолчанию true.
Configurable (настраиваемость): Определяет, можно ли изменять атрибуты свойства и удалять его из объекта. Если установлен в true, свойство может быть изменено или удалено. По умолчанию true.
2. Дескрипторы свойств:
Дескриптор свойства - это объект, содержащий флаги и другие характеристики свойства.
Value (значение): Значение свойства.
Writable (записываемость): Флаг записываемости.
Enumerable (перечисляемость): Флаг перечисляемости.
Configurable (настраиваемость): Флаг настраиваемости.
Пример использования:
const obj = {};
Object.defineProperty(obj, ‘prop’, {
value: 42,
writable: false,
enumerable: true,
configurable: true
});
console.log(obj.prop); // Выведет 42
obj.prop = 100; // Ошибка в строгом режиме или silent mode
console.log(obj.prop); // Выведет 42
delete obj.prop; // Работает, так как configurable установлен в true
console.log(obj.prop); // Выведет undefined
Методы для работы с дескрипторами:
Object.defineProperty(): Определяет новое свойство непосредственно на объекте или изменяет существующее свойство и возвращает объект.
Object.defineProperties(): Определяет новые или изменяет существующие свойства непосредственно на объекте, возвращая объект.
Object.getOwnPropertyDescriptor(): Возвращает дескриптор указанного свойства объекта.
Object.getOwnPropertyDescriptors(): Возвращает объект, содержащий дескрипторы всех собственных свойств объекта.
Примечания:
Использование дескрипторов позволяет более точно контролировать поведение свойств объекта.
Object.defineProperty() и Object.defineProperties() позволяют явно задавать флаги свойств объекта.
Object.getOwnPropertyDescriptor() и Object.getOwnPropertyDescriptors() позволяют получить информацию о свойствах объекта.

### Creating iterable objects and using Symbol.iterator (optional).

В JavaScript итерируемые объекты позволяют перебирать их элементы с помощью циклов for…of, распространенных методов массивов (например, map, filter, reduce) и оператора распространения (…). Для создания итерируемых объектов используется символ Symbol.iterator, который представляет метод, возвращающий итератор для объекта. Вот как это работает:
Создание итерируемого объекта:
Создание метода Symbol.iterator: Определяем метод Symbol.iterator в прототипе объекта или непосредственно в объекте.
Метод Symbol.iterator: Этот метод возвращает итератор для объекта. Итератор - это объект, который должен иметь метод next(), возвращающий объект с двумя свойствами: value (значение следующего элемента) и done (логическое значение, показывающее, завершен ли перебор).
Пример создания итерируемого объекта:
const myIterable = {
data: [‘one’, ‘two’, ‘three’],
[Symbol.iterator]: function() {
let index = 0;
return {
next: () => {
return {
value: this.data[index++],
done: index > this.data.length
};
}
};
}
};

for (const item of myIterable) {
console.log(item); // Выведет ‘one’, ‘two’, ‘three’
}
Примечания:
Метод Symbol.iterator может быть определен непосредственно в объекте или в его прототипе.
Возвращаемый итератор должен иметь метод next(), который возвращает объект с полями value и done.
После завершения перебора done должен быть установлен в true.
Использование итерируемых объектов упрощает работу с данными и делает код более понятным и функциональным, особенно в контексте современных возможностей JavaScript, таких как цикл for…of и оператор распространения (…).

ECMAScript Data Types & Expressions
### Working with Object computed properties.
С вычисляемыми свойствами объекта вы можете создавать свойства, имена которых вычисляются во время выполнения программы. В JavaScript для этого используется выражение в квадратных скобках [], в котором можно указывать любые выражения, включая переменные или вызовы функций. Давайте рассмотрим это подробнее:
Создание объекта с вычисляемыми свойствами:
const prefix = ‘foo’;
const obj = {
[prefix + ’_bar’]: ‘baz’,
‘get’ + ‘Value’ {
return this.foo_bar; // Доступ к вычисляемому свойству
}
};
console.log(obj.foo_bar); // Выведет ‘baz’
console.log(obj.getValue()); // Выведет ‘baz’
Примечания:
Внутри квадратных скобок [] можно использовать любые выражения, которые могут быть вычислены в строку.
Свойства, созданные с использованием вычисляемых имен, имеют те же характеристики, что и обычные свойства объекта.
Вы можете использовать вычисляемые свойства для динамического создания свойств объекта или создания свойств с удобными именами на основе переменных или других вычислений.
Это очень мощный инструмент, который позволяет гибко создавать и манипулировать свойствами объектов в JavaScript. Он часто используется в ситуациях, когда имена свойств заранее неизвестны и зависят от контекста выполнения программы.

### Iterating through Object keys.

Итерация по ключам объекта - это процесс перебора всех ключей объекта и выполнение определенных действий для каждого ключа. В JavaScript есть несколько способов сделать это. Давайте рассмотрим их подробнее:
1. Цикл for…in:
Цикл for…in используется для перебора всех перечисляемых свойств объекта. Он перебирает имена всех свойств, включая унаследованные.
const obj = { a: 1, b: 2, c: 3 };
for (const key in obj) {
console.log(key); // Выведет ‘a’, ‘b’, ‘c’
}
2. Метод Object.keys():
Метод Object.keys() возвращает массив строк, содержащих имена собственных перечисляемых свойств объекта.
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
for (const key of keys) {
console.log(key); // Выведет ‘a’, ‘b’, ‘c’
}
3. Метод Object.entries() с деструктуризацией:
Метод Object.entries() возвращает массив пар ключ-значение для каждого собственного перечисляемого свойства объекта в виде массива. Можно использовать деструктуризацию для итерации по ключам и значениям одновременно.
const obj = { a: 1, b: 2, c: 3 };
for (const [key, value] of Object.entries(obj)) {
console.log(key); // Выведет ‘a’, ‘b’, ‘c’
}
Примечания:
Каждый из этих методов имеет свои особенности и подходит для разных сценариев использования.
Цикл for…in удобен для перебора всех перечисляемых свойств, но он также перебирает унаследованные свойства.
Метод Object.keys() возвращает только имена собственных перечисляемых свойств объекта.
Метод Object.entries() возвращает массив пар ключ-значение, что может быть полезно при итерации как по ключам, так и по значениям объекта.

Arrays Built-in Methods
### Copying and modifying arrays.
Копирование и изменение массивов - это частая задача в JavaScript, особенно при работе с данными. Давайте рассмотрим различные методы для копирования и изменения массивов подробно:
1. Копирование массива:
1.1. Метод slice():
Метод slice() создает копию массива, начиная с указанного индекса и до указанного конечного индекса (не включая его). Если параметры не указаны, создается полная копия массива.
const array = [1, 2, 3, 4, 5];
const copyArray = array.slice();
console.log(copyArray); // [1, 2, 3, 4, 5]
1.2. Оператор распространения (…):
Оператор распространения (…) также создает поверхностную копию массива.
const array = [1, 2, 3, 4, 5];
const copyArray = […array];
console.log(copyArray); // [1, 2, 3, 4, 5]
2. Изменение массива:
2.1. Метод concat():
Метод concat() создает новый массив, объединяя существующий массив с другими массивами или значениями.
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];
const newArray = array1.concat(array2);
console.log(newArray); // [1, 2, 3, 4, 5, 6]
2.2. Методы изменения массива:
Методы, изменяющие массив, такие как push(), pop(), shift(), unshift(), splice(), изменяют исходный массив. Их следует использовать для добавления, удаления или замены элементов в массиве.
const array = [1, 2, 3];
array.push(4); // Добавляет элемент в конец массива
console.log(array); // [1, 2, 3, 4]
array.pop(); // Удаляет последний элемент массива
console.log(array); // [1, 2, 3]
array.shift(); // Удаляет первый элемент массива
console.log(array); // [2, 3]
array.unshift(1); // Добавляет элемент в начало массива
console.log(array); // [1, 2, 3]
array.splice(1, 0, 5); // Вставляет элемент в заданную позицию
console.log(array); // [1, 5, 2, 3]
Примечания:
При копировании массива с помощью slice() или оператора распространения (…) создается поверхностная копия массива. Для глубокого копирования массива с вложенными структурами данных потребуется дополнительный код.
Методы изменения массива, такие как push(), pop(), shift(), unshift(), splice(), изменяют исходный массив.

Мутирующие методы изменяют сам массив, на котором они были вызваны, тогда как немутирующие методы возвращают новый массив или значение, не изменяя исходный массив.

### Мутирующие методы

Мутирующие методы изменяют содержимое массива непосредственно. Вот некоторые из наиболее часто используемых мутирующих методов массивов:

1. **`push()`**
    - Добавляет один или более элементов в конец массива и возвращает новую длину массива.
    
    ```jsx
    const arr = [1, 2, 3];
    arr.push(4); // arr теперь [1, 2, 3, 4]
    ```
    
2. **`pop()`**
    - Удаляет последний элемент из массива и возвращает его.
    
    ```jsx
    const arr = [1, 2, 3];
    arr.pop(); // arr теперь [1, 2], возвращает 3
    ```
    
3. **`shift()`**
    - Удаляет первый элемент из массива и возвращает его.
    
    ```jsx
    const arr = [1, 2, 3];
    arr.shift(); // arr теперь [2, 3], возвращает 1
    ```
    
4. **`unshift()`**
    - Добавляет один или более элементов в начало массива и возвращает новую длину массива.
    
    ```jsx
    const arr = [1, 2, 3];
    arr.unshift(0); // arr теперь [0, 1, 2, 3]
    ```
    
5. **`splice()`**
    - Изменяет содержимое массива, удаляя, заменяя или добавляя элементы.
    
    ```jsx
    const arr = [1, 2, 3, 4];
    arr.splice(1, 2, 'a', 'b'); // arr теперь [1, 'a', 'b', 4], удаляет 2 элемента начиная с индекса 1 и добавляет 'a' и 'b'
    ```
    
6. **`sort()`**
    - Сортирует элементы массива на месте и возвращает отсортированный массив.
    
    ```jsx
    const arr = [3, 1, 2];
    arr.sort(); // arr теперь [1, 2, 3]
    ```
    
7. **`reverse()`**
    - Переворачивает порядок элементов в массиве на месте и возвращает перевёрнутый массив.
    
    ```jsx
    const arr = [1, 2, 3];
    arr.reverse(); // arr теперь [3, 2, 1]
    ```
    
8. **`copyWithin()`**
    - Копирует часть массива в другую позицию в этом же массиве без изменения его длины.
    
    ```jsx
    const arr = [1, 2, 3, 4, 5];
    arr.copyWithin(0, 3); // arr теперь [4, 5, 3, 4, 5]
    
    ```
    
9. **`fill()`**
    - Заполняет все элементы массива от начального до конечного индекса статическим значением.
    
    ```jsx
    const arr = [1, 2, 3];
    arr.fill(0); // arr теперь [0, 0, 0]
    ```
    

### Немутирующие методы

Немутирующие методы возвращают новое значение (массив или другое) и не изменяют исходный массив. Вот некоторые из наиболее часто используемых немутирующих методов массивов:

1. **`concat()`**
    - Возвращает новый массив, состоящий из этого массива, объединённого с другими массивами и/или значениями.
    
    ```jsx
    const arr = [1, 2];
    const newArr = arr.concat([3, 4]); // newArr [1, 2, 3, 4], arr остаётся [1, 2]
    ```
    
2. **`slice()`**
    - Возвращает новый массив, содержащий копию части исходного массива.
    
    ```jsx
    const arr = [1, 2, 3, 4];
    const newArr = arr.slice(1, 3); // newArr [2, 3], arr остаётся [1, 2, 3, 4]
    ```
    
3. **`map()`**
    - Создаёт новый массив с результатами вызова указанной функции для каждого элемента массива.
    
    ```jsx
    const arr = [1, 2, 3];
    const newArr = arr.map(x => x * 2); // newArr [2, 4, 6], arr остаётся [1, 2, 3]
    ```
    
4. **`filter()`**
    - Создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в предоставленной функции.
    
    ```jsx
    const arr = [1, 2, 3, 4];
    const newArr = arr.filter(x => x % 2 === 0); // newArr [2, 4], arr остаётся [1, 2, 3, 4]
    ```
    
5. **`reduce()`**
    - Применяет функцию к аккумулятору и каждому элементу массива (слева направо), сводя его к единственному значению.
    
    ```jsx
    const arr = [1, 2, 3, 4];
    const sum = arr.reduce((acc, x) => acc + x, 0); // sum 10, arr остаётся [1, 2, 3, 4]
    ```
    
6. **`reduceRight()`**
    - Применяет функцию к аккумулятору и каждому элементу массива (справа налево), сводя его к единственному значению.
    
    ```jsx
    const arr = [1, 2, 3, 4];
    const sum = arr.reduceRight((acc, x) => acc + x, 0); // sum 10, arr остаётся [1, 2, 3, 4]
    ```
    
7. **`find()`**
    - Возвращает первый элемент массива, который удовлетворяет предоставленной функции.
    
    ```jsx
    const arr = [1, 2, 3, 4];
    const found = arr.find(x => x > 2); // found 3, arr остаётся [1, 2, 3, 4]
    ```
    
8. **`findIndex()`**
    - Возвращает индекс первого элемента массива, который удовлетворяет предоставленной функции.
    
    ```jsx
    const arr = [1, 2, 3, 4];
    const index = arr.findIndex(x => x > 2); // index 2, arr остаётся [1, 2, 3, 4]
    ```
    
9. **`includes()`**
    - Проверяет, содержит ли массив определённое значение среди своих элементов.
    
    ```jsx
    const arr = [1, 2, 3];
    const hasTwo = arr.includes(2); // hasTwo true, arr остаётся [1, 2, 3]
    ```
    
10. **`every()`**
    - Проверяет, удовлетворяют ли все элементы массива условию, заданному в предоставленной функции.
    
    ```jsx
    const arr = [1, 2, 3];
    const allPositive = arr.every(x => x > 0); // allPositive true, arr остаётся [1, 2, 3]
    ```
    
11. **`some()`**
    - Проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в предоставленной функции.
    
    ```jsx
    const arr = [1, 2, 3];
    const someGreaterThanTwo = arr.some(x => x > 2); // someGreaterThanTwo true, arr остаётся [1, 2, 3]
    ```
    
12. **`join()`**
    - Объединяет все элементы массива в строку.
    
    ```jsx
    const arr = [1, 2, 3];
    const str = arr.join('-'); // str '1-2-3', arr остаётся [1, 2, 3]
    ```
    

## Цепочка вызовов (или цепочка методов)

Цепочка вызовов (или цепочка методов) в JavaScript — это техника, позволяющая вызывать несколько методов на одном и том же объекте, используя метод вызова одного метода после другого. В контексте массивов это означает, что вы можете использовать несколько методов массива последовательно, каждый из которых выполняет операцию над массивом и возвращает новый массив или результат, на котором можно вызвать следующие методы.

### Как это работает

Цепочка вызовов позволяет вам выполнять несколько операций на массиве в одной строке кода. Это возможно благодаря тому, что многие методы массива возвращают новый массив или значение, которое может быть использовано для дальнейших вызовов методов.

**Пример цепочки вызовов:**

```jsx
const numbers = [1, 2, 3, 4, 5];

const result = numbers
  .filter(num => num > 2)      // Фильтрует элементы больше 2
  .map(num => num * 2)         // Умножает каждый элемент на 2
  .sort((a, b) => b - a);      // Сортирует элементы в убывающем порядке
console.log(result); // Output: [10, 8, 6]
```

### Зачем нужна цепочка вызовов

1. **Улучшение читаемости кода**:
    - Цепочка вызовов позволяет выразить последовательность операций над данными более ясно и компактно. Это делает код легче для понимания и сопровождения.
2. **Сокращение кода**:
    - Использование цепочки вызовов помогает избежать промежуточных переменных и упрощает код. Вместо того чтобы создавать промежуточные массивы или переменные для хранения результатов, вы можете сделать все в одной цепочке методов.
3. **Избежание побочных эффектов**:
    - Немутирующие методы массивов (такие как `filter`, `map`, `concat`, и т.д.) возвращают новые массивы, оставляя исходный массив неизменным. Цепочка вызовов позволяет избегать побочных эффектов и улучшает предсказуемость кода.

### Где применяется

1. **Фильтрация данных**:
    - Например, когда нужно отфильтровать элементы массива по определенному критерию, затем преобразовать их и отсортировать.
2. **Обработка данных**:
    - Когда требуется выполнить несколько преобразований данных, таких как преобразование форматов, вычисления и сортировка.
3. **Комплексные вычисления**:
    - Цепочка вызовов может использоваться для выполнения сложных вычислений, которые требуют последовательного применения нескольких функций.

**Пример использования в реальных сценариях:**

**1. Обработка списка пользователей:**

```jsx
const users = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 },
  { name: 'Charlie', age: 35 },
];
const result = users
  .filter(user => user.age > 25)       // Фильтрация пользователей старше 25 лет
  .map(user => user.name)              // Извлечение имен
  .sort();                            // Сортировка имен в алфавитном порядке
console.log(result); // Output: ['Bob', 'Charlie']
```

**2. Анализ и обработка числовых данных:**

```jsx
const data = [5, 7, 2, 9, 4, 8];
const result = data
  .map(x => x * 2)                     // Умножение каждого элемента на 2
  .filter(x => x > 10)                // Фильтрация значений больше 10
  .reduce((sum, x) => sum + x, 0);    // Суммирование оставшихся значений
console.log(result); // Output: 34
```

### Copying and modifying arrays

1. Копирование массива:
1.1. Метод slice():
Метод slice() создает копию массива, начиная с указанного индекса и до указанного конечного индекса (не включая его). Если параметры не указаны, создается полная копия массива.
const array = [1, 2, 3, 4, 5];
const copyArray = array.slice();
console.log(copyArray); // [1, 2, 3, 4, 5]
1.2. Оператор распространения (…):
Оператор распространения (…) также создает поверхностную копию массива.
const array = [1, 2, 3, 4, 5];
const copyArray = […array];
console.log(copyArray); // [1, 2, 3, 4, 5]
2. Изменение массива:
2.1. Метод concat():
Метод concat() создает новый массив, объединяя существующий массив с другими массивами или значениями.
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];
const newArray = array1.concat(array2);
console.log(newArray); // [1, 2, 3, 4, 5, 6]
2.2. Методы изменения массива:
Методы, изменяющие массив, такие как push(), pop(), shift(), unshift(), splice(), изменяют исходный массив. Их следует использовать для добавления, удаления или замены элементов в массиве.
const array = [1, 2, 3];
array.push(4); // Добавляет элемент в конец массива
console.log(array); // [1, 2, 3, 4]
array.pop(); // Удаляет последний элемент массива
console.log(array); // [1, 2, 3]
array.shift(); // Удаляет первый элемент массива
console.log(array); // [2, 3]
array.unshift(1); // Добавляет элемент в начало массива
console.log(array); // [1, 2, 3]
array.splice(1, 0, 5); // Вставляет элемент в заданную позицию
console.log(array); // [1, 5, 2, 3]
Примечания:
При копировании массива с помощью slice() или оператора распространения (…) создается поверхностная копия массива. Для глубокого копирования массива с вложенными структурами данных потребуется дополнительный код.
Методы изменения массива, такие как push(), pop(), shift(), unshift(), splice(), изменяют исходный массив.

### Flattening nested arrays.

Сглаживание (flattening) вложенных массивов - это процесс преобразования массива с вложенными массивами в одномерный массив, в котором все элементы находятся на одном уровне. Для выполнения этой задачи в JavaScript существует несколько подходов. Давайте рассмотрим некоторые из них:
1. Использование метода flat():
Метод flat() создает новый массив, удаляя все вложенные массивы до указанной глубины. По умолчанию глубина устанавливается в 1.
const nestedArray = [1, [2, 3], [4, [5, 6]]];
const flattenedArray = nestedArray.flat();
console.log(flattenedArray); // [1, 2, 3, 4, [5, 6]]
2. Использование метода reduce():
Метод reduce() может быть использован для сглаживания массива рекурсивно.
const nestedArray = [1, [2, 3], [4, [5, 6]]];
function flattenArray(arr) {
return arr.reduce((acc, curr) => {
return Array.isArray(curr) ? acc.concat(flattenArray(curr)) : acc.concat(curr);
}, []);
}
const flattenedArray = flattenArray(nestedArray);
console.log(flattenedArray); // [1, 2, 3, 4, 5, 6]
3. Использование рекурсии:
Рекурсивная функция может быть использована для обхода всех элементов массива и сглаживания вложенных массивов.
const nestedArray = [1, [2, 3], [4, [5, 6]]];
function flattenArray(arr) {
let result = [];
arr.forEach(item => {
if (Array.isArray(item)) {
result = result.concat(flattenArray(item));
} else {
result.push(item);
}
});
return result;
}
const flattenedArray = flattenArray(nestedArray);
console.log(flattenedArray); // [1, 2, 3, 4, 5, 6]
Примечания:
Метод flat() является наиболее простым способом сглаживания массивов, но может не поддерживаться в старых версиях JavaScript или во всех браузерах.
Использование рекурсии дает большую гибкость и контроль, но может потребовать больше кода.
При сглаживании массива следует учитывать возможные циклические ссылки в структуре данных.

Arrays Iterating, Sorting, Filtering
### Sorting and custom sorting arrays.
Сортировка массивов - это процесс упорядочивания элементов массива в определенном порядке. В JavaScript для этого используется метод sort(). Помимо стандартной сортировки, которая сортирует элементы в лексикографическом порядке, вы также можете определить собственную функцию сравнения для настройки сортировки по вашему усмотрению.
1. Стандартная сортировка:
Метод sort() сортирует элементы массива как строки Unicode.
const array = [5, 2, 8, 1, 4];
array.sort();
console.log(array); // [1, 2, 4, 5, 8]
2. Пользовательская сортировка:
Метод sort() принимает функцию сравнения, которая определяет порядок сортировки. Функция должна возвращать отрицательное число, если первый аргумент меньше второго, положительное число, если первый аргумент больше второго, и 0, если они равны.
const array = [5, 2, 8, 1, 4];
array.sort((a, b) => a - b); // Сортировка по возрастанию
console.log(array); // [1, 2, 4, 5, 8]
const array = [5, 2, 8, 1, 4];
array.sort((a, b) => b - a); // Сортировка по убыванию
console.log(array); // [8, 5, 4, 2, 1]
3. Сортировка объектов:
Если вы сортируете массив объектов, вы также можете передать функцию сравнения для сортировки по определенному свойству объекта.
const people = [
{ name: ‘Alice’, age: 30 },
{ name: ‘Bob’, age: 25 },
{ name: ‘Charlie’, age: 35 }];
people.sort((a, b) => a.age - b.age); // Сортировка по возрасту
console.log(people);
/* Вывод:
[
{ name: ‘Bob’, age: 25 },
{ name: ‘Alice’, age: 30 },
{ name: ‘Charlie’, age: 35 }]
*/
Примечания:
Пользовательская сортировка позволяет точно определить порядок сортировки в зависимости от ваших потребностей.
При сортировке объектов убедитесь, что функция сравнения правильно обрабатывает случаи, когда свойства объектов имеют различные типы данных или отсутствуют.

### Filtering array elements.

ильтрация элементов массива - это процесс удаления элементов, которые не соответствуют определенному условию, и оставление только тех, которые удовлетворяют этому условию. В JavaScript для этого обычно используется метод filter(). Давайте рассмотрим его подробнее:
Использование метода filter():
Метод filter() создает новый массив, содержащий только те элементы исходного массива, для которых функция обратного вызова возвращает true.
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // [2, 4]
Примечания:
Функция обратного вызова, передаваемая в метод filter(), принимает три аргумента: элемент массива, индекс элемента и сам массив.
Если функция обратного вызова возвращает true, элемент добавляется в новый массив, если false - элемент пропускается.
Метод filter() не изменяет исходный массив, а создает новый массив на основе элементов, прошедших фильтрацию.
Вы можете использовать filter() для фильтрации массивов объектов, применяя к ним различные условия, включая значения свойств объектов.

JavaScript in Browser:
### Global Object Window
Глобальный объект window - это главный объект в браузерной среде JavaScript. В контексте веб-разработки, window представляет глобальное окно браузера, в котором отображается текущая веб-страница. В этом объекте содержатся множество встроенных свойств и методов, предоставляемых браузером для управления окном и другими аспектами веб-платформы. Давайте рассмотрим основные характеристики глобального объекта window:
1. Глобальные переменные и функции:
Все переменные и функции, объявленные на верхнем уровне в скрипте, становятся свойствами глобального объекта window.
var globalVariable = ‘Hello’;
function globalFunction() {
console.log(‘World’);
}
console.log(window.globalVariable); // ‘Hello’
window.globalFunction(); // ‘World’
2. Встроенные свойства и методы:
window содержит множество встроенных свойств и методов, таких как document, location, navigator, setTimeout, setInterval и многое другое, которые предоставляют доступ к различным функциям и компонентам браузера.
console.log(window.document); // Объект Document, представляющий текущий HTML-документ
console.log(window.location.href); // URL текущей веб-страницы
console.log(window.navigator.userAgent); // Строка, представляющая информацию о браузере пользователя
3. Обработка событий:
window также предоставляет методы для обработки событий, такие как addEventListener() и removeEventListener(), которые используются для добавления и удаления обработчиков событий на глобальном уровне.
window.addEventListener(‘load’, () => {
console.log(‘Страница загружена’);
});
Примечания:
В контексте браузера, где отсутствует внешняя оболочка, глобальный объект window является главным контейнером для всех глобальных переменных и функций.
Использование свойств и методов window может быть полезным для взаимодействия с браузером и его окружением при разработке веб-приложений.

### Understanding the Document Object Model (DOM).

Модель объектов документа (Document Object Model, DOM) - это структура и интерфейс программирования приложений (API) для HTML и XML документов. Она представляет структуру документа в виде древовидной структуры объектов, которая позволяет JavaScript взаимодействовать с содержимым и структурой веб-страницы. Вот ключевые концепции, которые следует понимать о DOM:

1. Иерархия узлов:
DOM представляет документ в виде дерева узлов, которые представляют различные части документа, такие как элементы HTML, атрибуты, текстовые узлы и т. д. Верхний уровень дерева представляет сам документ, а его потомки представляют элементы и содержимое документа.
<!DOCTYPE html>
    
    # Привет, мир!
    
    Это пример веб-страницы.
    
2. Доступ к элементам:
С помощью JavaScript вы можете получить доступ к элементам документа, используя методы API DOM, такие как getElementById(), getElementsByClassName(), getElementsByTagName() или querySelector(). Эти методы позволяют получить ссылки на элементы по их идентификатору, классу, тегу или CSS селектору.
const header = document.getElementById(‘header’);
const paragraphs = document.getElementsByTagName(‘p’);
const firstParagraph = document.querySelector(‘p’);
3. Изменение содержимого:
JavaScript также позволяет изменять содержимое документа, включая текстовое содержимое элементов, атрибуты и структуру документа. Например, вы можете изменить текст внутри элемента или добавить новый элемент в документ.
const paragraph = document.getElementById(‘paragraph’);
paragraph.textContent = ‘Новый текст’; // Изменение текстового содержимого элемента
const newElement = document.createElement(‘div’); // Создание нового элемента
newElement.textContent = ‘Новый элемент’;
document.body.appendChild(newElement); // Добавление элемента в конец документа
Примечания:
DOM предоставляет множество методов и свойств для взаимодействия с элементами документа, что делает его мощным инструментом для динамического изменения веб-страницы.
Понимание DOM важно для разработчиков веб-приложений, так как это позволяет им создавать интерактивные и динамические пользовательские интерфейсы.

Events Basics
### Types of DOM Events.
События DOM (Document Object Model) представляют собой действия или сигналы, которые браузер отправляет в ваше веб-приложение при определенных действиях пользователя или изменениях веб-страницы. События играют важную роль в создании интерактивных веб-приложений, так как позволяют реагировать на действия пользователя. Вот некоторые из наиболее распространенных типов событий DOM:
1. События мыши:
click: Происходит при клике на элемент.
mouseover: Происходит, когда указатель мыши наводится на элемент.
mouseout: Происходит, когда указатель мыши покидает элемент.
mousedown, mouseup: Происходит при нажатии и отпускании кнопки мыши над элементом.
2. События клавиатуры:
keydown, keyup: Происходит при нажатии и отпускании клавиши на клавиатуре.
3. События фокуса:
focus, blur: Происходит, когда элемент получает или теряет фокус ввода.
4. События формы:
submit: Происходит при отправке формы.
input, change: Происходит при изменении значения элемента формы (текстового поля, чекбокса, радиокнопки и т. д.).
5. События загрузки документа:
DOMContentLoaded: Происходит, когда документ был полностью загружен и разобран (без ожидания загрузки изображений и стилей).
load: Происходит, когда весь контент (включая изображения, стили и т. д.) был полностью загружен.
6. События CSS анимации и переходов:
transitionend: Происходит после завершения CSS перехода.
animationstart, animationend, animationiteration: Происходит при начале, завершении или итерации CSS анимации.
7. Свои события:
Возможно создание и вызов собственных пользовательских событий с помощью методов createEvent() и dispatchEvent().
Примечания:
События DOM позволяют вашему веб-приложению реагировать на действия пользователя и изменения веб-страницы.
Обработчики событий могут быть привязаны к элементам DOM с помощью методов addEventListener() или встроенных атрибутов HTML, таких как onclick, onmouseover, и т. д.
При разработке веб-приложений важно понимать различные типы событий DOM и уметь использовать их для создания интерактивных и отзывчивых пользовательских интерфейсов.

### Working with Mouse and Keyboard Events.

Работа с событиями мыши и клавиатуры в веб-приложениях играет важную роль в создании интерактивного пользовательского интерфейса. С помощью событий мыши и клавиатуры можно отслеживать действия пользователя, такие как щелчки мышью, нажатия клавиш и другие взаимодействия. Давайте рассмотрим основные аспекты работы с этими типами событий подробнее:
Работа с событиями мыши:
click: Происходит при клике на элемент.
element.addEventListener(‘click’, () => {
console.log(‘Кликнули на элемент’);
});
mouseover, mouseout: Происходит при наведении курсора мыши на элемент и его убирании.
element.addEventListener(‘mouseover’, () => {
console.log(‘Курсор наведен на элемент’);
});
element.addEventListener(‘mouseout’, () => {
console.log(‘Курсор убран с элемента’);
});
mousedown, mouseup: Происходит при нажатии и отпускании кнопки мыши над элементом.
element.addEventListener(‘mousedown’, () => {
console.log(‘Кнопка мыши нажата’);
});
element.addEventListener(‘mouseup’, () => {
console.log(‘Кнопка мыши отпущена’);
});
Работа с событиями клавиатуры:
keydown, keyup: Происходит при нажатии и отпускании клавиши на клавиатуре.
document.addEventListener(‘keydown’, event => {
console.log(`Нажата клавиша: ${event.key}`);
});
document.addEventListener(‘keyup’, event => {
console.log(`Отпущена клавиша: ${event.key}`);
});
Обработка нажатия клавиш с помощью кодов клавиш:
document.addEventListener(‘keydown’, event => {
if (event.key === ‘Enter’) {
console.log(‘Нажата клавиша Enter’);
}
});
Примечания:
События мыши и клавиатуры могут быть использованы для создания интерактивных элементов управления, игр, форм и других веб-компонентов.
Обработчики событий мыши и клавиатуры могут быть привязаны к любому элементу DOM с помощью метода addEventListener().
В обработчиках событий мыши и клавиатуры можно использовать объект события для получения дополнительной информации о событии, такой как нажатая клавиша или координаты мыши.

### Handling Form and Input Events.

Обработка событий формы и ввода данных в веб-приложениях является важной частью создания интерактивных пользовательских интерфейсов. События формы и ввода позволяют отслеживать изменения в полях ввода, отправку формы и другие взаимодействия пользователя с элементами формы. Давайте рассмотрим основные аспекты работы с этими типами событий подробнее:

События формы:
submit: Происходит при отправке формы.
const form = document.querySelector(‘form’);
form.addEventListener(‘submit’, event => {
event.preventDefault(); // Отменяет стандартное поведение отправки формы
console.log(‘Форма отправлена’);
});
reset: Происходит при сбросе формы.
form.addEventListener(‘reset’, () => {
console.log(‘Форма сброшена’);
});
События ввода данных:
input: Происходит при изменении значения поля ввода.
const input = document.querySelector(‘input’);

input.addEventListener(‘input’, () => {
console.log(‘Изменено значение поля ввода:’, input.value);
});
change: Происходит при изменении значения поля ввода и потере им фокуса.
input.addEventListener(‘change’, () => {
console.log(‘Изменено значение поля ввода и потерян фокус:’, input.value);
});
События фокуса:
focus: Происходит при получении фокуса элементом формы.
input.addEventListener(‘focus’, () => {
console.log(‘Получен фокус на поле ввода’);
});
blur: Происходит при потере фокуса элементом формы.
input.addEventListener(‘blur’, () => {
console.log(‘Потерян фокус на поле ввода’);
});
Примечания:
Обработчики событий формы и ввода данных могут быть привязаны к любым элементам формы, таким как текстовые поля, кнопки отправки и сброса формы, элементы выбора и т. д.
События формы, такие как submit и reset, позволяют вам контролировать отправку и сброс формы, а события ввода данных, такие как input и change, позволяют реагировать на изменения значений полей ввода в реальном времени.
При обработке событий формы и ввода данных можно использовать объект события для получения дополнительной информации о событии, такой как значения полей ввода или тип события.

### Event Listeners.

События и слушатели событий (Event Listeners) являются важным механизмом взаимодействия JavaScript с элементами HTML. Они позволяют вашему приложению реагировать на действия пользователя, такие как клики, наведение мыши, ввод данных и многое другое. Давайте рассмотрим основные аспекты работы событий и слушателей событий:
Добавление слушателей событий:
Вы можете добавить слушатели событий к элементам DOM с помощью метода addEventListener().
const button = document.querySelector(‘button’);
button.addEventListener(‘click’, () => {
console.log(‘Кнопка была нажата’);
});
Обработчики событий:
Функция, переданная в addEventListener(), называется обработчиком события. Она будет выполнена при наступлении события.
const button = document.querySelector(‘button’);
function handleClick() {
console.log(‘Кнопка была нажата’);
}
button.addEventListener(‘click’, handleClick);
Удаление слушателей событий:
Вы можете удалить слушателей событий с помощью метода removeEventListener().
const button = document.querySelector(‘button’);
function handleClick() {
console.log(‘Кнопка была нажата’);
}
button.addEventListener(‘click’, handleClick);
// Удаление слушателя
button.removeEventListener(‘click’, handleClick);
Объект события:
Обработчики событий получают объект события, который содержит информацию о событии, такую как тип события, целевой элемент и многое другое.
const button = document.querySelector(‘button’);

button.addEventListener(‘click’, event => {
console.log(‘Тип события:’, event.type);
console.log(‘Целевой элемент:’, event.target);
});
Примечания:
События и слушатели событий позволяют создавать интерактивные пользовательские интерфейсы и реагировать на действия пользователя.
Вы можете добавлять несколько слушателей событий к одному элементу, а также удалять их при необходимости.
Обработчики событий могут быть анонимными функциями или именованными функциями.
В обработчиках событий можно использовать объект события для доступа к дополнительной информации о событии.

### Event Phases and their differences.

Фазы событий в DOM (Document Object Model) определяют порядок, в котором события обрабатываются при их возникновении. Событие проходит через три основные фазы: захват (capture), цель (target) и всплытие (bubble). Рассмотрим каждую фазу подробнее:
1. Фаза захвата (Capture Phase):
В этой фазе событие начинает свой путь с корневого элемента DOM и спускается по иерархии DOM к целевому элементу. Во время этой фазы событие не достигает целевого элемента, но слушатели событий, установленные на предках целевого элемента, могут перехватывать и обрабатывать событие.
2. Фаза цели (Target Phase):
В этой фазе событие достигает целевого элемента, на котором произошло событие. Событие вызывает все слушатели событий, установленные непосредственно на целевом элементе. Эта фаза является пунктом входа в обработку события для этого элемента.
3. Фаза всплытия (Bubble Phase):
После завершения фазы цели событие начинает свой путь обратно к корневому элементу DOM. Во время этой фазы событие всплывает по иерархии DOM, вызывая слушатели событий на каждом предке целевого элемента. Это позволяет реализовать обработку событий вверх по иерархии элементов.
Различия между фазами:
Цель vs. Погружение: В фазе цели событие достигает элемента, на котором произошло событие, в то время как в фазе погружения событие движется от корневого элемента к целевому элементу.
Порядок обработки: Событие проходит через фазы в определенном порядке: сначала захват, затем цель, и, наконец, всплытие.
Обработка слушателей: В каждой фазе события вызываются только те слушатели, которые были установлены на элементах, принимающих участие в данной фазе.
Использование фаз событий позволяет более гибко управлять обработкой событий и реализовывать различные сценарии взаимодействия с пользователем.

### Custom events (optional).

Пользовательские события (Custom events) - это механизм в JavaScript, который позволяет создавать и запускать собственные события. В отличие от встроенных браузерных событий, пользовательские события могут быть определены и использованы в вашем коде для обмена информацией между различными частями вашего приложения. Давайте рассмотрим подробнее:
Создание пользовательского события:
Для создания пользовательского события используется конструктор CustomEvent.
// Создание пользовательского события с именем “customEvent”
const customEvent = new CustomEvent(‘customEvent’, {
detail: { message: ‘Привет, мир!’ } // Дополнительные данные, передаваемые событию
});
Добавление слушателя пользовательского события:
После создания пользовательского события можно добавить слушателя, который будет реагировать на это событие.
// Добавление слушателя пользовательского события
document.addEventListener(‘customEvent’, event => {
console.log(‘Сообщение из пользовательского события:’, event.detail.message);
});
Запуск пользовательского события:
После создания и настройки пользовательского события, его можно запустить с помощью метода dispatchEvent().
// Запуск пользовательского события
document.dispatchEvent(customEvent);
Передача данных через пользовательское событие:
Вы можете передать дополнительные данные через пользовательское событие, используя свойство detail в объекте конфигурации события при его создании. Эти данные будут доступны в обработчике события через свойство event.detail.
Преимущества пользовательских событий:
Гибкость: Пользовательские события позволяют создавать собственные механизмы взаимодействия между частями вашего приложения.
Масштабируемость: Они упрощают разработку крупных и сложных приложений, позволяя модулям взаимодействовать без прямой зависимости друг от друга.
Расширяемость: Вы можете расширять функциональность вашего кода, добавляя новые пользовательские события для определенных действий или событий.
Использование пользовательских событий может значительно улучшить структуру вашего кода и обеспечить более эффективное взаимодействие между его различными частями.

Events Propagation / Preventing
### Event propagation cycle.
Цикл распространения события (Event propagation cycle) описывает последовательность этапов, через которые проходит событие от момента его возникновения до обработки всеми слушателями. Этот процесс состоит из трех основных фаз: захват (capture), цель (target), и всплытие (bubble). Давайте рассмотрим каждую фазу подробнее:
1. Фаза захвата (Capture Phase):
В этой фазе событие начинает свой путь с корневого элемента DOM и движется вниз по иерархии DOM к целевому элементу. Во время этой фазы событие не достигает целевого элемента, но слушатели событий, установленные на предках целевого элемента, могут перехватывать и обрабатывать событие.
2. Фаза цели (Target Phase):
В этой фазе событие достигает целевого элемента, на котором произошло событие. Событие вызывает все слушатели событий, установленные непосредственно на целевом элементе. Эта фаза является пунктом входа в обработку события для этого элемента.
3. Фаза всплытия (Bubble Phase):
После завершения фазы цели событие начинает свой путь обратно к корневому элементу DOM. Во время этой фазы событие всплывает по иерархии DOM, вызывая слушатели событий на каждом предке целевого элемента. Это позволяет реализовать обработку событий вверх по иерархии элементов.
Порядок обработки:
События проходят через фазы в определенном порядке: сначала захват, затем цель, и, наконец, всплытие. Этот порядок позволяет реализовать различные сценарии взаимодействия с пользователем и обеспечивает гибкость при обработке событий.
Примечания:
Обработчики событий могут быть установлены как на захват, так и на всплытие, используя третий аргумент метода addEventListener() (true для захвата и false или опущенный для всплытия).
Порядок обработки событий позволяет реализовать различные сценарии взаимодействия с пользователем и обеспечивает гибкость при обработке событий.
Понимание цикла распространения событий помогает эффективно управлять взаимодействием пользовательского интерфейса в вашем веб-приложении.

### Stopping event propagation.

Остановка распространения события (Stopping event propagation) - это процесс предотвращения дальнейшего распространения события вверх или вниз по иерархии DOM. Это полезный механизм, который позволяет контролировать, какие элементы должны обрабатывать событие, а какие нет. Давайте рассмотрим, как можно остановить распространение события подробнее:
Остановка распространения во время захвата и всплытия:
stopPropagation(): Метод stopPropagation() вызывается на объекте события и предотвращает дальнейшее распространение события вверх или вниз по иерархии DOM.
element.addEventListener(‘click’, event => {
event.stopPropagation(); // Остановить распространение события
console.log(‘Событие обработано на этом элементе’);
});
Остановка распространения во время захвата:
В случае захвата, можно использовать третий аргумент метода addEventListener(), чтобы установить слушателя события в режим захвата. В этом случае событие будет перехвачено на самом раннем этапе, ещё до достижения целевого элемента.
element.addEventListener(‘click’, event => {
console.log(‘Событие захвачено на этом элементе’);
}, true); // Установка режима захвата
Примечания:
Использование stopPropagation() может быть полезным, когда вы хотите предотвратить вызов слушателей событий на родительских или дочерних элементах определенного элемента.
Остановка распространения события может быть полезна для предотвращения неожиданных взаимодействий между различными частями интерфейса или конфликтов между различными компонентами приложения.
Будьте осторожны при использовании stopPropagation(), чтобы не создать ситуацию, когда некоторые элементы перестают реагировать на события вообще.

### Preventing default browser behavior.

Предотвращение стандартного поведения браузера (Preventing default browser behavior) - это процесс предотвращения выполнения действия по умолчанию, которое обычно происходит при возникновении определенного события. Например, клик по ссылке перенаправляет нас на другую страницу, а отправка формы загружает новую страницу или обновляет текущую. Предотвращение этого стандартного поведения может быть полезным для реализации более интерактивных пользовательских интерфейсов. Давайте рассмотрим, как можно предотвратить стандартное поведение браузера подробнее:
Использование preventDefault():
preventDefault(): Метод preventDefault() вызывается на объекте события и предотвращает выполнение стандартного действия, связанного с событием.
element.addEventListener(‘click’, event => {
event.preventDefault(); // Предотвратить стандартное действие браузера
console.log(‘Стандартное действие предотвращено’);
});
Применение к различным типам событий:
Для ссылок (click): Предотвращение перехода по ссылке.
document.querySelector(‘a’).addEventListener(‘click’, event => {
event.preventDefault();
});
Для форм (submit): Предотвращение отправки формы.
document.querySelector(‘form’).addEventListener(‘submit’, event => {
event.preventDefault();
});
Примечания:
Предотвращение стандартного поведения браузера особенно полезно при разработке веб-приложений с использованием AJAX или SPA (Single Page Application), где страницы не перезагружаются при многих взаимодействиях пользователя.
При использовании preventDefault() убедитесь, что вы предоставляете пользователю альтернативные способы выполнения действий, которые могут быть предотвращены. Например, предоставьте кнопку “Отмена” для форм или инструкции о том, что произойдет после клика по ссылке.

### Event delegation and its pros/cons.

Делегирование событий (Event delegation) - это паттерн в JavaScript, который позволяет обрабатывать события на родительском элементе вместо непосредственно на дочерних элементах. При использовании этого паттерна события “всплывают” вверх по DOM-дереву, что позволяет обрабатывать их на более высоком уровне, чем на конкретном элементе. Давайте рассмотрим подробнее, как работает делегирование событий и его преимущества и недостатки:
Принцип работы:
Установка обработчика на родительский элемент: Обработчик события устанавливается на родительский элемент, который содержит целевые элементы, на которые вы хотите реагировать.
Использование событий всплытия (bubbling): События всплывают от дочерних элементов к родительским, что позволяет обрабатывать их на родительском элементе.
Определение целевого элемента: В обработчике события можно определить целевой элемент, на котором произошло событие, и выполнить соответствующие действия.
Преимущества:
Уменьшение количества обработчиков: При использовании делегирования событий вы можете установить один обработчик на родительский элемент вместо установки обработчика на каждый дочерний элемент, что может существенно уменьшить количество обработчиков и улучшить производительность.
Работает с динамически создаваемыми элементами: Делегирование событий позволяет обрабатывать события на элементах, которые были добавлены в DOM после установки обработчика, что делает его особенно полезным для работы с динамически создаваемыми элементами.
Недостатки:
Сложнее определить целевой элемент: При обработке событий на родительском элементе может быть сложнее определить, на каком именно дочернем элементе произошло событие, особенно если у вас есть много разных дочерних элементов.
Не подходит для всех случаев: Делегирование событий может быть неудобным в случаях, когда необходимо обрабатывать события на конкретных дочерних элементах с разными обработчиками.
Пример:
// HTML

- Элемент 1
- Элемент 2
- Элемент 3

// JavaScript
document.getElementById(‘myList’).addEventListener(‘click’, function(event) {
if (event.target.tagName === ‘LI’) {
console.log(‘Вы нажали на элемент:’, event.target.textContent);
}
});

Делегирование событий - это мощный и эффективный паттерн в JavaScript, который позволяет управлять событиями более эффективно, особенно при работе с большим количеством элементов или динамически создаваемыми элементами. Однако важно учитывать его ограничения и правильно применять в контексте вашего приложения.

Timers
### Usage of setTimeout / setInterval.
Функции setTimeout() и setInterval() - это методы JavaScript, которые позволяют выполнить код через определенный интервал времени. Вот как они работают и как их использовать:
setTimeout():
setTimeout() используется для запуска выполнения функции один раз через определенный промежуток времени.
setTimeout(function() {
console.log(‘Этот код выполнится один раз через 2 секунды’);
}, 2000); // 2000 миллисекунд (2 секунды)
Применения setTimeout():
Запуск анимаций: Вы можете использовать setTimeout() для создания анимаций, изменяя стили элементов через определенные интервалы времени.
Обновление данных: Приложения могут использовать setTimeout() для периодического обновления данных с сервера или других источников данных без перезагрузки страницы.
setInterval():
setInterval() позволяет запускать выполнение функции регулярно через определенные интервалы времени.
setInterval(function() {
console.log(‘Этот код будет выполняться каждые 3 секунды’);
}, 3000); // 3000 миллисекунд (3 секунды)
Применения setInterval():
Автообновление: Используйте setInterval(), чтобы регулярно обновлять данные или состояние вашего приложения без необходимости вручную обновлять страницу.
Регулярные оповещения: Можно использовать setInterval(), чтобы создавать регулярные оповещения или уведомления для пользователя.
Преимущества и недостатки:
Преимущества:
Простота использования и понимания.
Удобство для выполнения операций через определенные промежутки времени.
Недостатки:
Различные проблемы с производительностью, особенно при использовании setInterval() для коротких интервалов или интенсивных операций.
Риск переполнения очереди событий, если код внутри setTimeout() или setInterval() выполняется дольше, чем интервал между вызовами.

setTimeout() и setInterval() - это мощные инструменты для выполнения кода через определенные промежутки времени в JavaScript. Однако необходимо использовать их осторожно, учитывая их влияние на производительность и потенциальные проблемы с обработкой событий.

### Clearing timers with clearTimeout / clearInterval.

clearTimeout() и clearInterval() используются для отмены выполнения кода, запланированного с помощью setTimeout() и setInterval() соответственно. Давайте рассмотрим их подробнее:
clearTimeout():
clearTimeout() используется для отмены выполнения кода, который был запланирован с помощью setTimeout().
const timerId = setTimeout(function() {
console.log(‘Этот код не будет выполнен’);
}, 2000);
clearTimeout(timerId); // Отмена выполнения кода, запланированного с setTimeout()
Примечания по clearTimeout():
clearTimeout() принимает один аргумент - идентификатор таймера, возвращаемый функцией setTimeout().
Если clearTimeout() вызывается до истечения времени, указанного в setTimeout(), то запланированный код не будет выполнен.
clearInterval():
clearInterval() используется для отмены выполнения кода, который был запланирован с помощью setInterval().
const intervalId = setInterval(function() {
console.log(‘Этот код выполняется каждые 3 секунды’);
}, 3000);
clearInterval(intervalId); // Отмена выполнения кода, запланированного с setInterval()
Примечания по clearInterval():
clearInterval() также принимает один аргумент - идентификатор таймера, возвращаемый функцией setInterval().
Если clearInterval() вызывается, то код, запланированный с помощью setInterval(), больше не будет выполняться с заданным интервалом.
Преимущества использования:
Позволяет управлять выполнением кода, запланированного с помощью таймеров, что может быть полезно при динамическом изменении времени выполнения или при необходимости остановки повторяющегося кода.

clearTimeout() и clearInterval() - это важные инструменты в JavaScript для управления таймерами и предотвращения выполнения запланированного кода. Правильное использование этих функций помогает избежать проблем с производительностью и ненужного выполнения кода.

Web Storage API & Cookies
### Differences between LocalStorage, SessionStorage, and Cookies.
LocalStorage, SessionStorage и Cookies - это три основных механизма для хранения данных на стороне клиента в веб-приложениях. Вот их подробное сравнение:
Cookies:
Хранение данных: Cookies хранят данные в виде пар ключ-значение в виде текста на стороне клиента. Каждое хранимое значение имеет свою длину ограниченную примерно 4 кб.
Использование: Cookies отправляются автоматически с каждым HTTP-запросом, что делает их подходящими для хранения данных, которые необходимо передавать между клиентом и сервером.
Хранение сроков действия: Можно задать срок действия для cookies, после которого они будут удалены. Они могут быть постоянными (сохраняются на диск клиента) или сеансовыми (удаляются при закрытии браузера).
LocalStorage:
Хранение данных: LocalStorage также хранит данные в виде пар ключ-значение, но в отличие от cookies, они хранятся в браузере без отправки на сервер. Максимальный размер хранимых данных составляет примерно 5-10 МБ для большинства браузеров.
Использование: LocalStorage может использоваться для хранения данных, которые должны сохраняться между сеансами браузера и не требуют отправки на сервер.
Срок хранения: Данные в LocalStorage сохраняются даже после закрытия браузера и могут быть доступны при последующих посещениях сайта.
SessionStorage:
Хранение данных: SessionStorage аналогичен LocalStorage, но хранит данные только на время сеанса. Это означает, что данные будут удалены, когда пользователь закроет вкладку или браузер.
Использование: SessionStorage полезен для хранения временных данных, которые должны быть доступны только в течение одного сеанса.
Сравнение:
Производительность: Cookies могут замедлить загрузку веб-страницы, так как они отправляются с каждым HTTP-запросом. LocalStorage и SessionStorage не влияют на производительность загрузки страницы.
Безопасность: Cookies можно защитить от доступа через определенные параметры. LocalStorage и SessionStorage доступны только для JavaScript на странице, поэтому могут быть менее безопасными.
Емкость: Cookies имеют меньший объем хранения данных по сравнению с LocalStorage и SessionStorage.
Использование:
Cookies часто используются для аутентификации, отслеживания сеансов и хранения предпочтений пользователя.
LocalStorage и SessionStorage используются для хранения состояния приложения, кэширования данных и других временных данных, которые не требуют отправки на сервер.

### Differences between LocalStorage, SessionStorage, and Cookies Способы хранения информации

LocalStorage, SessionStorage и Cookies - это три основных механизма для хранения данных на стороне клиента в веб-приложениях. 

### Cookies

Хранение данных: Cookies хранят данные в виде пар ключ-значение в виде текста на стороне клиента. Каждое хранимое значение имеет свою длину ограниченную примерно 4 кб.
Использование: Cookies отправляются автоматически с каждым HTTP-запросом, что делает их подходящими для хранения данных, которые необходимо передавать между клиентом и сервером.
Хранение сроков действия: Можно задать срок действия для cookies, после которого они будут удалены. Они могут быть постоянными (сохраняются на диск клиента) или сеансовыми (удаляются при закрытии браузера).

### LocalStorage

Хранение данных: LocalStorage также хранит данные в виде пар ключ-значение, но в отличие от cookies, они хранятся в браузере без отправки на сервер. Максимальный размер хранимых данных составляет примерно 5-10 МБ для большинства браузеров.
Использование: LocalStorage может использоваться для хранения данных, которые должны сохраняться между сеансами браузера и не требуют отправки на сервер.
Срок хранения: Данные в LocalStorage сохраняются даже после закрытия браузера и могут быть доступны при последующих посещениях сайта.

### SessionStorage

Хранение данных: SessionStorage аналогичен LocalStorage, но хранит данные только на время сеанса. Это означает, что данные будут удалены, когда пользователь закроет вкладку или браузер.
Использование: SessionStorage полезен для хранения временных данных, которые должны быть доступны только в течение одного сеанса.

Сравнение:
Производительность: Cookies могут замедлить загрузку веб-страницы, так как они отправляются с каждым HTTP-запросом. LocalStorage и SessionStorage не влияют на производительность загрузки страницы.
Безопасность: Cookies можно защитить от доступа через определенные параметры. LocalStorage и SessionStorage доступны только для JavaScript на странице, поэтому могут быть менее безопасными.
Емкость: Cookies имеют меньший объем хранения данных по сравнению с LocalStorage и SessionStorage.

Использование:
Cookies часто используются для аутентификации, отслеживания сеансов и хранения предпочтений пользователя.
LocalStorage и SessionStorage используются для хранения состояния приложения, кэширования данных и других временных данных, которые не требуют отправки на сервер.

Каждый из механизмов хранения данных имеет свои преимущества и недостатки, и правильный выбор зависит от требований вашего веб-приложения. Cookies подходят для обмена данными между клиентом и сервером, в то время как LocalStorage и SessionStorage обеспечивают удобное хранение данных на стороне клиента для временного или постоянного использования.

Date & Time (optional)
### Working with the Date object.
Объект Date в JavaScript используется для работы с датами и временем. Он позволяет создавать объекты, представляющие дату и время, а также выполнять множество операций с ними. Вот подробное рассмотрение работы с объектом Date:

Создание объекта Date:
const currentDate = new Date(); // Создание объекта с текущей датой и временем
const specificDate = new Date(‘2022-12-31’); // Создание объекта с конкретной датой
const specificTime = new Date(2022, 11, 31, 12, 30, 0); // Создание объекта с конкретным временем
Получение компонентов даты и времени:
const year = currentDate.getFullYear(); // Получение года (четыре цифры)
const month = currentDate.getMonth(); // Получение месяца (0-11)
const date = currentDate.getDate(); // Получение дня месяца (1-31)
const hours = currentDate.getHours(); // Получение часов (0-23)
const minutes = currentDate.getMinutes(); // Получение минут (0-59)
const seconds = currentDate.getSeconds(); // Получение секунд (0-59)
Работа с датами и временем:
currentDate.setDate(currentDate.getDate() + 1); // Добавление одного дня
currentDate.setMonth(currentDate.getMonth() + 1); // Добавление одного месяца
currentDate.setHours(currentDate.getHours() + 1); // Добавление одного часа
Форматирование даты и времени:

const options = { weekday: ‘long’, year: ‘numeric’, month: ‘long’, day: ‘numeric’ };
const formattedDate = currentDate.toLocaleDateString(‘en-US’, options);
Получение времени в миллисекундах:
const currentTimeInMillis = currentDate.getTime();
Работа с разницей во времени:
const otherDate = new Date(‘2023-01-01’);
const timeDifference = otherDate - currentDate; // Разница в миллисекундах между двумя датами
Пример использования:
const birthday = new Date(‘2000-10-15’);
const today = new Date();
const age = today.getFullYear() - birthday.getFullYear();

Объект Date предоставляет широкий спектр методов для работы с датами и временем в JavaScript. Он позволяет создавать, форматировать, изменять и сравнивать даты, а также выполнять множество других операций. При использовании объекта Date важно учитывать его особенности, такие как нумерация месяцев с 0 и различия в поддержке методов между разными браузерами.

### Timezones and Internationalization in JavaScript (Intl).

Работа с часовыми поясами (Timezones) и интернационализацией (Internationalization) в JavaScript включает в себя использование объекта Intl для форматирования дат, времени, чисел и валют в соответствии с различными локализациями и часовыми поясами. Давайте подробнее рассмотрим использование Intl:

Форматирование даты и времени:
const now = new Date();
const dateFormatter = new Intl.DateTimeFormat(‘en-US’, { weekday: ‘long’, year: ‘numeric’, month: ‘long’, day: ‘numeric’ });
const formattedDate = dateFormatter.format(now); // Выводит дату в формате “Wednesday, April 6, 2022”
Форматирование чисел:
const number = 123456.789;
const numberFormatter = new Intl.NumberFormat(‘de-DE’, { style: ‘currency’, currency: ‘EUR’ });
const formattedNumber = numberFormatter.format(number); // Выводит число в формате “123.456,79 €”
Форматирование валюты:
const currency = 123456.78;
const currencyFormatter = new Intl.NumberFormat(‘en-US’, { style: ‘currency’, currency: ‘USD’ });
const formattedCurrency = currencyFormatter.format(currency); // Выводит валюту в формате “$123,456.78”
Работа с часовыми поясами:
const timeZone = ‘America/New_York’;
const timeFormatter = new Intl.DateTimeFormat(‘en-US’, { timeZone: timeZone, timeStyle: ‘medium’ });
const formattedTime = timeFormatter.format(now); // Выводит время в часовом поясе “America/New_York”
Локализация:
const language = ‘fr-FR’;
const dateFormatterFR = new Intl.DateTimeFormat(language, { weekday: ‘long’, year: ‘numeric’, month: ‘long’, day: ‘numeric’ });
const formattedDateFR = dateFormatterFR.format(now); // Выводит дату на французском языке
Обработка ошибок:
try {
const invalidDate = new Date(‘invalid’);
} catch (error) {
console.error(‘Invalid date:’, error.message);
}

Объект Intl в JavaScript предоставляет мощные средства для форматирования дат, времени, чисел и валюты, а также для работы с часовыми поясами и локализацией. Он позволяет создавать приложения, которые могут адаптироваться к различным культурным и локальным настройкам, что делает его важным инструментом для международной разработки веб-приложений.

Design Patterns
Intermediate Knowledge
### Understanding and applying KISS, DRY, and YAGNI principles.

Coding tasks:

Coding Tasks Examples

### Array.flat Polyfill

Implement a polyfill for the Array.flat method. This method should flatten an array up to the specified depth, handling cases where the depth is not provided (default to 1) or when it’s an infinite depth.

// Проверяем, существует ли метод flat в массивах
if (!Array.prototype.flat) {
Array.prototype.flat = function(depth = 1) {
// Создаем новый массив для хранения результата
const flattenedArray = [];
// Рекурсивная функция для сглаживания массива
function flatten(array, currentDepth) {
// Проходим по каждому элементу массива
array.forEach(item => {
// Если текущий элемент является массивом и мы еще не достигли максимальной глубины
if (Array.isArray(item) && currentDepth < depth) {
// Рекурсивно вызываем flatten для этого элемента с увеличенной глубиной
flatten(item, currentDepth + 1);
} else {
// В противном случае добавляем элемент в результирующий массив
flattenedArray.push(item);
}
});
}
// Начинаем сглаживание массива с глубиной 1
flatten(this, 1);
// Возвращаем сглаженный массив
return flattenedArray;
};
}

### Array.reduce Polyfill

Write a polyfill for the Array.reduce method. Ensure your implementation handles all the functionalities of the native reduce method, including the accumulator and current value parameters, as well as the optional initial value.
if (!Array.prototype.reduce) {
Array.prototype.reduce = function(callback, initialValue) {
// Проверяем, что массив не пустой
if (this.length === 0 && initialValue === undefined) {
throw new TypeError(‘Reduce of empty array with no initial value’);
}
// Инициализируем аккумулятор начальным значением или первым элементом массива
let accumulator = initialValue !== undefined ? initialValue : this[0];
let startIndex = initialValue !== undefined ? 0 : 1;
// Проходим по оставшимся элементам массива и вызываем callback
for (let i = startIndex; i < this.length; i++) {
accumulator = callback(accumulator, this[i], i, this);
}
// Возвращаем итоговое значение аккумулятора
return accumulator;
};
}

### String Repeater

Create a method that extends the String prototype to repeat a given string a specified number of times. For example, calling ‘hello world’.repeating(3) should return ‘hello world hello world hello world’. The method should handle edge cases like non-integer repeat times and negative numbers.
String.prototype.repeating = function(times) {
// Проверяем, является ли times числом и не является ли отрицательным
if (typeof times !== ‘number’ || !Number.isInteger(times) || times <= 0) {
throw new Error(‘Invalid repeat times’);
}
// Инициализируем пустую строку, в которую будем добавлять повторения
let repeatedString = ’‘;
// Повторяем исходную строку указанное количество раз
for (let i = 0; i < times; i++) {
repeatedString += this +’ ‘; // Добавляем пробел после каждого повторения
}
// Удаляем лишний пробел в конце строки
repeatedString = repeatedString.trim();
return repeatedString;
};
// Пример использования:
console.log(’hello world’.repeating(3));

### String.prototype.padStart Polyfill

Write a polyfill for the String.prototype.padStart method. It should pad the current string from the start with another string (multiple times if necessary) until the resulting string reaches the given length.
if (!String.prototype.padStart) {
String.prototype.padStart = function(targetLength, padString) {
// Преобразуем текущую строку в строку
let str = String(this);
// Проверяем, если нужно добавлять пустые пространства
if (padString === undefined) {
padString = ’ ‘;
}
// Проверяем, если строка уже длиннее или равна целевой длине
if (str.length >= targetLength) {
return str;
}
// Вычисляем, сколько символов нужно добавить
const padLength = targetLength - str.length;
// Строим строку с пустыми пространствами
const padding = padString.repeat(Math.ceil(padLength / padString.length)).substring(0, padLength);
// Возвращаем объединенную строку
return padding + str;
};
}
// Пример использования:
console.log(’abc’.padStart(10)); // Выводит ’ abc’
console.log(‘abc’.padStart(10, ‘123’)); // Выводит ‘1231231abc’

### Custom setTimeout Implementation

Implement a custom version of setTimeout using only Date and a while loop, without using the native setTimeout function.
function customSetTimeout(callback, delay) {
// Получаем текущее время
const startTime = new Date().getTime();
// Запускаем цикл, который будет выполняться, пока не истечет время ожидания
while (new Date().getTime() < startTime + delay) {
// Пустое тело цикла, ничего не делаем
}
// Как только время ожидания истекло, вызываем функцию обратного вызова
callback();
}
// Пример использования:
console.log(‘Start’);
customSetTimeout(() => {
console.log(‘Hello after 2000 milliseconds’);
}, 2000);
console.log(‘End’);

### Memoization Function

Create a function that implements memoization to cache and return the results of expensive function calls.
function memoization(func) {
const cache = {}; // Объект для кэширования результатов
return function(…args) {
const key = JSON.stringify(args); // Создаем ключ на основе аргументов функции
if (!(key in cache)) { // Проверяем, есть ли результат в кэше
cache[key] = func.apply(this, args); // Вызываем функцию с переданными аргументами и сохраняем результат в кэше
}
return cache[key]; // Возвращаем результат из кэша
};
}

### Currying Logger:

Develop a curryLogger function that takes a logging function and returns a curried version of this function.
Функция “curryLogger” должна принимать функцию журналирования (например, console.log) и возвращать каррированную версию этой функции. Каррированная функция позволяет вызывать исходную функцию с частичным набором аргументов и возвращает новую функцию, которая ожидает оставшиеся аргументы.
Вот пример решения на JavaScript:
function curryLogger(logger) {
return function(…args) {
return function(…innerArgs) {
logger(…args, …innerArgs); // Вызываем функцию журналирования с аргументами и внутренними аргументами
};
};
}
В этом решении:
Функция curryLogger принимает функцию журналирования (logger) в качестве аргумента.
Возвращается анонимная функция, которая принимает аргументы (args).
Внутри анонимной функции создается еще одна анонимная функция, которая принимает внутренние аргументы (innerArgs).
Внутренняя анонимная функция вызывает функцию журналирования (logger) с объединенными внешними и внутренними аргументами.
Теперь мы можем использовать curryLogger для каррирования функции журналирования:
// Создаем каррированную версию функции журналирования console.log
const curriedLogger = curryLogger(console.log);
// Журналируем сообщение “Hello, World!” с использованием каррированной функции
curriedLogger(“Hello, World!”); // Выводит “Hello, World!”
Таким образом, мы можем использовать curryLogger для создания каррированных версий любой функции журналирования, что позволяет нам удобно использовать ее с частичным набором аргументов.

### Arguments Reverser

Implement a function that reverses the order of arguments it receives, returning a new function with reversed arguments.
Для этой задачи вам нужно реализовать функцию, которая принимает другую функцию в качестве аргумента и возвращает новую функцию, которая принимает аргументы в обратном порядке.

Вот пример того, как это можно сделать на JavaScript:
function reverseArguments(func) {
return function(…args) {
return func(…args.reverse());
};
}
Это решение включает в себя:
Функция reverseArguments, которая принимает функцию func в качестве аргумента.
Возвращение анонимной функции, которая принимает любое количество аргументов через оператор …args.
Внутри анонимной функции вызывается функция func с аргументами, которые были развернуты с помощью метода reverse().
Теперь вы можете использовать эту функцию для создания новой функции с аргументами, переданными в обратном порядке:
function exampleFunc(a, b, c) {
console.log(a, b, c);
}
const reversedFunc = reverseArguments(exampleFunc);
reversedFunc(1, 2, 3); // Выведет “3 2 1”

### Private Counter Closure

Craft a function that uses closures to create a private counter, which can only be modified through specific methods.
Для этой задачи вам нужно создать функцию, которая будет использовать замыкания для создания приватного счетчика, который может быть изменен только через определенные методы. Это означает, что счетчик будет доступен только внутри этой функции, и его значение можно будет изменить только с помощью специальных методов, которые мы предоставим.

Вот пример, как это можно сделать на JavaScript:
function createCounter() {
let count = 0; // Приватная переменная счетчика

```
return {
    increment: function() { // Метод для увеличения счетчика на 1
        count++;
    },
    decrement: function() { // Метод для уменьшения счетчика на 1
        count--;
    },
    getCount: function() { // Метод для получения текущего значения счетчика
        return count;
    }
};
```

}
// Создаем экземпляр объекта счетчика
const counter = createCounter();
// Увеличиваем счетчик на 1
counter.increment();
console.log(counter.getCount()); // Выведет 1
// Уменьшаем счетчик на 1
counter.decrement();
console.log(counter.getCount()); // Выведет 0

### Rest Parameters Sum

Write a function that uses rest parameters to calculate and return the sum of an indefinite number of arguments.
Для решения этой задачи вам нужно создать функцию, которая использует rest-параметры для получения неопределенного количества аргументов и вычисления их суммы.
Вот пример такой функции на JavaScript:
function sum(…args) {
return args.reduce((total, current) => total + current, 0);
}

### Object Freeze Deep

Create a function that deeply freezes an object, ensuring all nested objects are also frozen.
Для решения этой задачи вам нужно создать функцию, которая рекурсивно замораживает объект, включая все вложенные объекты внутри него.
Вот пример такой функции на JavaScript:
function deepFreeze(obj) {
// Замораживаем текущий объект
Object.freeze(obj);
// Рекурсивно замораживаем все свойства объекта, которые являются объектами
for (let key in obj) {
if (obj.hasOwnProperty(key) && typeof obj[key] === ‘object’ && !Object.isFrozen(obj[key])) {
deepFreeze(obj[key]);
}
}
return obj;
}
Эта функция deepFreeze принимает объект obj и сначала замораживает его с помощью Object.freeze(). Затем она проходит через все свойства этого объекта и, если какое-то свойство является объектом и не заморожено, рекурсивно замораживает его вызовом deepFreeze.
Теперь вы можете использовать эту функцию, чтобы глубоко заморозить любой объект:
const obj = {
a: 1,
b: {
c: 2,
d: {
e: 3
}
}
};
deepFreeze(obj);
// Попытка изменить значения объекта
obj.a = 10; // Не сработает, так как объект заморожен
obj.b.c = 20; // Не сработает, так как объект заморожен
obj.b.d.e = 30; // Не сработает, так как объект заморожен

### Array Chunker

Develop a function that divides an array into chunks of a specified size and returns them.
Для решения этой задачи вам нужно создать функцию, которая принимает массив и размер куска (чанка), на которые нужно разделить этот массив, и возвращает массив из чанков.
Вот пример такой функции на JavaScript:
function chunkArray(arr, size) {
const chunkedArray = []; // Результирующий массив чанков
for (let i = 0; i < arr.length; i += size) {
chunkedArray.push(arr.slice(i, i + size)); // Добавляем чанк в результирующий массив
}
return chunkedArray;
}
Эта функция chunkArray принимает массив arr и размер size чанка. Затем она использует цикл for, чтобы проходить по массиву arr с шагом size и для каждого элемента массива вызывает метод slice, чтобы получить чанк заданного размера. Этот чанк затем добавляется в результирующий массив chunkedArray.
Теперь вы можете использовать эту функцию для разделения массива на чанки:
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const chunkedArray = chunkArray(array, 3);
console.log(chunkedArray); // Выведет [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
Таким образом, функция chunkArray позволяет разделить массив на чанки заданного размера.

### Custom Array Filter

Implement your own version of the array filter function without using the built-in Array.prototype.filter method.
Для решения этой задачи мы можем создать свою собственную функцию customFilter, которая будет принимать массив и функцию обратного вызова (callback) и возвращать новый массив, содержащий только те элементы, для которых функция обратного вызова возвращает true.
Вот пример такой функции на JavaScript:
function customFilter(arr, callback) {
const filteredArray = []; // Результирующий массив
// Проходим по каждому элементу массива
for (let i = 0; i < arr.length; i++) {
// Проверяем, соответствует ли текущий элемент условиям функции обратного вызова
if (callback(arr[i], i, arr)) {
filteredArray.push(arr[i]); // Добавляем элемент в результирующий массив
}
}

```
return filteredArray;
```

}
Эта функция customFilter принимает массив arr и функцию обратного вызова callback. Затем она проходит по каждому элементу массива arr и вызывает функцию callback для каждого элемента с передачей текущего элемента, индекса и самого массива. Если функция callback вернет true для текущего элемента, то он добавляется в результирующий массив filteredArray.
Теперь вы можете использовать эту функцию для фильтрации массива:
const array = [1, 2, 3, 4, 5];
// Функция обратного вызова для проверки четности элементов
function isEven(num) {
return num % 2 === 0;
}
const filteredArray = customFilter(array, isEven);
console.log(filteredArray); // Выведет [2, 4]
Таким образом, функция customFilter предоставляет альтернативный способ фильтрации массива без использования встроенного метода filter массива.

### DOM Element Selector

Write a function for selecting DOM elements with a specific data attribute and applying a given callback function to them.
Для решения этой задачи мы можем создать функцию selectElementsWithAttribute, которая будет принимать имя атрибута и значение этого атрибута, а также функцию обратного вызова (callback). Функция будет находить все элементы с указанным атрибутом и его значением, применять к ним функцию обратного вызова и возвращать их.
Вот пример такой функции на JavaScript:
function selectElementsWithAttribute(attribute, value, callback) {
const elements = document.querySelectorAll(`[${attribute}="${value}"]`); // Находим элементы с указанным атрибутом и значением

```
// Применяем callback к каждому найденному элементу
elements.forEach(element => {
    callback(element);
});
```

}
Теперь вы можете использовать эту функцию для выбора элементов по их атрибуту и значению, а затем применения к ним функции обратного вызова:
// Пример использования:
// Функция обратного вызова для добавления класса
function addClass(element) {
element.classList.add(‘highlight’);
}
// Выбираем все элементы с атрибутом data-type и значением ‘button’ и добавляем им класс ‘highlight’
selectElementsWithAttribute(‘data-type’, ‘button’, addClass);
Этот пример выберет все элементы, у которых атрибут data-type имеет значение ‘button’, и добавит им класс highlight.

### Что такое политика CORS про что она?

CORS (Cross-Origin Resource Sharing) — это механизм, предназначенный для обеспечения безопасности веб-приложений и позволяющий контролировать, как веб-страницы могут запрашивать ресурсы с других доменов, отличных от того, с которого была загружена текущая страница. CORS решает проблему Same-Origin Policy, которая безопасно ограничивает запросы к ресурсам на других доменах.

Политика CORS определяет, какие ресурсы с других доменов могут быть запрошены и загружены в браузере. Она использует HTTP-заголовки для определения разрешенных и недопустимых операций между разными источниками.

Некоторые ключевые заголовки CORS:
Origin: Определяет источник (origin) запроса.
Access-Control-Allow-Origin: Указывает, какие источники имеют право делать запрос на ресурс. Если значение этого заголовка равно “*“, это означает, что любой источник разрешен.
Access-Control-Allow-Methods: Определяет разрешенные методы HTTP для запроса (например, GET, POST).
Access-Control-Allow-Headers: Определяет разрешенные заголовки HTTP.
Access-Control-Allow-Credentials: Указывает, могут ли запросы включать информацию аутентификации (например, куки).
Access-Control-Expose-Headers: Указывает, какие заголовки могут быть доступны в ответе.

CORS предотвращает атаки, такие как Cross-Site Request Forgery (CSRF), обеспечивая контроль того, какой код на странице имеет доступ к ресурсам на других доменах.

### Если нужно хранить коллецию данных что использовать в зависимости от того какие это данные

В JavaScript существует несколько структур данных, которые могут использоваться для хранения коллекций данных в зависимости от особенностей этих данных и требований к их обработке. Вот несколько наиболее часто используемых структур данных:
Массивы (Array):
Используются для хранения упорядоченных коллекций элементов.
Обеспечивают быстрый доступ к элементам по индексу.
Хорошо подходят, когда порядок элементов важен.
Объекты (Object):
Используются для хранения неупорядоченных коллекций пар ключ-значение.
Позволяют быстро получать доступ к значениям по ключу.
Подходят для представления ассоциативных данных.
Map:
Предоставляет коллекцию пар ключ-значение, где ключи могут быть любого типа данных.
Поддерживает итерацию в порядке вставки.
Обеспечивает более гибкие возможности для определения ключей.
Set:
Предоставляет уникальные значения без дубликатов.
Обеспечивает быстрый поиск элементов.
Подходит, если нужно хранить только уникальные значения.

### Что такое виртуальный DOM в React

- Modules in JavaScript

Модули в JavaScript необходимы для организации кода, улучшения его читаемости, повторного использования и поддержки. Модули позволяют разбивать большой код на более мелкие, управляемые части, каждая из которых решает конкретную задачу. Это упрощает тестирование и поддержку кода, а также способствует лучшему управлению зависимостями.

### Purpose and concept of a module/module pattern.

Модуль — это автономная часть кода, которая инкапсулирует функциональность и может быть повторно использована в различных частях приложения или даже в различных проектах.
Основные концепции модулей:
-Инкапсуляция:
Модули инкапсулируют детали реализации, предоставляя только необходимую часть кода через публичный API.
Это предотвращает доступ внешнего кода к внутреннему состоянию и изменению его, что повышает безопасность и устойчивость кода.
-Повторное использование:
Модули позволяют повторно использовать код, давая возможность писать функции и переменные один раз и использовать их в различных проектах.
Это уменьшает дублирование и способствует соблюдению принципов DRY (Don’t Repeat Yourself — не повторяй себя).
-Поддерживаемость:
Модульный код легче поддерживать и обновлять, поскольку изменения в одном модуле не влияют напрямую на другие.
Тестирование и отладка также упрощаются, так как каждый модуль можно разрабатывать и тестировать отдельно.
-Управление зависимостями:
Модули явно объявляют свои зависимости, что облегчает их управление и отслеживание.
Это помогает понимать взаимосвязи между различными частями кода и решать проблемы, связанные с конфликтами зависимостей.

### Types of modules (AMD, ES6, CommonJS, UMD).

AMD: Лучший выбор для браузерных сред с асинхронной загрузкой. Полезен для оптимизации времени загрузки страницы, но имеет более сложный синтаксис.
CommonJS: Идеально подходит для серверных приложений, особенно с Node.js. Синхронная загрузка делает его неподходящим для браузеров.
ES6 Модули: Современные и универсальные, с поддержкой на уровне языка в браузерах и Node.js. Требует транспиляции для работы в старых средах.
UMD: Высоко универсальный и совместимый с AMD и CommonJS. Полезен для написания модулей, которые должны работать в различных средах, но с более сложной настройкой.

### AMD Asynchronous module definition

AMD — это спецификация для определения модулей, особенно подходящая для браузеров. Она загружает модули асинхронно, что полезно для улучшения производительности веб-приложений за счет загрузки только необходимых модулей по мере их необходимости.
Преимущества:
Асинхронная загрузка: Модули загружаются асинхронно, что может улучшить время загрузки страницы.
Управление зависимостями: Зависимости явно объявляются, что делает очевидным, от каких модулей зависит каждый модуль.
Недостатки:
Сложный синтаксис: Синтаксис может быть более сложным и менее интуитивно понятным по сравнению с другими системами модулей.
Основное использование в браузерах: Реже используется в серверных средах.

define([‘dependency1’, ‘dependency2’], function(dep1, dep2) {
// код модуля
return {
// экспортируемые значения
};
});

Пример:
// math.js
define([], function() {
return {
add: function(a, b) {
return a + b;
},
subtract: function(a, b) {
return a - b;
}
};
});

// app.js
require([‘./math’], function(math) {
console.log(math.add(2, 3)); // 5
console.log(math.subtract(5, 2)); // 3
});

### ES6

ES6 Модули (также известные как ECMAScript модули) — это стандартизированная система модулей, введенная в ECMAScript 2015 (ES6). Они предназначены для работы как в браузерах, так и в серверных средах.
Преимущества:
Поддержка на уровне языка: Поддерживается на уровне языка в современных браузерах и Node.js (без необходимости в дополнительных библиотеках или инструментах).
Статический анализ: Позволяет лучше анализировать код, что упрощает оптимизацию и управление зависимостями.
импорт возвращает промис, не блокирует выполнение кода.
Недостатки:
Совместимость: Требует транспиляции (процесс преобразования исходного кода из одного языка программирования в другой) (например, с помощью Babel) для работы в старых браузерах, которые не поддерживают ES6 модули.

// Экспорт
export default myFunction;
export { myFunction1, myFunction2 };
// Импорт
import myFunction, { myFunction1, myFunction2 } from ‘./module.js’;

Пример:
// math.js
export function add(a, b) {
return a + b;
}

export function subtract(a, b) {
return a - b;
}

// app.js
import { add, subtract } from ‘./math.js’;
console.log(add(2, 3)); // 5
console.log(subtract(5, 2)); // 3

### CommonJS

CommonJS — это стандарт модулей, предназначенный в первую очередь для серверных приложений. Это формат модулей, используемый в Node.js. Модули загружаются синхронно, что хорошо работает в серверных средах, где файлы обычно загружаются из локальной файловой системы.
Преимущества:
Простота: Синтаксис простой и легко понятный.
Синхронная загрузка: Работает хорошо в средах, где допустима синхронная загрузка (например, серверные приложения).
Недостатки:
Синхронная загрузка: Не подходит для браузеров из-за блокирующего поведения при загрузке модулей.
Ограничено серверной стороной: В основном используется в Node.js, менее подходит для клиентских приложений
Требуется транспиляция

// Экспорт
module.exports = myFunction;
exports.myFunction1 = myFunction1;
exports.myFunction2 = myFunction2;

// Импорт
const myFunction = require(‘./module.js’);
const { myFunction1, myFunction2 } = require(‘./module.js’);
.
Пример:
// math.js
function add(a, b) {
return a + b;
}
function subtract(a, b) {
return a - b;
}
module.exports = { add, subtract };
// app.js
const math = require(‘./math’);
console.log(math.add(2, 3)); // 5
console.log(math.subtract(5, 2)); // 3

### UMD Universal Module Definition

UMD — это формат модулей, предназначенный для совместимости как с AMD, так и с CommonJS средами. Он может использоваться как на клиентской, так и на серверной стороне, что делает его универсальным.
Преимущества UMD:
Универсальность: UMD (Universal Module Definition) позволяет создавать модули, которые могут быть использованы как в среде клиентского JavaScript (браузеры), так и в среде серверного JavaScript (Node.js), что делает его универсальным и применимым для различных проектов.
Совместимость: UMD формат устраняет разрыв между AMD и CommonJS стилями модулей. Это позволяет создавать модули, которые могут быть использованы в различных средах без изменений, облегчая написание и использование кода в различных проектах.
Недостатки UMD:
Сложность: UMD может быть более сложным в использовании и понимании по сравнению с другими форматами модулей, такими как AMD или CommonJS. Синтаксис и шаблонный код UMD могут быть более громоздкими из-за необходимости поддерживать совместимость с различными средами выполнения JavaScript.
Таким образом, UMD обеспечивает универсальность и совместимость модулей, но может иметь некоторые сложности в использовании и понимании из-за его универсальной природы.

(function (root, factory) {
if (typeof define === ‘function’ && define.amd) { // define.amd - это проверка на наличие среды AMD
// AMD
define(factory);
} else if (typeof module === ‘object’ && module.exports) {
// CommonJS
module.exports = factory();
} else {
// Глобальные переменные браузера
root.myModule = factory();
}
}(this, function () {
// Код модуля здесь
var myFunction = function() {
console.log(‘Hello, UMD!’);
};
return {
myFunction: myFunction
};
}));

Пример:
(function (root, factory) {
if (typeof define === ‘function’ && define.amd) {
// AMD
define([], factory);
} else if (typeof module === ‘object’ && module.exports) {
// Node.js/CommonJS
module.exports = factory();
} else {
// Глобальная переменная браузера
root.myModule = factory();
}
}(this, function () {
return {
add: function(a, b) {
return a + b;
},
subtract: function(a, b) {
return a - b;
}
};
}));

// Использование в разных средах
// AMD
require([‘myModule’], function(myModule) {
console.log(myModule.add(2, 3)); // 5
});

// CommonJS
const myModule = require(‘./myModule’);
console.log(myModule.add(2, 3)); // 5
// Глобальная переменная браузера
console.log(myModule.add(2, 3)); // 5

### Что такое Babel?

**Babel** — это инструмент для преобразования современного JavaScript-кода в код, совместимый с более старыми браузерами и средами выполнения.

### Для чего нужен Babel?

1. **Совместимость**: Преобразует код ES6+ в ES5 для поддержки старых браузеров.
2. **Новые возможности**: Позволяет использовать новейшие функции JavaScript, такие как async/await.
3. **JSX и TypeScript**: Преобразует JSX (для React) и TypeScript в стандартный JavaScript.

### Где используется Babel?

- **Веб-разработка**: В сборщиках модулей (например, Webpack).
- **React-приложения**: Для трансформации JSX в JavaScript.
- **Node.js**: Для использования современных возможностей JavaScript в серверном коде.

### Syntax and common features (export default, named exports, exports as).

### Экспорт в JavaScript в ES6:

JavaScript поддерживает несколько способов экспортирования функций, переменных или объектов из модулей для их использования в других модулях.

1. export default:
export default используется для экспорта единственного значения (может быть функцией, классом, объектом или примитивом) из модуля. Это значение будет считаться “основным” или “по умолчанию” при импорте в другие модули.
Пример
// module.js
const myFunc = () => { … };
export default myFunc;
// другой модуль
import myFunc from ‘./module.js’;
2. Именованный экспорт (named exports):
Именованный экспорт позволяет экспортировать несколько значений из модуля, каждый из которых может иметь свое собственное имя. Для этого используется ключевое слово export.
Пример:
// module.js
export const foo = ‘foo’;
export const bar = ‘bar’;
// другой модуль
import { foo, bar } from ‘./module.js’;
3. Экспорт под псевдонимом (export as):
Этот синтаксис позволяет экспортировать значения под другим именем, чем оно было определено в модуле. Это может быть полезно, когда необходимо изменить имя при экспорте для избежания конфликтов с уже существующими именами в других модулях.
Пример:
// module.js
const internalName = ‘internal’;
export { internalName as externalName };
// другой модуль
import { externalName } from ‘./module.js’;

### Сравнение CommonJS и ES6

Экспорт по умолчанию:
CommonJS: module.exports = value;
ES6: export default value;

Именованный экспорт:
CommonJS: exports.name = value;
ES6: export const name = value;

Экспорт под псевдонимом:
CommonJS: exports.alias = value;
ES6: export { value as alias };

### Сравнение ES6 и AMD

- Экспорт по умолчанию:
ES6:
// module.js
const myFunc = () => { /* реализация */ };
export default myFunc;
// другой модуль
import myFunc from ‘./module.js’;
AMD:
// module.js
define(function() {
const myFunc = () => { /* реализация */ };
return myFunc;
});
// другой модуль
require([‘module’], function(myFunc) {
myFunc();
});
- Именованный экспорт:
ES6:
// module.js
export const foo = ‘foo’;
export const bar = ‘bar’;
// другой модуль
import { foo, bar } from ‘./module.js’;
AMD:
// module.js
define(function() {
const foo = ‘foo’;
const bar = ‘bar’;
return {
foo: foo,
bar: bar
};
});
// другой модуль
require([‘module’], function(module) {
const foo = module.foo;
const bar = module.bar;
});
- Экспорт под псевдонимом:
ES6:
// module.js
const internalName = ‘internal’;
export { internalName as externalName };
// другой модуль
import { externalName } from ‘./module.js’;
AMD:
В AMD, чтобы экспортировать значения под псевдонимом, нужно явно указать имена свойств объекта, возвращаемого из модуля.
// module.js
define(function() {
const internalName = ‘internal’;
return {
externalName: internalName
};
});
// другой модуль
require([‘module’], function(module) {
const externalName = module.externalName;
});

### Dynamic imports

Dynamic imports позволяют загружать модули асинхронно, что особенно полезно для веб-приложений, где время загрузки и производительность имеют критическое значение. В различных системах модулей подходы к динамическому импорту различаются.

Динамический импорт в ES6 (import()) полезен для ситуаций, когда вам нужно динамически загружать модули во время выполнения программы, когда точно известно, что модуль необходим в определенный момент или при определенных условиях.

1. ES6 (ECMAScript 2015 Modules)
В ES6 динамические импорты реализуются с помощью функции import(), которая возвращает промис. Это позволяет загружать модули по требованию и обрабатывать их асинхронно.
Пример:
// Динамический импорт
import(‘./module.js’).then(module => {
module.myFunction();
}).catch(err => {
console.error(‘Ошибка загрузки модуля’, err);
});
2. AMD (Asynchronous Module Definition)
В AMD динамические импорты поддерживаются “из коробки”, так как AMD была разработана для асинхронной загрузки модулей с самого начала. Для этого используется функция require.

Пример:
// Динамический импорт
require([‘module’], function(module) {
module.myFunction();
});

1. CommonJS
CommonJS, изначально разработанная для Node.js, не поддерживает асинхронную загрузку модулей изначально. Однако, можно использовать другие асинхронные механизмы, доступные в Node.js, такие как колбэки, промисы или асинхронные функции. Также возможно использование некоторых инструментов сборки, таких как Webpack, для реализации динамической загрузки модулей.
Можно создать обходной путь для динамической загрузки модулей, используя асинхронные функции и промисы.

Пример с использованием промисов:
const fs = require(‘fs’);
const path = require(‘path’);
// Функция для асинхронной загрузки модуля
function asyncRequire(modulePath) {
return new Promise((resolve, reject) => {
fs.readFile(modulePath, ‘utf8’, (err, data) => {
if (err) {
return reject(err);
}
try {
const moduleExports = {};
const moduleFunction = new Function(‘exports’, ‘require’, ‘module’, ’__filename’, ’__dirname’, data);
moduleFunction(moduleExports, require, { exports: moduleExports }, modulePath, path.dirname(modulePath));
resolve(moduleExports);
} catch (error) {
reject(error);
}
});
});
}
// Использование асинхронного require
asyncRequire(path.join(__dirname, ‘module.js’))
.then((module) => {
module.myFunction();
})
.catch((error) => {
console.error(‘Ошибка загрузки модуля:’, error);
});

1. UMD (Universal Module Definition)
UMD не имеет встроенной поддержки для динамических импортов, так как UMD является оберткой для совместимости с различными системами модулей. Тем не менее, UMD модули могут использовать динамические импорты, предоставленные конкретной системой модулей, в которой они выполняются (например, AMD или ES6).

Пример с ES6 динамическим импортом:
// Используем ES6 динамический импорт
import(‘./module.js’).then(module => {
module.myFunction();
}).catch(err => {
console.error(‘Ошибка загрузки модуля’, err);
});

Пример с AMD динамическим импортом:
// Используем AMD динамический импорт
require([‘module’], function(module) {
module.myFunction();
});

Основные отличия:
ES6 в июне 2015 года:
Использует функцию import().
Возвращает промис.
Поддерживается в современных браузерах и Node.js (начиная с версии 13.2.0).

AMD в 2009 году:
Использует функцию require.
Поддерживает асинхронную загрузку изначально.
Требует библиотеку, такую как RequireJS, для работы в браузере.

CommonJS в начале 2010-х годов:
Изначально не поддерживает асинхронную загрузку.
Можно использовать import() в Node.js или асинхронные механизмы в сборщиках, таких как Webpack (require.ensure).

UMD с середины 2010 годов:
Нет встроенной поддержки для динамических импортов.
Может использовать динамические импорты, предоставляемые конкретной системой модулей (например, ES6 или AMD).

### Functional Patterns

Функциональные паттерны (Functional Patterns) в JavaScript относятся к применению принципов функционального программирования (Functional Programming) для написания чистого, модульного и легко тестируемого кода. Функциональное программирование фокусируется на использовании функций как основных строительных блоков и избегании изменения состояния и побочных эффектов.

- Чистые функции (Pure Functions):
Функции всегда возвращают одинаковый результат для одинаковых входных данных, что делает их предсказуемыми и легкими в тестировании.
Они не имеют побочных эффектов, таких как изменение внешних переменных или состояний, что способствует лучшей изоляции кода и уменьшает вероятность ошибок.
- Иммутабельность (Immutability):
Данные неизменны после создания, что означает, что они не могут быть изменены напрямую. Вместо этого создаются новые данные на основе существующих.
Это обеспечивает безопасность данных и предотвращает неожиданные изменения.
- Функции высшего порядка (Higher-Order Functions):
Функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата.
Это позволяет создавать более абстрактные и универсальные функции, что способствует повторному использованию кода и упрощает его структуру.
- Функциональные композиции (Function Composition):
Комбинирование простых функций для создания более сложных.
Это позволяет создавать более чистый и модульный код, разбивая его на небольшие, повторно используемые функции, и затем комбинируя их для решения более сложных задач.

Основные функциональные паттерны в JavaScript:

1. Чистые функции (Pure Functions):
Пример:
// Чистая функция
function add(a, b) {
return a + b;
// Императивный код с побочными эффектами
let total = 0;
function addToTotal(amount) {
total += amount;
}
2. Функции высшего порядка (Higher-Order Functions):
Пример:
// Функция высшего порядка, которая принимает другую функцию в качестве аргумента
function applyOperation(a, b, operation) {
return operation(a, b);
}
const sum = (a, b) => a + b;
const product = (a, b) => a * b;
console.log(applyOperation(2, 3, sum)); // 5
console.log(applyOperation(2, 3, product)); // 6
3. Функциональная композиция (Function Composition):
Пример:
const compose = (f, g) => (x) => f(g(x));
const add1 = (x) => x + 1;
const multiply2 = (x) => x * 2;
const add1ThenMultiply2 = compose(multiply2, add1);
console.log(add1ThenMultiply2(5)); // 12 (5 + 1 = 6, 6 * 2 = 12)
4. Каррирование (Currying):
Каррирование — это процесс преобразования функции, принимающей несколько аргументов, в последовательность функций, каждая из которых принимает один аргумент.
Пример:
function curry(fn) {
return function curried(…args) {
if (args.length >= fn.length) {
return fn(…args);
} else {
return function(…nextArgs) {
return curried(…args, …nextArgs);
}
}
}
}
Функция curry принимает функцию fn в качестве аргумента. Она возвращает новую функцию curried.
Функция curried принимает любое количество аргументов при вызове с помощью оператора …args.
Внутри функции curried проверяется количество переданных аргументов (args.length) с ожидаемым количеством аргументов у функции fn (fn.length).
Если количество переданных аргументов достаточно для вызова функции fn, то вызывается fn с этими аргументами (fn(…args)), и результат возвращается.
Если количество аргументов недостаточно, создается новая функция, ожидающая оставшиеся аргументы. Она возвращает curried с текущими аргументами и ожидаемыми оставшимися аргументами.
После создания такой функции она может быть вызвана с оставшимися аргументами, и процесс будет повторен, пока не будет накоплено достаточное количество аргументов для вызова fn.

const add = (a, b, c) => a + b + c;
const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6

1. Рекурсия (Recursion):
Использование функций для вызова самих себя вместо использования циклов.
Пример:
function factorial(n) {
if (n === 0) {
return 1;
}
return n * factorial(n - 1);
}
console.log(factorial(5)); // 120
2. Обработка коллекций (Collection Processing):
Использование методов массивов, таких как map, filter и reduce, для обработки данных.
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
console.log(doubled); // [2, 4, 6, 8, 10]
const even = numbers.filter(n => n % 2 === 0);
console.log(even); // [2, 4]
const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum); // 15

Преимущества функционального программирования:
Простота тестирования: Чистые функции легче тестировать, поскольку они не зависят от внешнего состояния.
Модульность и переиспользуемость: Функции высшего порядка и композиции делают код более модульным и переиспользуемым.
Прозрачность и предсказуемость: Код становится более прозрачным и предсказуемым благодаря отсутствию побочных эффектов и изменяемого состояния.
Упрощенное параллельное программирование: Иммутабельность данных облегчает параллельное выполнение кода, так как отсутствуют конфликты при изменении состояния.
Функциональные паттерны помогают писать более чистый, понятный и поддерживаемый код, что особенно важно в крупных проектах.

### Callbacks and IIFE

Callbacks — это функции, которые передаются в другие функции как аргументы и вызываются (или “обратно вызываются”) после завершения определенного действия или операции. В JavaScript они часто используются для асинхронных операций, таких как сетевые запросы, чтение файлов и таймеры.
Пример:
Асинхронный коллбек:
function fetchData(url, callback) {
setTimeout(() => {
const data = { name: ‘John Doe’ }; // Имитация данных
callback(data);
}, 1000);
}
function processData(data) {
console.log(‘Data received:’, data);
}
fetchData(‘https://example.com’, processData);
// Через 1 секунду в консоли будет: Data received: { name: ‘John Doe’ }

Синхронный коллбек:
function greet(name, callback) {
const message = `Hello, ${name}!`;
callback(message);
}
function displayMessage(message) {
console.log(message);
}
greet(‘Alice’, displayMessage);
// В консоли будет: Hello, Alice!

### IIFE (Immediately Invoked Function Expression) немедленно вызываемое функциональное выражение

IIFE — это функция, которая определена и вызвана немедленно. IIFE часто используются для создания локальной области видимости, чтобы избежать загрязнения глобальной области видимости.
Пример:
(function() {
const message = ‘Hello, World!’;
console.log(message);
})();
// В консоли будет: Hello, World!

Другой пример с передачей аргументов в IIFE:
(function(name) {
const message = `Hello, ${name}!`;
console.log(message);
})(‘Alice’);
// В консоли будет: Hello, Alice!

Зачем нужно
Callbacks:
Асинхронность: Callbacks позволяют выполнять код асинхронно, что важно для работы с сетевыми запросами, файловыми операциями и другими длительными задачами.
Гибкость: Callbacks позволяют передавать различные функции для обработки результатов, что делает код более гибким и модульным.
IIFE:
Изоляция кода: IIFE изолируют код, предотвращая загрязнение глобальной области видимости и конфликтов имен.
Инициализация: IIFE часто используются для инициализации переменных и выполнения кода, который нужно выполнить сразу при загрузке скрипта.

### Limitations of callbacks (e.g., callback hell).

Ограничения и проблемы коллбеков

- Callback Hell (Ад коллбеков):
Описание: Ад коллбеков возникает, когда несколько асинхронных операций вкладываются друг в друга, образуя глубокую иерархию вложенных функций. Это делает код трудным для чтения и понимания.
Пример:
doSomething(function(result) {
doSomethingElse(result, function(newResult) {
doThirdThing(newResult, function(finalResult) {
console.log(finalResult);
});
});
});
- Сложность отладки:
Описание: Глубокая вложенность коллбеков затрудняет отладку. Стек вызовов становится менее очевидным, и трассировка ошибок может быть сложной задачей.
Пример: Ошибки в глубоко вложенных коллбеках могут быть трудно выявляемыми из-за потери контекста.
- Сложность управления ошибками:
Описание: В коллбеках необходимо явно обрабатывать ошибки в каждой функции, что увеличивает сложность кода.
Пример:
doSomething(function(err, result) {
if (err) {
handleError(err);
} else {
doSomethingElse(result, function(err, newResult) {
if (err) {
handleError(err);
} else {
doThirdThing(newResult, function(err, finalResult) {
if (err) {
handleError(err);
} else {
console.log(finalResult);
}
});
}
});
}
});
- Проблемы с масштабируемостью и переиспользованием кода:
Описание: Коллбеки затрудняют разделение кода на небольшие, переиспользуемые модули. Глубоко вложенные функции трудно масштабировать и поддерживать.
Пример: Повторное использование кода становится трудным, когда каждая функция зависит от внутреннего состояния и результатов предыдущих вызовов.
- Неявная передача контекста:
Описание: Контекст this внутри коллбеков может быть потерян или изменен, что требует дополнительных усилий для его сохранения.
Пример:
function Timer() {
this.seconds = 0;
setInterval(function() {
this.seconds++;
console.log(this.seconds);
}, 1000);
}
const timer = new Timer();
// ‘this.seconds’ будет undefined, потому что контекст ‘this’ потерян
В данном примере контекст this внутри функции, переданной в setInterval, не будет указывать на объект Timer, а будет определяться контекстом выполнения этой функции, что в данном случае будет глобальный объект (в браузере - window), либо будет undefined в строгом режиме. Поэтому при обращении к this.seconds внутри колбэка, свойство seconds не будет найдено, и вернется undefined.

Для того чтобы исправить это, можно использовать стрелочную функцию, которая не создает свой собственный контекст this, а использует контекст родительской функции. Вот исправленный пример:
function Timer() {
this.seconds = 0;
setInterval(() => {
this.seconds++;
console.log(this.seconds);
}, 1000);
}
const timer = new Timer();

Пример с обычной функцией
function createTimer() {
let seconds = 0;
setInterval(() => {
seconds++;
console.log(seconds);
}, 1000);
return {
getSeconds: () => seconds
};
}
const timer = createTimer();
В этом примере мы создаем функцию createTimer, которая возвращает объект с методом getSeconds. Контекст this здесь не используется, так как все переменные находятся в замыкании функции createTimer.

Пример с использованием объекта
Вы также можете создать объект с методом, который будет запускать таймер:
const timer = {
seconds: 0,
start: function() {
setInterval(() => {
this.seconds++;
console.log(this.seconds);
}, 1000);
}
};
timer.start();

Способы решения проблем с коллбеками
-Промисы (Promises):
Описание: Промисы предоставляют более понятный и управляемый способ работы с асинхронными операциями, избегая вложенности коллбеков.
Пример:
doSomething()
.then(result => doSomethingElse(result))
.then(newResult => doThirdThing(newResult))
.then(finalResult => console.log(finalResult))
.catch(err => handleError(err));

- Async/Await:
Описание: Синтаксис async/await делает асинхронный код более читаемым и похожим на синхронный код, что упрощает его понимание и отладку.
Пример:
async function main() {
try {
const result = await doSomething();
const newResult = await doSomethingElse(result);
const finalResult = await doThirdThing(newResult);
console.log(finalResult);
} catch (err) {
handleError(err);
}
}
main();
- Модули и функции высшего порядка:
Описание: Разделение кода на модули и использование функций высшего порядка помогают улучшить структуру и переиспользуемость кода.
Пример:

```jsx
function doSomething() {
    return new Promise((resolve, reject) => {
        // Асинхронная операция    });}
function doSomethingElse(result) {
    return new Promise((resolve, reject) => {
        // Асинхронная операция    });}
function doThirdThing(newResult) {
    return new Promise((resolve, reject) => {
        // Асинхронная операция    });}
async function main() {
    try {
        const result = await doSomething();        const newResult = await doSomethingElse(result);        const finalResult = await doThirdThing(newResult);        console.log(finalResult);    } catch (err) {
        handleError(err);    }
}
main();
```

Callbacks являются важной частью JavaScript, особенно для работы с асинхронными операциями. Однако их использование может привести к трудночитаемому и сложному для отладки коду. Промисы и async/await предлагают более удобные и управляемые альтернативы для работы с асинхронностью, решая основные проблемы коллбеков, такие как ад коллбеков, сложность отладки и управления ошибками.

### Function currying and partial functions

Функциональное каррирование (Function currying) и частичное применение функций (Partial functions) - это два концепта функционального программирования, которые позволяют создавать новые функции на основе существующих с учетом определенных условий

### Функциональное каррирование (Function currying)

Функциональное каррирование заключается в преобразовании функции с несколькими аргументами в последовательность функций с одним аргументом. Каждая новая функция принимает один аргумент и возвращает функцию, которая принимает следующий аргумент, и так далее, пока не будут переданы все аргументы. Когда все аргументы будут переданы, функция выполнится.

Пример функционального каррирования:

```jsx
// Обычная функция с несколькими аргументамиfunction multiply(a, b, c) {
    return a * b * c;}
// Функция каррированияfunction curry(func) {
    return function curried(...args) {
        if (args.length >= func.length) {
            return func(...args);        } else {
            return function(...nextArgs) {
                return curried(...args, ...nextArgs);            };        }
    };}
const curriedMultiply = curry(multiply);console.log(curriedMultiply(2)(3)(4)); // Выведет: 24
```

### Частичное применение функций (Partial functions)

Частичное применение функций - это процесс создания новой функции на основе существующей функции путем фиксации (зафиксирования) одного или нескольких ее аргументов. Полученная функция будет иметь меньше аргументов, чем исходная функция, и она будет вызываться с недостающими аргументами.

Пример частичного применения функций:

```jsx
// Обычная функция с несколькими аргументамиfunction greet(greeting, name) {
    return `${greeting}, ${name}!`;}
// Функция частичного примененияfunction partial(func, ...fixedArgs) {
    return function(...args) {
        return func(...fixedArgs, ...args);    };}
const greetHello = partial(greet, 'Hello');console.log(greetHello('Alice')); // Выведет: Hello, Alice!
```

### new keyword functionality

Ключевое слово new в JavaScript используется для создания нового экземпляра объекта на основе конструктора функции или класса. Это ключевое слово добавляет новый объект в качестве контекста выполнения для вызова функции-конструктора, что позволяет инициализировать новый объект и возвращать его.

Функциональность ключевого слова new
-Создание нового объекта: Когда используется new, создается новый пустой объект {}.
Установка прототипа: Прототип нового объекта устанавливается на прототип, указанный в свойстве prototype функции-конструктора.
-Вызов функции-конструктора: Функция-конструктор вызывается с новым объектом в качестве контекста (this).
-Возврат объекта: Если функция-конструктор явно не возвращает объект, то будет возвращен созданный объект.

Пример использования new с функциями-конструкторами:

```jsx
// Определение функции-конструктораfunction Person(name, age) {
    this.name = name;    this.age = age;}
// Создание экземпляра объекта с использованием newconst person1 = new Person('Алиса', 30);console.log(person1); // Выведет: Person { name: 'Алиса', age: 30 }// два примера с разницой, один результатfunction Person(name) {
  this.name = name;}
// Функция-конструктор, которая возвращает объектfunction createPerson(name) {
  return new Person(name);}
const person1 = new Person('Alice');console.log(person1); // Person { name: 'Alice' }const person2 = createPerson('Bob');console.log(person2); // Person { name: 'Bob' }
```

### Constructor functions and their properties

В JavaScript конструкторы функций - это специальные функции, которые используются для создания объектов с определенными свойствами и методами. Когда конструктор вызывается с использованием ключевого слова new, он создает новый объект и устанавливает его контекст как this. Затем он инициализирует свойства этого объекта и возвращает его. Рассмотрим подробнее основные аспекты конструкторов функций и их свойств:
#### Создание конструкторов функций
Конструкторы функций могут быть определены как обычные функции. Однако их имя обычно начинается с заглавной буквы, чтобы указать, что они используются в качестве конструкторов.

```jsx
function Person(name, age) {
    this.name = name;    this.age = age;}
```

### Использование конструкторов функций

Конструкторы функций могут быть использованы для создания множества объектов с одинаковой структурой и поведением.

```jsx
const person1 = new Person('Alice', 30);const person2 = new Person('Bob', 25);console.log(person1); // { name: 'Alice', age: 30 }console.log(person2); // { name: 'Bob', age: 25 }
```

### Свойства конструкторов функций

- Свойство prototype:
prototype - это объект, который используется для добавления свойств и методов к объектам, созданным с использованием конструктора функции.
Методы и свойства, добавленные в prototype, становятся доступными для всех экземпляров объекта, созданных с помощью этого конструктора.
-Свойство length: Свойство length объекта-функции содержит количество параметров, ожидаемых функцией.
-Свойство constructor:
constructor - это ссылка на функцию-конструктор, которая была использована для создания объекта.
По умолчанию все объекты в JavaScript имеют свойство constructor, указывающее на функцию-конструктор, которая была использована для их создания.

Пример использования свойств конструкторов функций

```jsx
function Person(name, age) {
    this.name = name;    this.age = age;}
// Добавление метода в prototypePerson.prototype.greet = function() {
    console.log(`Привет, меня зовут ${this.name} и мне ${this.age} лет.`);};const person1 = new Person('Alice', 30);person1.greet(); // Выведет: Привет, меня зовут Alice и мне 30 лет.// Проверка конструктора объектаconsole.log(person1.constructor === Person); // Выведет: true
```

### Преимущества использования конструкторов функций

- Создание множества объектов: Конструкторы функций позволяют создавать множество объектов с одинаковой структурой и поведением.
-Использование наследования: При использовании прототипного наследования, методы и свойства, добавленные в prototype, становятся доступными для всех экземпляров объекта.
-Удобство и понятность: Конструкторы функций делают код более понятным и удобным для сопровождения, так как они обеспечивают логическую структуру и поведение объектов.

### Public, private, and static members in OOP

В JavaScript нет явного поддержания модификаторов доступа, таких как public, private и static, как в других языках программирования, например, в Java или C#. Однако существуют различные способы имитировать такие концепции для организации кода в объектно-ориентированном стиле.

1. Public (публичные) члены
Публичные члены объекта доступны извне и могут быть изменены и использованы внешним кодом.

```jsx
function Person(name) {
    this.name = name; // Публичное свойство}
Person.prototype.greet = function() {
    console.log(`Привет, меня зовут ${this.name}.`);};const person = new Person('Alice');console.log(person.name); // Aliceperson.greet(); // Привет, меня зовут Alice.
```

1. Private (приватные) члены
Приватные члены объекта недоступны извне и могут быть использованы только внутри объекта.

Использование замыкания:

```jsx
function Person(name) {
    let _name = name; // Приватное свойство    this.getName = function() { // Публичный метод для доступа к приватному свойству        return _name;    };}
const person = new Person('Alice');console.log(person._name); // undefined (приватное свойство недоступно)console.log(person.getName()); // Alice
```

Использование WeakMap:

```jsx
const privateData = new WeakMap();function Person(name) {
    privateData.set(this, { name }); // Приватное свойство}
Person.prototype.getName = function() { // Публичный метод для доступа к приватному свойству    return privateData.get(this).name;};const person = new Person('Alice');console.log(person.name); // undefined (приватное свойство недоступно)console.log(person.getName()); // Alice
```

1. Static (статические) члены
Статические члены принадлежат классу, а не экземпляру объекта, и могут быть вызваны непосредственно из класса.

```jsx
function Person(name) {
    this.name = name;}
Person.staticMethod = function() {
    console.log('Это статический метод.');};const person = new Person('Alice');Person.staticMethod(); // Это статический метод.
```

### ECMAScript Classes

ECMAScript Classes - это синтаксический сахар в JavaScript, представленный в стандарте ECMAScript 2015 (ES6), который предоставляет удобный способ для определения классов и создания объектов на основе этих классов. Хотя классы в JavaScript выглядят как классы в других объектно-ориентированных языках, они по-прежнему используют прототипное наследование внутри себя.

Вот основные концепции и возможности ECMAScript Classes:
1. Определение классов
Синтаксис определения классов в ECMAScript Classes выглядит следующим образом:

```jsx
class ClassName {
    constructor(/* аргументы конструктора */) {
        // инициализация объекта    }
    /* методы класса */}
```

1. Конструкторы
Конструктор класса вызывается при создании нового экземпляра класса. Он определяется с помощью метода constructor.

```jsx
class Person {
    constructor(name, age) {
        this.name = name;        this.age = age;    }
}
```

1. Методы класса
Методы класса определяются внутри тела класса и предоставляют функциональность для объектов, созданных на основе этого класса.

```jsx
class Person {
    constructor(name, age) {
        this.name = name;        this.age = age;    }
    greet() {
        console.log(`Привет, меня зовут ${this.name} и мне ${this.age} лет.`);    }
}
```

1. Наследование
Классы в ECMAScript Classes поддерживают наследование с помощью ключевого слова extends. Подклассы могут наследовать методы и свойства суперклассов.

```jsx
class Student extends Person {
    constructor(name, age, grade) {
        super(name, age);        this.grade = grade;    }
    study() {
        console.log(`${this.name} учится в ${this.grade} классе.`);    }
}
```

1. Статические методы
Статические методы принадлежат самому классу, а не его экземплярам, и вызываются непосредственно из класса.

```jsx
class MathUtils {
    static add(a, b) {
        return a + b;    }
}
console.log(MathUtils.add(3, 4)); // 7
```

1. Геттеры и сеттеры
Геттеры и сеттеры позволяют устанавливать и получать значения свойств объекта с помощью специальных методов.

```jsx
class Rectangle {
    constructor(width, height) {
        this._width = width;        this._height = height;    }
    get area() {
        return this._width * this._height;    }
    set width(value) {
        this._width = value;    }
}
const rect = new Rectangle(5, 10);console.log(rect.area); // 50rect.width = 8;console.log(rect.area); // 80
```

Преимущества ECMAScript Classes
-Читаемость и понятность кода: Классы обеспечивают более чистый и понятный синтаксис для определения объектов и их поведения.
-Структурированность кода: Классы помогают организовать код в более логические и удобные блоки, облегчая его сопровождение и разработку.
-Наследование и переиспользование кода: Классы поддерживают наследование, что позволяет создавать иерархии классов и повторно использовать код.
-ECMAScript Classes представляют собой мощный инструмент для объектно-ориентированного программирования в JavaScript, обеспечивая удобный синтаксис для определения классов, наследования и создания объектов.

### Class declaration and syntax

Объявление класса (Class declaration) в JavaScript представляет собой способ определения класса, который предоставляет удобный и читаемый синтаксис для создания объектов и структурного программирования. Вот основные аспекты объявления класса и его синтаксиса:

1. Синтаксис объявления класса

```jsx
class ClassName {
    // тело класса}
```

1. Конструктор класса
Конструктор класса определяется с помощью метода constructor. Он вызывается при создании нового экземпляра класса и используется для инициализации свойств объекта.

```jsx
class Person {
    constructor(name, age) {
        this.name = name;        this.age = age;    }
}
```

1. Методы класса
Методы класса определяются внутри тела класса и предоставляют функциональность для объектов, созданных на основе этого класса.

```jsx
class Person {
    constructor(name, age) {
        this.name = name;        this.age = age;    }
    greet() {
        console.log(`Привет, меня зовут ${this.name} и мне ${this.age} лет.`);    }
}
```

1. Вызов методов класса
Методы класса вызываются на экземплярах класса с использованием точечной нотации.

```jsx
const person = new Person('Alice', 30);person.greet(); // Привет, меня зовут Alice и мне 30 лет.
```

1. Наследование
Классы поддерживают наследование с помощью ключевого слова extends. Подклассы могут наследовать методы и свойства суперклассов.

```jsx
class Student extends Person {
    constructor(name, age, grade) {
        super(name, age);        this.grade = grade;    }
    study() {
        console.log(`${this.name} учится в ${this.grade} классе.`);    }
}
```

1. Статические методы
Статические методы принадлежат самому классу, а не его экземплярам, и вызываются непосредственно из класса.

```jsx
class MathUtils {
    static add(a, b) {
        return a + b;    }
}
console.log(MathUtils.add(3, 4)); // 7
```

### Differences between class declarations and constructor functions

Классы (class declarations) и функции-конструкторы (constructor functions) - это два различных подхода к созданию объектов в JavaScript, хотя оба они используются для определения шаблонов объектов. Давайте рассмотрим основные различия между ними:
1. Синтаксис:

```jsx
Class Declaration:class ClassName {
    constructor(/* аргументы конструктора */) {
        // тело конструктора    }
    // методы класса}
```

Constructor Function:

```jsx
function ConstructorName(/* аргументы конструктора */) {
    // тело конструктора}
ConstructorName.prototype.methodName = function() {
    // тело метода};
```

1. Объекты прототипа:
Class Declaration:
В классах методы определяются непосредственно в теле класса, а не на его прототипе.
Каждый метод класса является методом прототипа.

Constructor Function:
Методы определяются на прототипе функции-конструктора.
Все экземпляры объектов, созданных с помощью функции-конструктора, разделяют общий прототип.

1. Наследование:
Class Declaration:
При использовании объявления класса (class declaration) для наследования от другого класса используется ключевое слово extends. В конструкторе подкласса метод super() используется для вызова конструктора суперкласса.

```jsx
// Суперклассclass Animal {
  constructor(name) {
    this.name = name;  }
  sayHello() {
    console.log('Привет, я ' + this.name);  }
}
// Подкласс, наследующий от Animalclass Cat extends Animal {
  constructor(name, color) {
    super(name); // Вызываем конструктор суперкласса Animal с аргументом name    this.color = color;  }
}
// Создаем экземпляр котаconst myCat = new Cat('Барсик', 'рыжий');myCat.sayHello(); // Вывод: Привет, я Барсик
```

Constructor Function:
При использовании функции-конструктора (constructor function) для наследования, устанавливается прототип на экземпляр суперкласса. В конструкторе подкласса методы call() или apply() используются для вызова конструктора суперкласса.

```jsx
// Суперклассfunction Animal(name) {
  this.name = name;}
Animal.prototype.sayHello = function() {
  console.log('Привет, я ' + this.name);};// Подкласс, наследующий от Animalfunction Cat(name, color) {
  Animal.call(this, name); // Вызываем конструктор суперкласса Animal с текущим значением this и передаем ему аргумент name, только свойство!  this.color = color;}
Cat.prototype = Object.create(Animal.prototype); // Наследование прототипа от родительского класса Animal для дочернего класса Cat . Cat.prototype будет иметь доступ к методам и свойствам, определенным в прототипе класса Animal.Cat.prototype.constructor = Cat; // Восстанавливаем ссылку на конструктор После наследования прототипа, свойство constructor объекта Cat.prototype указывает на конструктор Animal, так как оно было унаследовано от Animal.prototype. Чтобы исправить это, мы устанавливаем constructor обратно на Cat, чтобы он указывал на конструктор класса Cat.// Создаем экземпляр котаconst myCat = new Cat('Барсик', 'рыжий');myCat.sayHello(); // Вывод: Привет, я Барсик
```

1. Статические методы:
Class Declaration:
Методы, объявленные с использованием ключевого слова static, принадлежат самому классу, а не его экземплярам.
Constructor Function:
Статические методы могут быть добавлены к функции-конструктору, но они привязаны к самой функции и не наследуются подклассами.
2. Нотация вызова:
Class Declaration:
Создание нового экземпляра класса с использованием ключевого слова new.
Constructor Function:
Также создается новый экземпляр объекта с использованием ключевого слова new.

Преимущества и недостатки:
Class Declaration:
Преимущества: Более чистый и понятный синтаксис, поддержка наследования через extends, возможность объявления статических методов.
Недостатки: Не поддерживается в IE и некоторых устаревших версиях браузеров.

Constructor Function:
Преимущества: Более широкая совместимость с браузерами, более гибкий в использовании.
Недостатки: Менее читаемый синтаксис, более сложное наследование без использования сторонних библиотек.

### Usage of super()

super() - это ключевое слово в JavaScript, которое используется внутри конструктора подкласса для вызова конструктора суперкласса. Это позволяет передать аргументы родительскому конструктору и выполнить необходимые действия, определенные в нем.
1. Вызов конструктора суперкласса:
Внутри конструктора подкласса мы можем использовать super() для вызова конструктора суперкласса и инициализации его свойств.

```jsx
class Animal {
    constructor(name) {
        this.name = name;    }
}
class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Вызываем конструктор суперкласса        this.breed = breed;    }
}
const dog = new Dog('Бобик', 'Лабрадор');console.log(dog.name); // Бобикconsole.log(dog.breed); // Лабрадор
```

1. Передача аргументов родительскому конструктору:
Мы можем передать аргументы из конструктора подкласса в конструктор суперкласса с помощью super().

```jsx
class Person {
    constructor(name, age) {
        this.name = name;        this.age = age;    }
}
class Student extends Person {
    constructor(name, age, grade) {
        super(name, age); // Передаем аргументы в конструктор суперкласса        this.grade = grade;    }
}
const student = new Student('Alice', 25, 'A');console.log(student.name); // Aliceconsole.log(student.age); // 25console.log(student.grade); // A
```

1. Вызов методов суперкласса:
Помимо вызова конструктора, super() также может использоваться для вызова методов суперкласса из подкласса.

```jsx
class Animal {
    speak() {
        return 'Животное издает звук';    }
}
class Dog extends Animal {
    speak() {
        return super.speak() + ': Гав!';    }
}
const dog = new Dog();console.log(dog.speak()); // Животное издает звук: Гав!
```

Примечания:
super() должен быть вызван до обращения к ключевому слову this в конструкторе подкласса.
Если конструктор суперкласса не принимает аргументов, super() может быть вызван без аргументов.
Внутри методов подкласса super() также может быть использован для вызова методов суперкласса с тем же именем.

### Prototypal Inheritance

Прототипное наследование (Prototypal Inheritance) - это основной механизм наследования в JavaScript. Он отличается от классического наследования, которое присутствует во многих других объектно-ориентированных языках программирования, таких как Java или C++. Вот основные аспекты прототипного наследования:
1. Прототипы:
В JavaScript каждый объект имеет связанный с ним прототип (prototype). Прототип - это ссылка на другой объект, который используется как шаблон для наследования свойств и методов.

Вот основные аспекты прототипного наследования:
1. Прототипы:
В JavaScript каждый объект имеет связанный с ним прототип (prototype). Прототип - это ссылка на другой объект, который используется как шаблон для наследования свойств и методов.

```jsx
const parent = {
    greet() {
        console.log('Привет!');    }
};const child = Object.create(parent); // Создаем объект с прототипом parentchild.greet(); // Привет!
```

1. Свойство **proto**:
У каждого объекта в JavaScript есть свойство **proto**, которое ссылается на его прототип. Это нестандартное свойство, и его использование не рекомендуется в продакшен-коде.

```jsx
const child = {};console.log(child.__proto__); // Object.prototype
```

Рекомендованные альтернативы
Использование Object.create, Object.getPrototypeOf и Object.setPrototypeOf является более предпочтительным и стандартизированным способом работы с прототипами.

Пример с Object.create

```jsx
// Создание объекта-прототипаconst parent = {
  greet() {
    console.log('Привет от родителя');  }
};// Создание объекта с заданным прототипомconst child = Object.create(parent);// Вызов метода, определенного в прототипеchild.greet(); // Привет от родителя
```

Пример с Object.getPrototypeOf и Object.setPrototypeOf

```jsx
// Создание объектаconst child = {};// Создание объекта-прототипаconst parent = {
  greet() {
    console.log('Привет от родителя');  }
};// Установка прототипа объектаObject.setPrototypeOf(child, parent);// Доступ к прототипу объектаconsole.log(Object.getPrototypeOf(child) === parent); // true// Вызов метода, определенного в прототипеchild.greet(); // Привет от родителя
```

Почему **proto** не рекомендуется использовать
Проблемы с производительностью
Совместимость
Плохая поддерживаемость

1. Функции-конструкторы:
Функции-конструкторы являются специальным типом функций, которые используются для создания объектов. При создании объекта с помощью функции-конструктора, прототипом этого объекта становится объект, связанный с прототипом конструктора.

```jsx
function Person(name) {
    this.name = name;}
Person.prototype.greet = function() {
    console.log(`Привет, меня зовут ${this.name}.`);};const person = new Person('Alice');person.greet(); // Привет, меня зовут Alice.
```

1. Наследование:
Прототипное наследование позволяет объектам наследовать свойства и методы от других объектов. Если свойство или метод не найден в объекте, JavaScript автоматически обращается к прототипу.

```jsx
const parent = {
    greet() {
        console.log('Привет!');    }
};const child = Object.create(parent);child.greet(); // Привет!// Метод greet() не найден в объекте child,// поэтому JavaScript ищет его в прототипе parent и успешно находит.
```

1. Object.create():
Метод Object.create() используется для создания нового объекта с заданным прототипом. Он позволяет создавать объекты с явным указанием прототипа.

```jsx
const parent = {
    greet() {
        console.log('Привет!');    }
};const child = Object.create(parent); // Создаем объект с прототипом parentchild.greet(); // Привет!
```

Преимущества прототипного наследования:
Гибкость: Прототипное наследование позволяет объектам наследовать свойства и методы от произвольных объектов, что делает его гибким и мощным механизмом.
Простота: Отсутствие строгой иерархии классов делает прототипное наследование более простым для понимания и использования.
Динамическая природа: Прототипное наследование позволяет динамически изменять прототипы объектов во время выполнения программы, что обеспечивает большую гибкость и возможности.
Хотя прототипное наследование в JavaScript отличается от классического наследования в других языках, его гибкость и мощь делают его одним из ключевых особенностей языка.

### Цепочка прототипов

Если свойство не найдено в самом объекте, JavaScript ищет его в прототипе объекта (объект, на который ссылается **proto** или который установлен с помощью Object.getPrototypeOf). Если свойство не найдено и там, поиск продолжается в прототипе прототипа, и так далее, пока не будет достигнут конец цепочки (обычно это Object.prototype).

```jsx
const grandparent = {
  grandparentProperty: 'Это свойство дедушки',  greet() {
    console.log('Привет от дедушки');  }
};const parent = Object.create(grandparent);parent.parentProperty = 'Это свойство родителя';const child = Object.create(parent);child.childProperty = 'Это свойство ребенка';console.log(child.childProperty); // Это свойство ребенкаconsole.log(child.parentProperty); // Это свойство родителяconsole.log(child.grandparentProperty); // Это свойство дедушкиchild.greet(); // Привет от дедушки
```

Передача null в качестве первого аргумента позволяет создать объект без прототипа, что может быть полезно для создания чистых словарей или мапов без наследования методов и свойств от Object.prototype.
Второй аргумент метода Object.create позволяет задать свойства нового объекта с помощью дескрипторов, как в Object.defineProperties, что дает возможность тонко настраивать свойства нового объекта.

Подробности о втором аргументе
Второй аргумент метода Object.create может быть использован для определения свойств нового объекта с помощью дескрипторов свойств:

```jsx
const newObj = Object.create(proto, {
  property1: {
    value: true,    writable: true,    enumerable: true,    configurable: true  },  property2: {
    value: "Hello",    writable: false,    enumerable: false,    configurable: false  }
});
```

Различия между Object.create и new
Object.create:
Создает новый объект с указанным прототипом.
Может задать свойства с помощью дескрипторов.
Не требует использования функции-конструктора.
new:
Создает экземпляр объекта, вызывая функцию-конструктор.
Прототипом является prototype функции-конструктора.
Не позволяет легко задать свойства с помощью дескрипторов при создании объекта.

Практическое применение
Object.create часто используется в следующих случаях:
Создание объектов с заранее определенным прототипом:
Полезно для создания объектов с одинаковыми методами и свойствами.
Создание объектов без наследования от Object.prototype:
Полезно для создания словарей, где не нужно наследовать методы как toString, hasOwnProperty и т.д.
Сложные объекты с определенными дескрипторами свойств:
Когда требуется гибко настраивать свойства объекта.
Пример создания объекта без прототипа

```jsx
const dictionary = Object.create(null);dictionary.key1 = "value1";console.log(dictionary); // { key1: "value1" }console.log(dictionary.toString); // undefined
```

### ECMAScript Advanced Data Types & Expressions

Map: Коллекция пар ключ-значение, где ключи могут быть любого типа.
Set: Коллекция уникальных значений любого типа.
WeakMap: Коллекция пар ключ-значение, где ключи - объекты с “слабой” ссылкой.
WeakSet: Коллекция уникальных объектов с “слабыми” ссылками.

### Set/Map and WeakSet/WeakMap

### Set

- это структура данных, которая хранит уникальные значения любого типа, будь то примитивы или объекты. Она особенно полезна, когда необходимо работать с коллекцией уникальных элементов.
Создание и основные методы

```jsx
const set = new Set();// Добавление значенийset.add(1);set.add(5);set.add(1); // Игнорируется, так как 1 уже есть в множествеconsole.log(set); // Set { 1, 5 }// Проверка наличия значенияconsole.log(set.has(1)); // trueconsole.log(set.has(3)); // false// Удаление значенийset.delete(5);console.log(set); // Set { 1 }// Получение размера множестваconsole.log(set.size); // 1// Очистка множестваset.clear();console.log(set.size); // 0
```

Итерация
Множество поддерживает различные способы перебора его элементов:

```jsx
const set = new Set([1, 2, 3]);// Использование for...offor (const value of set) {
  console.log(value);}
// Использование forEachset.forEach((value) => {
  console.log(value);});
```

Преобразование
Вы можете легко преобразовать Set в массив и наоборот:

```jsx
const set = new Set([1, 2, 3]);const array = [...set]; // [1, 2, 3]const newSet = new Set(array); // Set { 1, 2, 3 }
```

### Map

Map - это структура данных, которая хранит пары ключ-значение. В отличие от обычных объектов, ключи в Map могут быть любого типа, включая объекты, функции и примитивы.
Создание и основные методы

```jsx
const map = new Map();// Добавление пар ключ-значениеmap.set('name', 'Alice');map.set('age', 25);map.set({ id: 1 }, 'Object as key');// Получение значения по ключуconsole.log(map.get('name')); // 'Alice'console.log(map.get('age')); // 25// Проверка наличия ключаconsole.log(map.has('name')); // trueconsole.log(map.has('gender')); // false// Удаление пары ключ-значениеmap.delete('age');console.log(map.has('age')); // false// Получение размера картыconsole.log(map.size); // 2// Очистка картыmap.clear();console.log(map.size); // 0
```

Итерация
Map поддерживает различные способы перебора его элементов:

```jsx
const map = new Map([
  ['name', 'Alice'],  ['age', 25]
]);// Использование for...offor (const [key, value] of map) {
  console.log(`${key}: ${value}`);}
// Использование forEachmap.forEach((value, key) => {
  console.log(`${key}: ${value}`);});
```

Преобразование
Вы можете преобразовать Map в массив и наоборот:

```jsx
const map = new Map([
  ['name', 'Alice'],  ['age', 25]
]);const array = [...map]; // [['name', 'Alice'], ['age', 25]]const newMap = new Map(array); // Map { 'name' => 'Alice', 'age' => 25 }
```

### WeakSet

WeakSet - это коллекция, которая хранит только объекты и использует “слабые” ссылки на них. Это означает, что если объект, добавленный в WeakSet, больше не доступен из других мест, он может быть удален сборщиком мусора.
Создание и основные методы

```jsx
const weakSet = new WeakSet();const obj1 = { a: 1 };const obj2 = { b: 2 };weakSet.add(obj1);weakSet.add(obj2);console.log(weakSet.has(obj1)); // trueconsole.log(weakSet.has({})); // false ({} - это новый объект, не obj1 и не obj2)weakSet.delete(obj1);console.log(weakSet.has(obj1)); // false
```

Особенности
WeakSet не итерируем, поэтому его нельзя перебрать с помощью for…of или forEach.
Нельзя получить размер WeakSet.

### WeakMap

WeakMap - это коллекция пар ключ-значение, где ключи являются объектами и имеют “слабые” ссылки. Это позволяет сборщику мусора удалять записи, если больше нет ссылок на ключи.
Создание и основные методы

```jsx
const weakMap = new WeakMap();const key1 = {};const key2 = {};weakMap.set(key1, 'value1');weakMap.set(key2, 'value2');console.log(weakMap.get(key1)); // 'value1'console.log(weakMap.has(key1)); // trueweakMap.delete(key1);console.log(weakMap.has(key1)); // false
```

Особенности
Ключи должны быть объектами.
WeakMap не итерируем, поэтому его нельзя перебрать с помощью for…of или forEach.
Нельзя получить размер WeakMap.

Применение на практике
Когда использовать Set/Map
Set: Когда нужно хранить уникальные значения. Примеры: множества уникальных идентификаторов, фильтрация дубликатов.
Map: Когда нужно хранить пары ключ-значение с ключами любого типа. Примеры: кеширование данных, словари конфигураций.

Когда использовать WeakSet/WeakMap
WeakSet: Когда нужно хранить коллекцию объектов и хотите, чтобы сборщик мусора автоматически очищал неиспользуемые объекты. Примеры: отслеживание элементов DOM, чтобы предотвратить утечки памяти.
WeakMap: Когда нужно хранить пары ключ-значение с объектами в качестве ключей и хотите, чтобы сборщик мусора автоматически очищал неиспользуемые ключи. Примеры: ассоциативные массивы для метаданных объектов, кеши с ограниченным временем жизни.

Set, Map, WeakSet и WeakMap являются мощными инструментами для работы с коллекциями данных в JavaScript. Понимание их особенностей и правильное использование помогает создавать более эффективные и надежные приложения.

### JavaScript Errors

Основные типы ошибок
-SyntaxError (Синтаксическая ошибка)
-ReferenceError (Ошибка ссылки)
-TypeError (Ошибка типа)
-RangeError (Ошибка диапазона)
-EvalError (Ошибка eval)
-URIError (Ошибка URI)
-AggregateError (Агрегированная ошибка)

1. SyntaxError
SyntaxError возникает, когда код содержит синтаксическую ошибку и не может быть выполнен.

```jsx
try {
  eval('foo bar'); // Некорректный синтаксис} catch (e) {
  console.log(e instanceof SyntaxError); // true  console.log(e.message); // Сообщение об ошибке}
```

1. ReferenceError
ReferenceError возникает, когда код ссылается на переменную, которая не была объявлена.

```jsx
try {
  console.log(nonExistentVariable); // Переменная не объявлена} catch (e) {
  console.log(e instanceof ReferenceError); // true  console.log(e.message); // Сообщение об ошибке}
```

1. TypeError
TypeError возникает, когда операция выполняется с несовместимыми типами данных.

```jsx
try {
  null.foo(); // Невозможно вызвать метод на null} catch (e) {
  console.log(e instanceof TypeError); // true  console.log(e.message); // Сообщение об ошибке}
```

1. RangeError
RangeError возникает, когда значение не попадает в допустимый диапазон.

```jsx
try {
  new Array(-1); // Невозможно создать массив отрицательного размера} catch (e) {
  console.log(e instanceof RangeError); // true  console.log(e.message); // Сообщение об ошибке}
```

1. EvalError
EvalError возникает при некорректном использовании функции eval(). В современных реализациях JavaScript эта ошибка редко используется.

```jsx
try {
  throw new EvalError('Eval error example');} catch (e) {
  console.log(e instanceof EvalError); // true  console.log(e.message); // Сообщение об ошибке}
```

1. URIError
decodeURI - это встроенная функция в JavaScript, которая декодирует закодированные URI (Uniform Resource Identifier). Она преобразует компоненты URI, которые были закодированы с использованием функции encodeURI или другой функции кодирования URI, обратно в их исходные символы. decodeURI не декодирует символы, которые являются частью синтаксиса URI (например, #, ?, &).
URIError возникает при передаче некорректных параметров в функции encodeURI() или decodeURI().

```jsx
try {
  decodeURI('%'); // Некорректный URI компонент} catch (e) {
  console.log(e instanceof URIError); // true  console.log(e.message); // Сообщение об ошибке}
```

1. AggregateError
AggregateError представляет группу ошибок, обычно возникающих в Promise.any() или других асинхронных операциях.

```jsx
try {
  throw new AggregateError([new Error('Error 1'), new Error('Error 2')], 'Aggregate error example');} catch (e) {
  console.log(e instanceof AggregateError); // true  console.log(e.message); // Сообщение об ошибке  console.log(e.errors); // Массив ошибок}
```

Обработка ошибок
- try…catch…finally
Конструкция try…catch используется для обработки ошибок. Блок finally выполняется всегда, независимо от того, была ли ошибка или нет.

```jsx
try {
  // Код, который может вызвать ошибку  throw new Error('Something went wrong');} catch (e) {
  // Обработка ошибки  console.log(e.message); // Сообщение об ошибке} finally {
  // Этот блок выполняется всегда  console.log('Execution completed');}
```

- throw
Оператор throw позволяет вручную вызывать ошибки.

```jsx
try {
  throw new Error('Custom error');} catch (e) {
  console.log(e.message); // 'Custom error'}
```

- Custom Errors
Вы можете создавать свои собственные классы ошибок для более точной обработки.

```jsx
class CustomError extends Error {
  constructor(message) {
    super(message);    this.name = 'CustomError';  }
}
try {
  throw new CustomError('This is a custom error');} catch (e) {
  console.log(e.name); // 'CustomError'  console.log(e.message); // 'This is a custom error'}
```

- Всплытие ошибок
Ошибки в JavaScript могут всплывать по стеку вызовов. Если ошибка не перехвачена в текущей функции, она передается в вышестоящий контекст.

```jsx
function a() {
  b();}
function b() {
  c();}
function c() {
  throw new Error('Error in function c');}
try {
  a();} catch (e) {
  console.log(e.message); // 'Error in function c'}
```

Работа с асинхронными операциями
Асинхронные операции требуют особого подхода к обработке ошибок.
Обработка ошибок в промисах

```jsx
const promise = new Promise((resolve, reject) => {
  reject(new Error('Promise rejected'));});promise.catch((e) => {
  console.log(e.message); // 'Promise rejected'});
```

Асинхронные функции
Асинхронные функции используют try…catch для обработки ошибок.

```jsx
async function asyncFunction() {
  try {
    await Promise.reject(new Error('Async error'));  } catch (e) {
    console.log(e.message); // 'Async error'  }
}
asyncFunction();
```

### Error handling techniques including try..catch.

Основными техниками являются использование try…catch…finally, создание собственных ошибок и работа с асинхронными операциями.

- try…catch…finally
Конструкция try…catch…finally используется для перехвата и обработки ошибок, которые могут возникнуть в блоке кода.
try: Блок кода, в котором может возникнуть ошибка.
catch: Блок кода, который выполняется, если в блоке try возникает ошибка.
finally: Блок кода, который выполняется независимо от того, возникла ошибка или нет. Используется для выполнения завершающих операций, таких как освобождение ресурсов.
Пример использования

```jsx
try {
  // Блок кода, который может вызвать ошибку  let result = riskyOperation();  console.log(result);} catch (error) {
  // Блок кода для обработки ошибки  console.error('An error occurred:', error.message);} finally {
  // Блок кода, который выполняется всегда  console.log('Operation completed.');}
```

- Глобальная обработка ошибок
JavaScript предоставляет механизмы для глобальной обработки ошибок, которые не были перехвачены на локальном уровне.
Обработчик ошибок в браузере
В браузере можно использовать событие window.onerror для перехвата глобальных ошибок.
window.onerror = function (message, source, lineno, colno, error) {
console.error(‘Global error:’, message);
return true; // Предотвращает вывод ошибки в консоль браузера
};
Обработчик ошибок в Node.js
В Node.js можно использовать событие process.on(‘uncaughtException’) для перехвата глобальных ошибок.
process.on(‘uncaughtException’, (error) => {
console.error(‘Uncaught Exception:’, error.message);
});

### Understanding and implementing custom errors

Создание и использование пользовательских ошибок (Custom Errors) в JavaScript позволяет улучшить обработку исключений, делая их более понятными и специфичными для вашего приложения. Это особенно полезно для крупных приложений, где различные модули могут выбрасывать свои собственные типы ошибок, что облегчает их диагностику и обработку.
Понимание пользовательских ошибок
Пользовательские ошибки позволяют вам создавать собственные типы ошибок, наследуемые от встроенного класса Error. Это позволяет добавлять дополнительные свойства и методы, а также задавать специфичные сообщения об ошибках.
Создание пользовательских ошибок
Чтобы создать пользовательский тип ошибки, создайте новый класс, который наследует от класса Error. Вы можете добавить любые свойства и методы, которые необходимы для вашей ошибки.
Пример создания пользовательской ошибки

```jsx
class ValidationError extends Error {
  constructor(message) {
    super(message); // Вызов конструктора суперкласса Error    this.name = 'ValidationError'; // Установка имени ошибки  }
}
try {
  throw new ValidationError('Invalid input data');} catch (error) {
  console.log(error.name); // 'ValidationError'  console.log(error.message); // 'Invalid input data'  console.log(error.stack); // Стек вызовов}
```

Добавление дополнительных свойств
Вы можете добавить дополнительные свойства в ваш класс ошибок, чтобы передавать больше информации о возникшей ошибке.
Пример пользовательской ошибки с дополнительными свойствами

```jsx
class ValidationError extends Error {
  constructor(message, field) {
    super(message);    this.name = 'ValidationError';    this.field = field; // Дополнительное свойство  }
}
try {
  throw new ValidationError('Invalid input data', 'username');} catch (error) {
  console.log(error.name); // 'ValidationError'  console.log(error.message); // 'Invalid input data'  console.log(error.field); // 'username'  console.log(error.stack); // Стек вызовов}
```

Наследование пользовательских ошибок
Вы можете создавать иерархии пользовательских ошибок, наследуя от ранее созданных классов ошибок. Это позволяет создавать более специфичные ошибки и упрощает их обработку.
Пример наследования пользовательских ошибок

```jsx
class ApplicationError extends Error {
  constructor(message) {
    super(message);    this.name = 'ApplicationError';  }
}
class ValidationError extends ApplicationError {
  constructor(message, field) {
    super(message);    this.name = 'ValidationError';    this.field = field;  }
}
try {
  throw new ValidationError('Invalid input data', 'email');} catch (error) {
  console.log(error.name); // 'ValidationError'  console.log(error.message); // 'Invalid input data'  console.log(error.field); // 'email'  console.log(error instanceof ValidationError); // true  console.log(error instanceof ApplicationError); // true  console.log(error instanceof Error); // true  console.log(error.stack); // Стек вызовов}
```

Обработка пользовательских ошибок
Создание пользовательских ошибок полезно только в том случае, если вы правильно их обрабатываете. Вы можете использовать конструкцию try…catch для перехвата и обработки различных типов ошибок по-разному.
Пример обработки пользовательских ошибок

```jsx
class ApplicationError extends Error {
  constructor(message) {
    super(message);    this.name = 'ApplicationError';  }
}
class ValidationError extends ApplicationError {
  constructor(message, field) {
    super(message);    this.name = 'ValidationError';    this.field = field;  }
}
function validateUser(user) {
  if (!user.username) {
    throw new ValidationError('Username is required', 'username');  }
  if (!user.email) {
    throw new ValidationError('Email is required', 'email');  }
}
try {
  validateUser({ username: 'John' }); // Отсутствует email} catch (error) {
  if (error instanceof ValidationError) {
    console.error(`Validation error on field: ${error.field} - ${error.message}`);  } else if (error instanceof ApplicationError) {
    console.error(`Application error: ${error.message}`);  } else {
    console.error(`Unexpected error: ${error.message}`);  }
}
```

Логирование и уведомления
Вы также можете использовать пользовательские ошибки для улучшения логирования и уведомлений в вашем приложении. Например, вы можете логировать ошибки с дополнительными данными или отправлять уведомления при возникновении критических ошибок.
Пример логирования пользовательских ошибок

```jsx
class CriticalError extends Error {
  constructor(message) {
    super(message);    this.name = 'CriticalError';    this.timestamp = new Date();  }
}
function performCriticalOperation() {
  throw new CriticalError('Critical failure');}
try {
  performCriticalOperation();} catch (error) {
  if (error instanceof CriticalError) {
    console.error(`[${error.timestamp}] ${error.name}: ${error.message}`);    // Отправка уведомления о критической ошибке    sendNotification(error);  }
}
function sendNotification(error) {
  // Логика отправки уведомления, например, на email или в систему мониторинга  console.log(`Notification sent for error: ${error.message}`);}
```

ECMAScript Advanced

### Promises, async/await, and the event loop

Promises
Промисы - это объект, представляющий результат асинхронной операции. Промис может находиться в одном из трёх состояний:
-Pending (Ожидание): начальное состояние, операция ещё не завершена.
-Fulfilled (Выполнено): операция успешно завершена, и промис имеет результат.
-Rejected (Отклонено): операция завершена с ошибкой.
Создание промиса
Промис создаётся с помощью конструктора Promise, который принимает функцию с двумя аргументами: resolve и reject.

```jsx
const promise = new Promise((resolve, reject) => {
  // Асинхронная операция  setTimeout(() => {
    const success = true;    if (success) {
      resolve('Operation successful');    } else {
      reject('Operation failed');    }
  }, 1000);});
```

Использование промиса
Промис предоставляет методы then и catch для обработки успешного выполнения и ошибок соответственно.

```jsx
promise
  .then(result => {
    console.log(result); // 'Operation successful'  })
  .catch(error => {
    console.error(error); // 'Operation failed'  });
```

Цепочки промисов
Метод then возвращает новый промис, что позволяет создавать цепочки промисов для выполнения последовательности асинхронных операций.
Цепочка промисов — это последовательное выполнение асинхронных операций с использованием промисов

```jsx
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve(1), 1000);});promise
  .then(result => {
    console.log(result); // 1    return result * 2;  })
  .then(result => {
    console.log(result); // 2    return result * 2;  })
  .then(result => {
    console.log(result); // 4  });
```

### async/await

async и await - это синтаксический сахар над промисами, который делает асинхронный код более читаемым и последовательным.
async функции
Функция, объявленная с ключевым словом async, автоматически возвращает промис. Значение, возвращаемое этой функцией, оборачивается в промис с состоянием fulfilled.
`javascript async function fetchData() {   return 'Data received'; } fetchData().then(data => console.log(data)); // 'Data received'`
await
Ключевое слово await приостанавливает выполнение async функции до тех пор, пока промис не будет выполнен или отклонён. Оно может использоваться только внутри async функции.
`javascript async function fetchData() {   const data = await new Promise((resolve, reject) => {     setTimeout(() => resolve('Data received'), 1000);   });   console.log(data); // 'Data received' } fetchData();`
Обработка ошибок
Ошибки в async функциях обрабатываются с помощью конструкции try…catch.

### Основы `async` и `await`

1. **Функция `async`**:
    - Ключевое слово `async` перед функцией обозначает, что функция возвращает промис.
    - Даже если функция явно возвращает не промис, значение будет автоматически обёрнуто в промис, который перейдет в состояние fulfilled с этим значением.
    
    **Пример:**
    
    ```jsx
    async function fetchData() {
      return 'Data received';
    }
    fetchData().then(data => {
      console.log(data); // 'Data received'
    });
    ```
    
    В этом примере функция `fetchData` возвращает строку `'Data received'`, которая автоматически оборачивается в промис. Поэтому мы можем использовать метод `then` для обработки результата.
    
2. **Ключевое слово `await`**:
    - `await` используется внутри `async` функции для ожидания завершения промиса.
    - Оно делает асинхронный код более последовательным, позволяя писать его так, как если бы он был синхронным.
    - `await` блокирует выполнение кода до тех пор, пока промис не будет исполнен.
    
    **Пример:**
    
    ```jsx
    async function fetchData() {
      const data = await new Promise(resolve => setTimeout(() => resolve('Data received'), 2000));
      return data;
    }
    fetchData().then(data => {
      console.log(data); // 'Data received'
    });
    
    ```
    
    В этом примере `await` ожидает завершения промиса, созданного с помощью `setTimeout`, который возвращает строку `'Data received'` через 2 секунды.
    

### Использование `async` и `await` для обработки ошибок

Ошибки в `async` функциях могут быть обработаны с помощью конструкции `try...catch`, как и в синхронном коде.

**Пример:**

```jsx
async function fetchData() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching data:', error);
  }
}
fetchData().then(data => {
  console.log(data);
});
```

В этом примере `fetchData` получает данные с веб-API. Если возникает ошибка при запросе или преобразовании данных, ошибка обрабатывается в блоке `catch`.

### `async` и `await` с несколькими промисами

Для одновременного выполнения нескольких асинхронных операций можно использовать `Promise.all`, `Promise.allSettled`, или `Promise.race`, а затем обрабатывать результаты с помощью `async`/`await`.

**Пример:**

```jsx
async function fetchAllData() {
  const [data1, data2] = await Promise.all([
    fetch('https://jsonplaceholder.typicode.com/posts/1').then(res => res.json()),
    fetch('https://jsonplaceholder.typicode.com/posts/2').then(res => res.json())
  ]);
  return { data1, data2 };
}

fetchAllData().then(({ data1, data2 }) => {
  console.log('Data 1:', data1);
  console.log('Data 2:', data2);
});
```

В этом примере `Promise.all` позволяет запрашивать два ресурса одновременно, и результат объединяется после завершения обоих запросов.

### `async` и `await` для работы с таймаутами

Вы можете использовать `await` с промисами, которые включают таймаут, чтобы добавить задержки или обработать их асинхронно.

**Пример:**

```jsx
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
sync function executeWithDelay() {
  console.log('Start');
  await delay(2000); // Задержка 2 секунды
  console.log('End');
}
executeWithDelay();
```

В этом примере функция `delay` возвращает промис, который разрешается через указанное количество миллисекунд. `await` позволяет приостановить выполнение `executeWithDelay` до завершения задержки.

- **`async`**: Объявляет функцию как асинхронную, возвращая промис.
- **`await`**: Ожидает завершения промиса и позволяет работать с результатом так, как если бы код был синхронным.

Использование `async` и `await` делает асинхронный код более последовательным и проще в чтении, по сравнению с использованием промисов с методами `.then()` и `.catch()`.

### Event Loop

### **Как работает eventloop (event loop)?**

Event Loop - это механизм, который управляет исполнением кода в JavaScript и обеспечивает асинхронное выполнение операций.
Вот как он работает:
-Выполнение синхронного кода: Когда вы запускаете JavaScript-приложение, сначала выполняется синхронный код по порядку сверху вниз.
-Обработка асинхронных операций: Если встречается асинхронная операция, например, чтение файла или выполнение запроса к серверу, она отправляется в стек вызовов (call stack) и передается браузеру или окружению выполнения (например, Node.js). JavaScript не ожидает завершения этих операций и продолжает выполнение следующего кода.
-Добавление колбэков в очередь событий: Когда асинхронная операция завершается, ее колбэк (callback) помещается в очередь событий (event queue). Это означает, что функция, переданная в качестве колбэка, будет вызвана после того, как все синхронные операции будут завершены.
-Ожидание выполнения: В то время как стек вызовов пуст и нет выполняющегося синхронного кода, интерпретатор JavaScript проверяет очередь событий. Если там есть колбэк, он добавляется в стек вызовов и выполняется.
-Повторение процесса: Этот процесс повторяется снова и снова, пока есть асинхронные операции и колбэки в очереди событий.

Event Loop (цикл событий) - это механизм, который позволяет JavaScript выполнять асинхронные операции. Он отслеживает стек вызовов, очередь задач и другие структуры данных для управления выполнением кода.
Основные концепции Event Loop
Stack (Стек вызовов): стек, содержащий текущие выполняемые функции.
Queue (Очередь задач): очередь, содержащая функции обратного вызова (callbacks), которые должны быть выполнены после завершения текущего стека вызовов.
Event Loop (Цикл событий): бесконечный цикл, который проверяет стек вызовов и очередь задач, выполняя функции из очереди задач, когда стек вызовов пуст.
Пример работы Event Loop

```jsx
console.log('Start'); // 1setTimeout(() => {
  console.log('Timeout'); // 4}, 0);Promise.resolve()
  .then(() => {
    console.log('Promise'); // 3  });console.log('End'); // 2
```

Сначала выполняется console.log(‘Start’).
Функция setTimeout ставит функцию в очередь задач.
Промис ставит функцию в очередь микрозадач.
Выполняется console.log(‘End’).
Event Loop выполняет задачи из очереди микрозадач (Promise).
Event Loop выполняет задачи из очереди задач (Timeout).

Очереди задач и микрозадач
В JavaScript есть две основные очереди: очередь задач (macrotask queue) и очередь микрозадач (microtask queue). Микрозадачи выполняются перед макрозадачами.
Микрозадачи: промисы, process.nextTick (в Node.js).
Макрозадачи: setTimeout, setInterval, setImmediate (в Node.js), I/O операции.
Пример с микрозадачами и макрозадачами

Микрозадачи: 

- **Обработчики промисов**:
    - Вызовы `.then()`, `.catch()`, `.finally()` на промисах.
- **Метод `queueMicrotask`**:
    - Явный вызов метода `queueMicrotask`, который добавляет функцию в очередь микрозадач.
- **MutationObserver**:
    - Колбэки, привязанные к `MutationObserver`, который отслеживает изменения в DOM.

Макрозадачи: 

- **setTimeout**:
    - Таймер, который выполняет задачу через заданное время.
- **setInterval**:
    - Таймер, который выполняет задачу с заданным интервалом.
- **setImmediate** (в среде Node.js):
    - Вызов функции, который будет выполнен сразу после текущего оборота цикла событий.
- **I/O задачи**:
    - Обработчики событий ввода-вывода, такие как сетевые запросы и операции с файлами.
- **Обработчики событий**:
    - Колбэки, связанные с пользовательскими событиями (например, клики, ввод данных, события клавиатуры).
- **MessageChannel**:
    - Сообщения, переданные через `MessageChannel`.

Пример с микрозадачами и макрозадачами

```jsx
console.log('Start'); // 1setTimeout(() => {
  console.log('setTimeout'); // 5}, 0);Promise.resolve()
  .then(() => {
    console.log('Promise 1'); // 3  })
  .then(() => {
    console.log('Promise 2'); // 4  });console.log('End'); // 2
```

Выполняется console.log(‘Start’).
Функция setTimeout ставит функцию в очередь задач (макрозадач).
Промис ставит функцию в очередь микрозадач.
Выполняется console.log(‘End’).
Event Loop выполняет задачи из очереди микрозадач (Promise 1, Promise 2).
Event Loop выполняет задачи из очереди задач (setTimeout).

### Garbage collection basics

Сборка мусора (Garbage Collection) в JavaScript — это процесс автоматического управления памятью, который освобождает память, занятую объектами, которые больше не используются программой. Понимание принципов работы сборки мусора позволяет разработчикам писать более эффективный и производительный код.
Управление памятью в JavaScript
JavaScript имеет автоматическое управление памятью, что означает, что разработчикам не нужно вручную выделять и освобождать память, как это требуется в некоторых других языках программирования (например, C или C++). Вместо этого JavaScript использует сборку мусора для управления памятью.
Этапы управления памятью
Выделение памяти: Когда создается объект, массив или другая структура данных, память для них выделяется автоматически.
Использование памяти: В процессе выполнения программы память используется для хранения значений переменных, объектов, массивов и других структур данных.
Освобождение памяти: Когда объекты больше не используются, сборщик мусора освобождает память, занятую этими объектами.
Основные концепции
1. Достижимость (Reachability)
Основная концепция, используемая сборщиком мусора, — это достижимость. Объект считается достижимым, если он может быть доступен из корня (root) — глобального объекта, таких как window в браузерах или global в Node.js, или из любого другого достижимого объекта.
Пример достижимых объектов:
Глобальные переменные.
Локальные переменные и параметры функций.
Объекты, на которые есть ссылки из других достижимых объектов.
2. Сильные и слабые ссылки
Сильные ссылки: Объекты, на которые есть сильные ссылки, считаются достижимыми и не могут быть собраны сборщиком мусора.
Слабые ссылки: Объекты, на которые есть только слабые ссылки, могут быть собраны сборщиком мусора, если на них больше нет сильных ссылок.
Алгоритмы сборки мусора
1. Алгоритм “Mark-and-Sweep” (Отметка и Очистка)
Это основной алгоритм, используемый в большинстве современных движков JavaScript, таких как V8 (используемый в Google Chrome и Node.js).
Этап отметки (Marking phase): Сборщик мусора обходит граф объектов, начиная с корней, и помечает все достижимые объекты.
Этап очистки (Sweeping phase): Все непомеченные объекты считаются недостижимыми и их память освобождается.

```jsx
// Пример использования памяти и сборки мусораlet obj = {
  name: "John",  age: 30};// 'obj' и его свойства достижимыobj = null; // Теперь объект недостижим и может быть собран сборщиком мусора
```

1. Сборка мусора на основе поколений
Сборка мусора на основе поколений основана на наблюдении, что большинство объектов “живут” недолго. Движки, такие как V8, разделяют объекты на два поколения:
Молодое поколение (Young Generation): Содержит недавно созданные объекты. Сборка мусора для этого поколения происходит часто и быстро.
Старое поколение (Old Generation): Содержит более “старые” объекты, которые пережили несколько циклов сборки мусора в молодом поколении. Сборка мусора для этого поколения происходит реже и медленнее.
2. Инкрементальная и параллельная сборка мусора
Для минимизации пауз, вызванных сборкой мусора, используются инкрементальные и параллельные методы:
Инкрементальная сборка мусора: Алгоритм разбивает процесс сборки мусора на небольшие части и выполняет их постепенно, чтобы уменьшить паузы.
Параллельная сборка мусора: Использует несколько потоков для выполнения сборки мусора одновременно с основным потоком выполнения программы.
Типы сборки мусора
3. Синхронная сборка мусора
В синхронной сборке мусора процесс выполнения программы приостанавливается до тех пор, пока сборка мусора не завершится. Это может привести к паузам в работе программы.
4. Асинхронная сборка мусора
Асинхронная сборка мусора выполняется параллельно с выполнением программы, что позволяет минимизировать паузы, вызванные сборкой мусора.
Влияние на производительность
Хотя сборка мусора автоматизирует управление памятью, разработчики должны понимать её влияние на производительность:
Частое создание и удаление объектов может привести к более частой работе сборщика мусора и, соответственно, к паузам.
Долгоживущие объекты могут занимать память дольше, что приводит к увеличению использования памяти.
Советы по оптимизации
Минимизируйте создание ненужных объектов: Создание большого количества объектов в короткий промежуток времени может привести к частой сборке мусора.
Используйте слабые ссылки, если это уместно: Использование WeakMap и WeakSet позволяет избегать утечек памяти, так как объекты могут быть собраны сборщиком мусора, если они больше не используются.
Будьте внимательны с замыканиями: Замыкания могут удерживать ссылки на объекты дольше, чем необходимо, что может привести к утечкам памяти.
Примеры слабых ссылок

```jsx
let obj = { name: "John" };const weakMap = new WeakMap();weakMap.set(obj, "some value");obj = null; // Объект теперь доступен для сборки мусора
```

JavaScript in Browser

### Global object window

Объект window — это глобальный объект в среде выполнения JavaScript в браузере. Он представляет собой окно браузера и предоставляет доступ к различным свойствам и методам, таким как документ, история браузера, таймеры и многое другое.
Свойства window
document: Представляет собой объект Document, который представляет собой текущий HTML-документ и предоставляет методы для взаимодействия с его содержимым.
navigator: Содержит информацию о браузере пользователя, такую как его агент, версия и язык.
location: Предоставляет информацию о текущем URL-адресе и позволяет перенаправлять пользователя на другие страницы.
history: Предоставляет доступ к истории браузера, позволяя перемещаться по истории и изменять URL-адрес без перезагрузки страницы.
localStorage и sessionStorage: Позволяют хранить данные локально на стороне клиента, которые сохраняются между сеансами браузера (localStorage) или только в рамках текущего сеанса (sessionStorage).
console: Объект для взаимодействия с консолью браузера, используемый для отладки и вывода сообщений.
Методы window
setTimeout() и clearTimeout(): Позволяют установить и удалить таймер, который выполняет функцию через определенное количество времени.
setInterval() и clearInterval(): Позволяют установить и удалить интервальный таймер, который выполняет функцию с определенной периодичностью.
alert(), confirm() и prompt(): Позволяют отображать модальные диалоговые окна для вывода сообщений, запроса подтверждения и получения ввода от пользователя соответственно.
open() и close(): Позволяют открывать и закрывать новые окна браузера.

Особенности использования в браузерном окружении
Cross-Origin Security: Безопасность среды выполнения JavaScript в браузере ограничивает доступ к объектам других доменов из соображений безопасности.
Single Threaded: JavaScript в браузере является однопоточным, что означает, что все операции выполняются в одном потоке. Это позволяет избежать гонок данных, но может приводить к блокировкам во время выполнения длительных операций.
Event-Driven Programming: Браузерные приложения обычно строятся на основе событий, таких как клики мыши, загрузка ресурсов и изменения состояния документа.

### Understanding browser’s location and history API

### API местоположения (Location)

Объект Location предоставляет информацию о текущем URL-адресе браузера и позволяет программно управлять этим URL-адресом.
Основные свойства объекта Location:
href: Строка, содержащая полный URL текущей страницы (например, https://www.example.com/page).
host: Строка, содержащая доменное имя и порт (если указан) текущей страницы (например, www.example.com:80).
hostname: Строка, содержащая только доменное имя текущей страницы (например, www.example.com).
pathname: Строка, содержащая часть пути URL-адреса после доменного имени (например, /page).
search: Строка, содержащая параметры запроса URL-адреса (например, ?param=value).
hash: Строка, содержащая идентификатор фрагмента URL-адреса (например, #section).
Основные методы объекта Location:
assign(url): Загружает новый документ по указанному URL-адресу.
replace(url): Заменяет текущий документ новым по указанному URL-адресу, но без создания записи в истории браузера.
reload(): Перезагружает текущий документ.
// Пример использования объекта Location
console.log(window.location.href); // Выводит текущий URL-адрес страницы
window.location.assign(‘https://www.example.com/newpage’); // Переход на новую страницу

### API истории (History)

Объект History предоставляет интерфейс для взаимодействия с историей браузера, позволяя перемещаться по истории и изменять URL-адреса без перезагрузки страницы.
Основные методы объекта History:
back(): Перемещает браузер на одну страницу назад в истории.
forward(): Перемещает браузер на одну страницу вперед в истории (если был совершен переход назад).
go(offset): Перемещает браузер вперед (положительное значение) или назад (отрицательное значение) на указанное количество страниц в истории.
// Пример использования объекта History
window.history.back(); // Переход на предыдущую страницу в истории

Интеграция с событиями
API местоположения и истории интегрируются с событиями браузера, такими как popstate, который срабатывает при изменении истории навигации.
// Обработчик события popstate
window.addEventListener(‘popstate’, function(event) {
console.log(‘Location changed:’, window.location.href);
});
Использование API местоположения и истории браузера позволяет создавать интерактивные веб-приложения, которые могут динамически изменять URL-адреса, перемещаться по истории и обновлять содержимое страницы без перезагрузки. Эти API являются важными инструментами для разработки современных веб-приложений и одной из ключевых особенностей современных веб-браузеров.

### User agent parsing and platform/browser detection

Парсинг User Agent и определение платформы/браузера являются важными задачами веб-разработки, позволяющими адаптировать контент и функционал вашего сайта или приложения под различные устройства и браузеры. Давайте подробнее рассмотрим каждый из этих аспектов.
1. Парсинг User Agent
User Agent (агент пользователя) - это строка, которую браузер отправляет на сервер при каждом HTTP-запросе, чтобы идентифицировать себя и передать информацию о своей версии, операционной системе и других аспектах.
Пример User Agent строки:
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4864.75 Safari/537.36
2. Определение платформы/браузера
Для определения платформы и браузера на основе User Agent строки можно использовать различные методы и библиотеки.
// Определение браузера и платформы с использованием navigator.userAgent
const userAgent = navigator.userAgent;
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
const isDesktop = !isMobile;
const isChrome = /Chrome/i.test(userAgent);
const isFirefox = /Firefox/i.test(userAgent);
// И т.д.
// Библиотеки, такие как platform.js, могут упростить этот процесс
console.log(platform.name); // Название платформы (Windows, Mac OS X, Linux, Android, iOS, …)
console.log(platform.version); // Версия платформы
console.log(platform.os); // Тип операционной системы (Windows, macOS, Linux, Android, iOS, …)
console.log(platform.description); // Полное описание платформы
Серверная сторона
На серверной стороне вы можете использовать данные User Agent для адаптации контента и функционала, а также для аналитики. Многие веб-серверы предоставляют доступ к User Agent через HTTP-заголовок User-Agent.
Пример использования
// JavaScript
if (isMobile) {
// Показывать мобильную версию сайта
} else {
// Показывать десктопную версию сайта
}

Парсинг User Agent и определение платформы/браузера позволяют создавать адаптивные и кросс-браузерные веб-приложения и сайты, что обеспечивает лучший пользовательский опыт и повышает доступность вашего контента для различных устройств и браузеров. Однако, стоит помнить, что User Agent может быть поддельным или измененным, поэтому использование этой информации следует рассматривать с осторожностью и в сочетании с другими методами анализа и адаптации.

### Page Lifecycle

- 1. Запрос (Request)
На этом этапе происходит отправка запроса на сервер для получения содержимого страницы. Браузер отправляет HTTP-запрос и ожидает ответ.
-2. Загрузка (Loading)
Этот этап включает получение HTML-кода и связанных ресурсов (CSS, JavaScript, изображения) от сервера. Здесь происходит:
Получение ресурсов: Браузер загружает HTML-документ, CSS-файлы, JavaScript-файлы, изображения и шрифты.
-3. Рендеринг (Rendering)
После получения всех необходимых ресурсов браузер приступает к рендерингу страницы. В рамках рендеринга выполняются следующие процессы:
Parsing:
Разбор HTML: Браузер разбирает HTML-код и строит DOM (Document Object Model).
Разбор CSS: Браузер разбирает CSS-код и строит CSSOM (CSS Object Model).
Critical Rendering Path:
Построение Render Tree: На основе DOM и CSSOM создается дерево рендеринга.
Layout (Reflow): Определение размеров и расположения каждого элемента на странице.
Painting (Repaint): Отрисовка элементов на экране.
Critical Rendering Path включает в себя весь процесс от разбора HTML и CSS до отрисовки элементов на экране. Это критический путь, который браузер проходит, чтобы отобразить содержимое страницы как можно быстрее.
1. Интерактивность (Interactivity)
Когда страница полностью загружена и отрендерена, пользователь может взаимодействовать с ней. На этом этапе происходят:
Выполнение JavaScript: JavaScript-скрипты могут вносить изменения в DOM и CSSOM, что может вызывать дополнительные reflow и repaint.
Reflow: Перестройка макета страницы при изменениях DOM, таких как добавление, удаление или изменение элементов.
Repaint: Перерисовка элементов на экране при изменениях стилей, которые не требуют изменений в макете.
-5. Выгрузка (Unload)
Когда пользователь переходит на другую страницу или закрывает текущую, страница проходит через этап выгрузки. На этом этапе:
Освобождение ресурсов: Браузер освобождает память, занятую ресурсами страницы, и сбрасывает ее состояние.
- Дополнительные этапы (опционально)
DOMContentLoaded: Событие, которое происходит, когда первоначальный HTML-документ полностью загружен и разобран (DOM готов к манипуляциям), но внешние ресурсы (CSS, изображения) еще могут быть не загружены. Происходит после Parsing HTML и построения DOM.
Load: Событие, которое происходит, когда вся страница (включая все зависимости, такие как стили и изображения) полностью загружена и отрендерена. Происходит после завершения Critical Rendering Path и полного завершения всех этапов рендеринга.
BeforeUnload: Событие, которое возникает перед выгрузкой страницы, позволяя выполнять действия, такие как предупреждение пользователя о несохраненных изменениях. Происходит непосредственно перед этапом выгрузки.
Unload: Событие, которое срабатывает, когда страница выгружается, т.е. когда пользователь покидает страницу или переходит на другую страницу.
- Итоговая картина
Запрос: Получение HTML-документа и связанных ресурсов.
Загрузка: Получение HTML, CSS, JS и других ресурсов.
Рендеринг:
Parsing (HTML и CSS) → Построение DOM и CSSOM.
Critical Rendering Path → Построение Render Tree, Layout (Reflow) и Painting (Repaint).
Интерактивность: Выполнение JavaScript, взаимодействие пользователя, возможные дополнительные Reflow и Repaint.
Выгрузка: Освобождение ресурсов и сброс состояния

### Network requests

Сетевые запросы - это важная часть веб-разработки, позволяющая вашему приложению взаимодействовать с сервером, получать данные и отправлять обновления. Давайте рассмотрим процесс сетевых запросов более подробно.
1. Типы сетевых запросов
Существует два основных типа сетевых запросов:
Запросы GET: Используются для получения данных с сервера. Обычно они не изменяют состояние сервера и могут быть кешированы браузером.
GET /api/data HTTP/1.1
Host: example.com
Запросы POST: Используются для отправки данных на сервер. Они могут изменять состояние сервера и обычно не кешируются.
POST /api/submit HTTP/1.1
Host: example.com
Content-Type: application/json
{“key”: “value”}
2. Процесс сетевого запроса
Процесс сетевого запроса состоит из нескольких этапов:
Инициация: Ваше приложение отправляет запрос на определенный URL-адрес сервера с определенными параметрами.
Отправка: Браузер отправляет запрос на сервер по указанному URL-адресу с использованием протокола HTTP или HTTPS.
Обработка на сервере: Сервер обрабатывает запрос, выполняет запрошенные операции и генерирует ответ.
Получение ответа: Браузер получает ответ от сервера в виде HTTP-статуса и тела ответа.
Обработка ответа: Ваше приложение обрабатывает полученные данные, выполняет необходимые действия и обновляет интерфейс при необходимости.
3. Асинхронные запросы
Современные веб-приложения часто используют асинхронные запросы, чтобы не блокировать пользовательский интерфейс во время выполнения сетевых операций. Это достигается с помощью технологий, таких как AJAX (Asynchronous JavaScript and XML) и Fetch API.

```jsx
// Пример асинхронного запроса с использованием Fetch APIfetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

1. Обработка ошибок
При сетевых запросах могут возникать различные ошибки, такие как недоступность сервера, проблемы с соединением или неправильные данные. Для обработки ошибок важно предусмотреть механизмы проверки и обработки ошибок в вашем коде.

```jsx
// Пример обработки ошибок при использовании Fetch APIfetch('/api/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');    }
    return response.json();  })
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

1. Безопасность
При отправке конфиденциальных данных по сети важно обеспечить их безопасность. Для этого используются протоколы шифрования, такие как HTTPS, а также различные методы аутентификации и авторизации.

### Using Fetch and understanding XMLHTTPRequest

Использование Fetch API и понимание XMLHTTPRequest (XHR) - это два основных метода для выполнения сетевых запросов в веб-разработке. Давайте рассмотрим каждый из них подробно.
1. Fetch API
Fetch API - это современный стандартный интерфейс для сетевых запросов в браузере, который предоставляет более простой и гибкий способ выполнения HTTP-запросов и работы с ответами, чем устаревший XMLHttpRequest.
Пример использования Fetch API:

```jsx
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');    }
    return response.json();  })
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

1. XMLHttpRequest (XHR)
XMLHttpRequest (XHR) - это стандартный объект в JavaScript, который позволяет отправлять сетевые запросы и получать данные с сервера без необходимости перезагрузки страницы. Это устаревший метод, но все еще используется в старых веб-приложениях и для совместимости с более старыми браузерами.
Он предоставляет более низкоуровневый доступ к сетевым операциям и обработке ответов.
XHR является синхронным по умолчанию, что может вызывать проблемы с блокированием потока в некоторых случаях
Пример использования XMLHttpRequest:

```jsx
var xhr = new XMLHttpRequest();xhr.open('GET', 'https://api.example.com/data', true);xhr.onreadystatechange = function () {
 if (xhr.readyState === XMLHttpRequest.DONE) {
   if (xhr.status === 200) {
     console.log(xhr.responseText);   } else {
     console.error('Error:', xhr.status);   }
 }
};xhr.send();
```

```
Создание объекта XMLHttpRequest с помощью конструктора new XMLHttpRequest().
Открытие соединения с сервером с помощью метода open(). В данном случае выполняется GET-запрос к URL https://api.example.com/data. Последний аргумент true указывает на асинхронный режим (запрос будет выполнен асинхронно).
Установка обработчика события onreadystatechange, который будет вызываться при изменении состояния запроса. В данном случае мы проверяем, когда состояние запроса становится XMLHttpRequest.DONE (4), что означает, что запрос завершен.
При состоянии XMLHttpRequest.DONE проверяем статус ответа (xhr.status). Если статус равен 200, это означает успешный запрос, и мы выводим ответ сервера в консоль с помощью console.log(xhr.responseText). В противном случае выводим сообщение об ошибке с кодом статуса.
Отправка запроса на сервер с помощью метода send().
```

Сравнение Fetch API и XMLHttpRequest
Fetch API предоставляет более современный и удобный способ выполнения сетевых запросов, а также имеет более простой и чистый синтаксис по сравнению с XMLHttpRequest. Fetch API также предоставляет встроенную поддержку Promise, что делает его более удобным для работы с асинхронными запросами.
Однако XMLHttpRequest все еще может быть полезным для решения определенных задач, особенно если вы работаете с устаревшими браузерами или имеете дело с более сложными сценариями, такими как загрузка файлов.

### Timers

Таймеры в JavaScript - это механизмы, которые позволяют выполнять код через определенный интервал времени или после задержки. Они являются важной частью асинхронного программирования и позволяют создавать задержки, периодически выполнять функции и управлять временными интервалами в веб-приложениях. Давайте подробно рассмотрим различные типы таймеров в JavaScript:
1. setTimeout
setTimeout используется для вызова функции один раз после указанной задержки в миллисекундах.

```jsx
setTimeout(() => {
  console.log('Этот код будет выполнен через 2 секунды');}, 2000);2. clearTimeout
```

clearTimeout используется для отмены выполнения функции, запланированной с помощью setTimeout.

```jsx
const timeoutId = setTimeout(() => {
  console.log('Этот код не будет выполнен');}, 2000);clearTimeout(timeoutId); // Отменяет выполнение setTimeout
```

1. setInterval
setInterval используется для вызова функции периодически с интервалом между вызовами.

```jsx
const intervalId = setInterval(() => {
  console.log('Этот код будет выполнен каждые 3 секунды');}, 3000);
```

1. clearInterval
clearInterval используется для остановки выполнения функции, запланированной с помощью setInterval.

```jsx
const intervalId = setInterval(() => {
  console.log('Этот код не будет выполнен');}, 3000);clearInterval(intervalId); // Останавливает выполнение setInterval
```

Замечания по использованию
Таймеры в JavaScript работают в однопоточной среде выполнения, что означает, что выполнение другого кода блокируется, пока таймер не завершится.
Использование слишком коротких интервалов времени может привести к избыточной нагрузке на процессор и плохому быстродействию.
Внимательно следите за утечками памяти при использовании таймеров, особенно если они вызываются в циклах или рекурсивно.
Применение таймеров
Анимации: Таймеры могут использоваться для создания анимаций на веб-страницах.
Автообновление данных: Можно использовать setInterval, чтобы периодически обновлять данные на странице.
Отложенная загрузка ресурсов: setTimeout может быть использован для отложенной загрузки ресурсов, таких как изображения или скрипты, для улучшения производительности страницы.

### Differences between setTimeout and requestAnimationFrame

setTimeout и requestAnimationFrame (rAF) - это два различных механизма в JavaScript, которые позволяют выполнять код асинхронно и планировать его выполнение через определенное время. Оба они часто используются для создания анимаций и выполнения действий с задержкой, но у них есть ряд существенных различий.
1. setTimeout
setTimeout - это функция, которая запускает выполнение заданной функции один раз через указанный интервал времени.

```jsx
setTimeout(() => {
  console.log('Этот код выполнится через 1000 миллисекунд (1 секунду)');}, 1000);
```

1. requestAnimationFrame
requestAnimationFrame - это функция, которая запускает выполнение заданной функции перед следующим перерисовыванием экрана браузера. Это делает его идеальным для создания анимаций с высокой производительностью, так как он синхронизируется с обновлениями экрана.

```jsx
function animate() {
  // Код анимации  requestAnimationFrame(animate);}
animate(); // Начать анимацию
```

Основные различия
1. Временные характеристики:
setTimeout не гарантирует точное время выполнения кода из-за асинхронной природы JavaScript и возможных задержек из-за загрузки ресурсов или выполнения других задач.
requestAnimationFrame запускает код анимации перед каждым обновлением экрана, что позволяет создавать более плавные и производительные анимации. Он автоматически подстраивается под частоту обновления экрана, что уменьшает мерцание и делает анимацию более качественной.
2. Периодичность выполнения:
setTimeout выполняет код только один раз после заданной задержки.
requestAnimationFrame позволяет создавать бесконечные циклы анимации, так как он вызывается перед каждым обновлением экрана.
3. Производительность:
requestAnimationFrame обычно производительнее и предпочтительнее для создания анимаций, особенно для анимаций, которые должны быть синхронизированы с обновлениями экрана.
setTimeout может быть использован для выполнения задач с задержкой, которым не требуется высокая производительность или точная синхронизация с обновлениями экрана.
Использование
Используйте setTimeout, когда требуется выполнить код один раз через определенный интервал времени без синхронизации с обновлениями экрана.
Используйте requestAnimationFrame, когда требуется создание производительной и плавной анимации, синхронизированной с обновлениями экрана.

Web Communication Protocols:

### Differences between HTTP and HTTPS

HTTP (HyperText Transfer Protocol) и HTTPS (HyperText Transfer Protocol Secure) - это два протокола передачи данных в сети Интернет, используемых для обмена информацией между клиентом и сервером. Давайте рассмотрим основные различия между ними:
1. Безопасность
HTTP: HTTP передает данные в открытом виде, что делает их уязвимыми для перехвата и прослушивания злоумышленниками. Это означает, что конфиденциальная информация, такая как пароли или данные кредитных карт, может быть скомпрометирована.
HTTPS: HTTPS использует протокол SSL/TLS для шифрования данных, которые передаются между клиентом и сервером. Это обеспечивает конфиденциальность и целостность передаваемой информации и защищает ее от перехвата и модификации злоумышленниками.
2. Протокол
HTTP: HTTP работает на порту 80 по умолчанию.
HTTPS: HTTPS работает на порту 443 по умолчанию.
3. Сертификация
HTTP: HTTP не требует использования цифровых сертификатов.
HTTPS: HTTPS требует использования цифровых сертификатов, выданных доверенными удостоверяющими центрами (Certificate Authorities), для проверки подлинности веб-сайта и обеспечения безопасного соединения.
4. Проверка подлинности
HTTP: HTTP не предоставляет механизмов для проверки подлинности сервера или клиента.
HTTPS: HTTPS использует цифровые сертификаты для проверки подлинности сервера и клиента, что помогает предотвращать атаки типа “Man-in-the-Middle” и обеспечивает доверие между участниками обмена данными.
5. SEO
HTTP: На поисковые системы HTTP-сайты смотрят негативно, особенно после введения обновления алгоритма Google в 2014 году, когда безопасность сайта (в частности, HTTPS) стала одним из факторов ранжирования.
HTTPS: HTTPS-сайты могут иметь преимущество в рейтинге поисковых систем благодаря своей безопасности и надежности.
Общий вывод состоит в том, что HTTPS предоставляет защищенное и шифрованное соединение между клиентом и сервером, тогда как HTTP передает данные в открытом виде и не обеспечивает безопасность. В связи с этим, использование HTTPS рекомендуется для любых веб-приложений, особенно для тех, которые работают с конфиденциальной информацией пользователей.

### Understanding HTTP methods, headers, responses, and status codes

1. HTTP Methods (Методы HTTP)
HTTP методы определяют тип запроса, который клиент отправляет серверу, и как сервер должен обрабатывать этот запрос. Некоторые из наиболее распространенных HTTP методов:
GET: Запрашивает данные из указанного ресурса.
POST: Отправляет данные для обработки на сервере.
PUT: Обновляет данные на сервере.
DELETE: Удаляет указанный ресурс.
PATCH: Частично изменяет ресурс.
HEAD: Запрашивает заголовки, аналогично методу GET, но без тела ответа.
2. HTTP Headers (Заголовки HTTP)
HTTP заголовки содержат метаданные о запросе или ответе, которые не являются частью тела сообщения, но предоставляют дополнительную информацию о его содержании, формате, аутентификации, кэшировании и т.д. Некоторые распространенные заголовки:
Content-Type: Определяет тип содержимого сообщения (например, text/html, application/json).
Content-Length: Содержит длину тела сообщения в байтах.
Authorization: Используется для аутентификации пользователя.
User-Agent: Содержит информацию о браузере или клиентском приложении.
Cache-Control: Управляет кэшированием содержимого.
Location: Используется для перенаправления.
3. HTTP Responses (Ответы HTTP)
HTTP ответы содержат информацию от сервера о результате обработки запроса. Каждый ответ состоит из:
Статусной код (Status Code): Цифровой код, который указывает на результат выполнения запроса (например, 200 - OK, 404 - Not Found, 500 - Internal Server Error).
Заголовки (Headers): Метаданные ответа, аналогично заголовкам запроса.
Тело (Body): Опциональное содержимое ответа, которое может быть любым типом данных (HTML, JSON, XML и т.д.).
4. HTTP Status Codes (Статусные коды HTTP)
HTTP статусные коды представляют собой трехзначные числа, которые указывают на результат выполнения запроса. Некоторые из наиболее распространенных кодов:
1xx (Информационные): Используются для передачи информации о процессе обработки запроса.
2xx (Успех): Указывает успешное завершение запроса.
3xx (Перенаправление): Указывает, что дополнительные действия должны быть предприняты для завершения запроса.
4xx (Ошибка клиента): Указывает на ошибку на стороне клиента (например, 404 - Not Found, 401 - Unauthorized).
5xx (Ошибка сервера): Указывает на ошибку на стороне сервера (например, 500 - Internal Server Error).

### Concepts of RESTful APIs

REST (Representational State Transfer) — это архитектурный стиль для создания сетевых приложений. В REST API применяются шесть ключевых принципов:

1. **Клиент-серверная модель** (Client-Server):
    - Сервер управляет данными и логикой, а клиент взаимодействует с пользователем и отображает данные. Это разделение позволяет улучшить масштабируемость и упрощает обновления.
2. **Отсутствие состояния** (Stateless):
    - Каждое обращение клиента к серверу должно содержать всю необходимую информацию для обработки запроса. Сервер не сохраняет состояние клиента между запросами. Это упрощает масштабируемость и восстановление после сбоев.
3. **Кэширование** (Cacheable):
    - Ответы от сервера должны явно указывать, могут ли они быть закэшированы клиентом и на какой срок. Кэширование уменьшает количество запросов к серверу, повышая производительность и уменьшая задержки.
4. **Единообразие интерфейса** (Uniform Interface):
    - Интерфейс взаимодействия должен быть единообразным и стандартизированным. Это включает в себя идентификацию ресурсов (URI), манипуляции с ресурсами через представления (HTTP методы), самоописательные сообщения и гипермедиа как движущую силу приложений (HATEOAS).
5. **Многоуровневая система** (Layered System):
    - Архитектура может состоять из нескольких уровней (например, серверы балансировки нагрузки, серверы приложений, серверы баз данных). Каждый уровень может выполнять свои функции, не зная о всей системе, что повышает гибкость и масштабируемость.
6. **Код по требованию** (Code on Demand) [необязательный принцип]:
    - Сервер может передавать исполняемый код или скрипты клиенту для выполнения. Это позволяет расширять функциональность клиентов без необходимости их обновления.

Эти принципы помогают создавать масштабируемые, надежные и простые в сопровождении системы.

RESTful API (Representational State Transfer) - это архитектурный стиль, используемый для построения веб-сервисов, которые предоставляют доступ к ресурсам через стандартные операции HTTP. Он основан на принципах, разработанных Роем Филдингом (Roy Fielding) в его докторской диссертации.
Вот основные концепции RESTful API:
1. Ресурсы (Resources)
Ресурсы представляют собой объекты или данные, к которым можно получить доступ через API. Каждый ресурс имеет уникальный идентификатор (URI), который используется для его идентификации. Например, ресурсы могут быть пользователями, сообщениями, комментариями и т.д.
2. HTTP Методы (HTTP Methods)
RESTful API использует стандартные методы HTTP для выполнения операций над ресурсами:
GET: Используется для получения информации о ресурсе.
POST: Создает новый ресурс.
PUT: Обновляет существующий ресурс.
DELETE: Удаляет ресурс.
PATCH: Частично обновляет ресурс.
3. Представление (Representation)
Ресурсы могут быть представлены в различных форматах данных, таких как JSON, XML, HTML и другие. Клиенты обычно отправляют запросы с указанием желаемого формата представления ресурса, а сервер возвращает данные в этом формате.
4. Гипермедиа как движущая сила (Hypermedia as the Engine of Application State, HATEOAS)
Это один из ключевых принципов RESTful API, который подразумевает, что клиент должен быть способен навигировать по API, следуя гиперссылкам (hyperlinks), предоставляемым сервером в ответ на запросы. Это делает клиенты более независимыми от структуры API и облегчает изменение или добавление новых функциональностей без необходимости изменения клиентского кода.
5. Stateless (Безсостояний)
Каждый запрос к серверу должен содержать всю необходимую информацию для его обработки, и сервер не должен хранить состояние клиента между запросами. Это позволяет легко масштабировать и распределить нагрузку на сервер.

Common Web-Security Knowledge:

### Basic security concepts including CORS, XSS, and OWASP Top 10

1. CORS (Cross-Origin Resource Sharing)
CORS - это механизм, который позволяет веб-странице запрашивать ресурсы с другого источника (origin), отличного от того, который предоставляет саму страницу. Он используется для защиты от атак, связанных с кросс-доменными запросами.
Проблема безопасности: Если веб-приложение не настроено для поддержки CORS, браузер может заблокировать запросы на другой домен, что может привести к ограничению функциональности или недоступности некоторых ресурсов.
2. XSS (Cross-Site Scripting)
XSS - это тип атаки, при которой злоумышленник внедряет вредоносный скрипт на веб-страницу, который выполняется в браузере жертвы. Атака XSS может быть хранимой, когда вредоносный скрипт сохраняется на сервере и выполняется при загрузке страницы, или рефлектируемой, когда злоумышленный скрипт передается в запросе.
Проблема безопасности: XSS может привести к краже данных пользователя, выполнению нежелательных действий от его имени, а также к утечке куки или сессионной информации.
3. OWASP Top 10
OWASP (Open Web Application Security Project) Top 10 - это список десяти наиболее критических уязвимостей веб-приложений, составленный OWASP, организацией, занимающейся безопасностью веб-приложений. Этот список обновляется примерно раз в 3 года и отражает последние тенденции и угрозы в области веб-безопасности.
Проблема безопасности: OWASP Top 10 включает такие уязвимости, как инъекции SQL, недостаточная аутентификация, кросс-сайтовая подделка запроса (CSRF), неправильная обработка сессий и аутентификационные данные, а также другие уязвимости, которые могут привести к утечке данных, нарушению целостности или компрометации безопасности приложения.
Понимание и защита от этих угроз являются важными аспектами разработки безопасных веб-приложений. Это включает в себя использование правильных методов аутентификации и авторизации, фильтрацию и валидацию пользовательского ввода, настройку CORS и использование средств защиты от XSS, а также регулярное обновление приложений и мониторинг за уязвимостями в них.

### Authentication mechanisms (JWT, OAuth)

1. JSON Web Tokens (JWT)
JWT - это открытый стандарт (RFC 7519), который определяет компактный и самоописывающийся способ представления информации об утверждениях между двумя сторонами в виде JSON-объектов. Он используется для аутентификации и обмена данных между клиентом и сервером.
Принцип работы:
Аутентификация: Когда пользователь успешно проходит аутентификацию на сервере, ему выдается JWT, содержащий информацию об утверждениях (например, идентификатор пользователя, срок действия, роли и т.д.).
Хранение на клиенте: JWT сохраняется на клиентской стороне, например, в localStorage или в cookie.
Предоставление токена: Клиент включает JWT в заголовок запроса или в куки при каждом запросе к защищенным ресурсам.
Проверка токена: Сервер проверяет подлинность и действительность JWT, декодируя его и проверяя подпись.
Выдача доступа: Если токен действителен и подлинен, сервер разрешает доступ к защищенным ресурсам и выполняет запрос от имени пользователя.
2. OAuth (Open Authorization)
OAuth - это протокол авторизации, который позволяет веб-приложениям получать доступ к защищенным ресурсам от имени пользователя без необходимости передачи его учетных данных (например, пароля).
Принцип работы:
Аутентификация пользователя: Пользователь аутентифицируется на сервере и дает разрешение на доступ к своим данным третьему приложению.
Выдача авторизации: Сервер выдает авторизационный токен, который может быть использован клиентским приложением для доступа к защищенным ресурсам.
Использование токена: Клиентское приложение отправляет авторизационный токен в запросе к защищенным ресурсам.
Проверка токена: Сервер проверяет подлинность и действительность токена, а также права доступа пользователя.
Выдача доступа: Если токен действителен и подлинен, сервер разрешает доступ к защищенным ресурсам и выполняет запрос от имени пользователя.
Оба механизма - JWT и OAuth - предоставляют безопасные и эффективные способы аутентификации и авторизации веб-приложений. Выбор между ними зависит от требований конкретного проекта и контекста его использования.

## Coding Task Examples:

Polyfills and Extensions

### Function.prototype.bind Polyfill Implement a polyfill for Function.prototype.bind.

реализации полифилла для метода bind объекта Function.prototype:

```
// Проверяем, существует ли метод bind в прототипе функций
if (!Function.prototype.bind) {
  // Определяем полифилл для bind
  Function.prototype.bind = function (context) {
      // Проверяем, является ли текущий контекст функцией
      if (typeof this !== 'function') {
          // Если текущий контекст не является функцией, выбрасываем исключение
          throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
      }
      // Сохраняем ссылку на вызываемую функцию
      var fn = this;
      // Получаем аргументы, переданные в bind, за исключением первого аргумента (контекста)
      var args = Array.prototype.slice.call(arguments, 1);
      // Возвращаем функцию-обертку
      return function () {
          // Получаем аргументы, переданные при вызове связанной функции
          var bindArgs = Array.prototype.slice.call(arguments);
          // Вызываем функцию с переданным контекстом и объединенными аргументами
          return fn.apply(context, args.concat(bindArgs));
      };
  };
}

```

Этот полифилл расширяет объект Function.prototype, добавляя метод bind, если он отсутствует в среде выполнения JavaScript. Метод bind используется для привязки контекста выполнения функции и определения начальных аргументов.
Пример использования:
`function greet(name) {     console.log('Hello, ' + name); } var greetBob = greet.bind(null, 'Bob'); greetBob(); // Выведет "Hello, Bob"`

В этом примере bind используется для создания новой функции greetBob, которая всегда будет вызывать greet с аргументом ‘Bob’ в качестве первого аргумента.

### Object.create Polyfill Implement a polyfill for Object.create.

пример полифилла для метода Object.create:
```
// Полифилл для метода Object.create
// Проверяем, существует ли метод create в прототипе объектов
if (!Object.create) {
// Определяем полифилл для create
Object.create = function (proto, propertiesObject) {
// Проверяем, что первый аргумент является объектом или null
if (typeof proto !== ‘object’ && typeof proto !== ‘function’) {
// Если первый аргумент не объект и не функция, выбрасываем исключение TypeError
throw new TypeError(‘Object prototype may only be an Object or null’);
}
// Создаем временную функцию-конструктор
function F() {}
// Устанавливаем прототип для временной функции-конструктора равным переданному прототипу
F.prototype = proto;
// Создаем новый объект с прототипом, установленным в переданный прототип
var obj = new F();
// Если передан объект с описанием свойств, устанавливаем эти свойства на новом объекте
if (propertiesObject !== undefined) {
// Устанавливаем свойства объекта с помощью метода Object.defineProperties
Object.defineProperties(obj, propertiesObject);
}
// Возвращаем созданный объект
return obj;
};
}

```
Этот полифилл расширяет объект Object, добавляя метод create, если он отсутствует в среде выполнения JavaScript. Метод create используется для создания нового объекта с указанным прототипом и набором свойств.
Пример использования:
```

var person = {
name: ‘John’,
age: 30
};
var student = Object.create(person, {
studentId: {
value: ‘12345’,
enumerable: true
}
});
console.log(student.name); // Выведет “John”
console.log(student.age); // Выведет 30
console.log(student.studentId); // Выведет “12345”
```
В этом примере student создается с прототипом person и дополнительным свойством studentId, заданным вторым аргументом метода Object.create.

### Array.flat Polyfill Implement a polyfill for Array.flat.

Вот пример полифилла для метода flat массивов:
`// Полифилл для метода flat массивов if (!Array.prototype.flat) {     Array.prototype.flat = function(depth = 1) {         var flattenedArray = []; // Инициализируем массив, в который будем собирать элементы         function flatten(arr, currentDepth) {             for (var i = 0; i < arr.length; i++) {                 if (Array.isArray(arr[i]) && currentDepth < depth) {                     flatten(arr[i], currentDepth + 1); // Рекурсивно обрабатываем вложенные массивы                 } else {                     flattenedArray.push(arr[i]); // Добавляем элемент в выходной массив                 }             }         }         flatten(this, 0); // Начинаем обход с текущего массива (this) и текущей глубины 0         return flattenedArray; // Возвращаем собранный массив     }; }`
Этот полифилл расширяет объект Array.prototype, добавляя метод flat, если он отсутствует в среде выполнения JavaScript. Метод flat используется для “сглаживания” (уплощения) массива до указанной глубины.
Пример использования:
`var arr = [1, 2, [3, 4, [5, 6]]]; var flatArr = arr.flat(2); // Уплощаем массив до глубины 2 console.log(flatArr); // Выведет [1, 2, 3, 4, 5, 6]`
В этом примере flat используется для “сглаживания” массива arr до глубины 2.

### Array.reduce Polyfill Implement a polyfill for Array.reduce.

пример полифилла для метода reduce массивов:

```
// Полифилл для метода reduce массивов
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function(callback, initialValue) {
        if (this === null || this === undefined) {
            throw new TypeError('Array.prototype.reduce called on null or undefined');
        }
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        var arr = Object(this); // Преобразуем массив в объект
        var len = arr.length >>> 0; // Получаем длину массива, используя беззнаковый сдвиг
        var k = 0; // Инициализируем счетчик
        var accumulator = initialValue; // Инициализируем аккумулятор

        if (accumulator === undefined) {
            // Если начальное значение не передано, берем первый элемент массива
            while (k < len && !(k in arr)) {
                k++;
            }
            if (k >= len) {
                throw new TypeError('Reduce of empty array with no initial value');
            }
            accumulator = arr[k++]; // Начальное значение - первый элемент массива
        }

        while (k < len) {
            if (k in arr) {
                accumulator = callback.call(undefined, accumulator, arr[k], k, arr);
            }
            k++;
        }
        return accumulator;
    };
}
```

```
                   >
```

Этот полифилл расширяет объект Array.prototype, добавляя метод reduce, если он отсутствует в среде выполнения JavaScript. Метод reduce используется для последовательной обработки элементов массива с сохранением промежуточного результата.
Пример использования:
`var arr = [1, 2, 3, 4, 5]; var sum = arr.reduce(function(acc, val) {     return acc + val; }, 0); // Начальное значение аккумулятора - 0 console.log(sum); // Выведет 15`
В этом примере reduce используется для вычисления суммы элементов массива arr. Начальное значение аккумулятора равно 0, и к нему последовательно добавляются значения элементов массива.

### String Repeating Function Create a method that allows a string to be repeated a certain number of times, similar to the native String.prototype.repeat.

можно создать метод для повторения строки, расширив String.prototype:
`// Создание метода для повторения строки if (!String.prototype.repeatCustom) {     String.prototype.repeatCustom = function(count) {         if (count < 0) {             throw new RangeError('Количество должно быть неотрицательным');         }         var result = '';         for (var i = 0; i < count; i++) {             result += this; // Добавляем исходную строку к результату         }         return result;     }; }`
Теперь вы можете использовать метод repeatCustom для любой строки, чтобы повторить ее определенное количество раз:
`var str = 'Привет '; var repeatedStr = str.repeatCustom(3); // Повторить строку 'Привет ' 3 раза console.log(repeatedStr); // Вывод: 'Привет Привет Привет '`
Этот пользовательский метод работает аналогично встроенному методу repeat, но реализован как полифилл для сред выполнения JavaScript, не поддерживающих метод repeat, или в случаях, когда требуется дополнительный функционал.

### Custom Join Function Implement a function that constructs a string from an array of numbers, separated by a specified delimiter.

функцию, которая конструирует строку из массива чисел, разделенных указанным разделителем:
```
// Функция для объединения массива чисел в строку с заданным разделителем
function customJoin(arr, delimiter) {
if (!Array.isArray(arr)) {
throw new TypeError(‘Первый аргумент должен быть массивом’);
}

```
// Преобразуем каждый элемент массива в строку и объединяем их с разделителем
return arr.map(String).join(delimiter);
```

}
Теперь вы можете использовать эту функцию для объединения массива чисел с помощью определенного разделителя:
var numbers = [1, 2, 3, 4, 5];
var result = customJoin(numbers, ‘-’); // Разделитель ‘-’
console.log(result); // Выведет: ‘1-2-3-4-5’
```
Эта функция берет массив чисел arr и разделитель delimiter, преобразует каждый элемент массива в строку и объединяет их в одну строку с использованием разделителя.

Functional Programming Challenges

### Functional Expressions Implement a series of functions that allow for functional expressions such as five(plus(seven(minus(three())))).

Чтобы реализовать эту функциональность, можно определить функции для каждой арифметической операции (плюс, минус, умножить, делить) и числа (ноль, один, два, …, девять) и объединить их для построения нужного выражения. Вот как это можно сделать:
`// Функции для арифметических операций function plus(num) {     return function(x) {         return x + num;     }; } function minus(num) {     return function(x) {         return x - num;     }; } function multiply(num) {     return function(x) {         return x * num;     }; } function divide(num) {     return function(x) {         return x / num;     }; } // Функции для чисел function zero(func) {     return func ? func(0) : 0; } function one(func) {     return func ? func(1) : 1; } function two(func) {     return func ? func(2) : 2; } function three(func) {     return func ? func(3) : 3; } function four(func) {     return func ? func(4) : 4; } function five(func) {     return func ? func(5) : 5; } function six(func) {     return func ? func(6) : 6; } function seven(func) {     return func ? func(7) : 7; } function eight(func) {     return func ? func(8) : 8; } function nine(func) {     return func ? func(9) : 9; }`
Теперь вы можете создавать функциональные выражения, например
`five(plus(seven(minus(three())))): var result = five(plus(seven(minus(three())))); // 5 + 7 - 3 = 9 console.log(result); // Вывод: 9`
Этот подход позволяет объединять функции для создания сложных функциональных выражений. Каждая функция для числа принимает другую функцию в качестве аргумента и применяет ее к соответствующему числу, что позволяет создавать сложные арифметические выражения.

### Curried Addition Function Write a function that supports adding numbers in a curried form, such as add(5)(9)(-4)(1).

Для реализации функции, которая поддерживает сложение чисел в каррированной форме, мы можем воспользоваться замыканиями. Вот пример реализации:
`function add(x) {     // Создаем внутреннюю функцию, которая принимает следующее число для сложения     var innerAdd = function(y) {         // Если y не передано, возвращаем текущую сумму         if (y === undefined) {             return x;         }         // Возвращаем новую функцию, которая будет прибавлять следующее число к текущей сумме         return add(x + y);     };     // Возвращаем внутреннюю функцию, чтобы обеспечить каррирование     return innerAdd; } // Пример использования var result = add(5)(9)(-4)(1)(); console.log(result); // Выведет: 11 (5 + 9 - 4 + 1)`
Эта функция add принимает первое число x, а затем возвращает внутреннюю функцию innerAdd. Каждый раз, когда мы вызываем innerAdd с числом y, она прибавляет его к предыдущему значению x. Если y не передается, innerAdd возвращает текущее значение x. Таким образом, мы можем вызывать add с последовательными числами в каррированной форме.

Timing Functions

### Periodic Output Write a function that logs the elapsed time in milliseconds at regular intervals.

Вы можете использовать функцию setInterval в JavaScript для этого. Вот функция, которая регулярно выводит в консоль прошедшее время в миллисекундах:
`function periodicOutput(interval) {     var startTime = Date.now(); // Получаем текущее время при запуске функции     // Функция для вывода прошедшего времени     function logElapsedTime() {         var elapsedTime = Date.now() - startTime; // Вычисляем прошедшее время         console.log('Прошло времени:', elapsedTime, 'миллисекунд');     }     // Выводим прошедшее время через заданный интервал     var intervalId = setInterval(logElapsedTime, interval);     // Останавливаем вывод после 10 секунд     setTimeout(function() {         clearInterval(intervalId);         console.log('Вывод остановлен после 10 секунд');     }, 10000); } // Пример использования: Вывод прошедшего времени каждую секунду periodicOutput(1000);`
В этой функции:
Мы получаем текущее время с помощью Date.now() при вызове функции.
Внутри функции logElapsedTime вычисляем прошедшее время, вычитая из текущего времени стартовое время.
Мы используем setInterval для вызова logElapsedTime через определенные интервалы, указанные параметром interval.
Вывод прекращается через 10 секунд с помощью setTimeout и clearInterval.
Вы можете изменить параметр interval, чтобы изменить интервал вывода прошедшего времени.

### Extended Periodic Output Implement a function that logs the elapsed time in milliseconds at intervals that increase incrementally.

Для реализации функции, которая выводит прошедшее время в миллисекундах с интервалами, увеличивающимися с каждым вызовом, вы можете использовать рекурсивный подход с setTimeout. Вот пример реализации:
`function extendedPeriodicOutput(initialInterval, increment) {     var startTime = Date.now(); // Получаем текущее время при запуске функции     // Внутренняя функция для вывода прошедшего времени     function logElapsedTime(interval) {         var elapsedTime = Date.now() - startTime; // Вычисляем прошедшее время         console.log('Прошло времени:', elapsedTime, 'миллисекунд');         // Увеличиваем интервал и вызываем logElapsedTime снова через новый интервал         setTimeout(function() {             logElapsedTime(interval + increment);         }, interval);     }     // Запускаем вывод с начальным интервалом     logElapsedTime(initialInterval); } // Пример использования: Вывод прошедшего времени с начальным интервалом 1000 мс и увеличением на 500 мс extendedPeriodicOutput(1000, 500);`
В этой функции:
Мы получаем текущее время с помощью Date.now() при запуске функции.
Функция logElapsedTime выводит прошедшее время и вызывает себя же снова через увеличенный интервал с помощью setTimeout.
Мы начинаем с начальным интервалом и увеличиваем его на величину increment с каждым вызовом.
Этот подход позволяет реализовать функцию с интервалами, которые увеличиваются по мере работы программы.

Working with Promises

### Sequential Promise Execution Write a function to execute an array of functions that return promises sequentially, ensuring each promise resolves before the next begins.

цепляя промисы последовательно, используя рекурсию или метод Array.reduce. Вот пример с использованием Array.reduce:
`function executeSequentially(funcArray) {     return funcArray.reduce(function(promiseChain, currentFunction) {         // Используем Promise.then для привязки текущей функции к концу цепочки         return promiseChain.then(function() {             // Выполняем текущую функцию и возвращаем ее промис             return currentFunction();         });     }, Promise.resolve()); // Начинаем с разрешенного промиса } // Пример использования: function asyncFunction1() {     return new Promise(function(resolve) {         setTimeout(function() {             console.log('Асинхронная Функция 1');             resolve();         }, 1000);     }); } function asyncFunction2() {     return new Promise(function(resolve) {         setTimeout(function() {             console.log('Асинхронная Функция 2');             resolve();         }, 1500);     }); } function asyncFunction3() {     return new Promise(function(resolve) {         setTimeout(function() {             console.log('Асинхронная Функция 3');             resolve();         }, 500);     }); } var funcArray = [asyncFunction1, asyncFunction2, asyncFunction3]; executeSequentially(funcArray);`
Эта функция executeSequentially принимает массив функций, которые возвращают промисы. Она использует Array.reduce для последовательного цепления промисов, гарантируя, что каждый промис разрешится перед тем, как начнется следующий. Promise.resolve() в конце инициализирует цепочку промисов.

### Promise.all Polyfill Implement a function that behaves like Promise.all.

пример полифилла для Promise.all:
```
function promiseAll(polyfillPromises) {
return new Promise(function(resolve, reject) {
if (!Array.isArray(polyfillPromises)) {
reject(new TypeError(‘Arguments must be an array’));
}

```
    var results = [];
    var completedPromises = 0;

    polyfillPromises.forEach(function(promise, index) {
        // Ensure each element in the array is a promise
        Promise.resolve(promise).then(function(result) {
            results[index] = result;
            completedPromises++;
            // If all promises are resolved, resolve the Promise.all
            if (completedPromises === polyfillPromises.length) {
                resolve(results);
            }
        }).catch(function(error) {
            // If any promise is rejected, reject the Promise.all
            reject(error);
        });
    });

    // If the input array is empty, resolve immediately
    if (polyfillPromises.length === 0) {
        resolve(results);
    }
});
```

}
`Эта функция promiseAll принимает массив промисов polyfillPromises и возвращает новый промис. Внутри создается массив для хранения результатов каждого промиса и переменная completedPromises для отслеживания количества завершенных промисов. Затем проходим по каждому промису во входном массиве, используя Promise.resolve для обработки значений и отклонений. Когда все промисы завершены, мы вызываем resolve с массивом результатов. Если хотя бы один промис отклонен, мы вызываем reject с соответствующей ошибкой. Вы можете использовать этот полифилл так же, как и встроенный Promise.all:`
var promise1 = Promise.resolve(‘First’);
var promise2 = Promise.resolve(‘Second’);
var promise3 = Promise.resolve(‘Third’);
promiseAll([promise1, promise2, promise3])
.then(function(results) {
console.log(results); // Output: [‘First’, ‘Second’, ‘Third’]
})
.catch(function(error) {
console.error(error);
});

```

### Race Condition Handling with Promises Create a function to handle race conditions, resolving or rejecting with the value of the first promise that settles.

функция, которая обрабатывает гонку промисов, разрешая или отклоняя с результатом первого промиса, который завершается:
```

function raceConditions(promises) {
return new Promise(function(resolve, reject) {
promises.forEach(function(promise) {
Promise.resolve(promise).then(function(result) {
// Если любой из промисов разрешается, разрешаем промис raceConditions с этим результатом
resolve(result);
}).catch(function(error) {
// Если любой из промисов отклоняется, отклоняем промис raceConditions с этой ошибкой
reject(error);
});
});
});
}
`Эта функция raceConditions принимает массив промисов и возвращает новый промис. Внутри функции мы перебираем каждый промис во входном массиве. Мы используем Promise.resolve, чтобы обработать значения, которые не являются промисами. Когда любой промис разрешается, мы разрешаем промис raceConditions с этим результатом. Если какой-либо промис отклоняется, мы отклоняем промис raceConditions с этой ошибкой. Вы можете использовать эту функцию для обработки гонки промисов следующим образом:`
var promise1 = new Promise(function(resolve) {
setTimeout(function() {
resolve(‘Первый’);
}, 1000);
});
var promise2 = new Promise(function(resolve) {
setTimeout(function() {
resolve(‘Второй’);
}, 500);
});
var promise3 = new Promise(function(_, reject) {
setTimeout(function() {
reject(new Error(‘Третий промис отклонен’));
}, 1500);
});
raceConditions([promise1, promise2, promise3])
.then(function(result) {
console.log(‘Гонка разрешена:’, result); // Вывод: ‘Второй’ (так как он разрешается первым)
})
.catch(function(error) {
console.error(‘Гонка отклонена:’, error); // Вывод: ‘Третий промис отклонен’
});
```
В этом примере функция raceConditions разрешает или отклоняет с результатом первого промиса, который завершается (разрешается или отклоняется).

### Promise Chaining and Error Handling Write a function that handles promise chaining and catches any errors, useful for data fetching scenarios.

функция, которая выполняет цепочку промисов и обрабатывает ошибки:
`function fetchData(url) {     return fetch(url)         .then(response => {             if (!response.ok) {                 throw new Error('Network response was not ok');             }             return response.json();         })         .then(data => {             // Обработка полученных данных             console.log('Received data:', data);             return data;         })         .catch(error => {             // Обработка ошибок             console.error('Error fetching data:', error);             throw error; // Пробрасываем ошибку дальше для дальнейшей обработки         }); }`
Эта функция fetchData отправляет запрос по заданному URL с помощью fetch. Затем она проверяет статус ответа: если он не является успешным (response.ok равен false), функция выбрасывает ошибку. Если запрос проходит успешно, она преобразует ответ в JSON и возвращает его. Если происходит какая-либо ошибка в процессе выполнения цепочки промисов, она перехватывается в блоке catch, выводится сообщение об ошибке и ошибка пробрасывается дальше для дальнейшей обработки.
Вы можете использовать эту функцию для выполнения цепочки промисов для получения данных и обработки возможных ошибок:
`fetchData('https://api.example.com/data')     .then(data => {         // Используем полученные данные         console.log('Data processing:', data);     })     .catch(error => {         // Обрабатываем любые ошибки, возникшие во время выполнения цепочки промисов         console.error('Data fetching error:', error);     });`
В этом примере мы используем fetchData для отправки запроса и обработки данных. Если в процессе выполнения цепочки промисов происходит ошибка, она перехватывается блоком catch и обрабатывается.

### Promisify Node-style Callbacks Convert traditional Node.js callback-style functions to return promises.

В Node.js часто используется стиль обратных вызовов (callback-style), когда функции принимают последним аргументом функцию обратного вызова, которая будет вызвана после завершения операции. Однако, использование промисов вместо обратных вызовов может сделать код более читаемым и управляемым. Давайте напишем функцию, которая преобразует традиционные Node.js функции возвращающие обратные вызовы в функции, возвращающие промисы:
`const util = require('util'); const fs = require('fs'); // Функция, которая преобразует традиционные Node.js функции в промисы function promisify(nodeFunction) {     // Возвращаем новую функцию, которая возвращает промис     return function(...args) {         // Используем утилиту promisify из модуля 'util' для преобразования функции в промис         return new Promise((resolve, reject) => {             // Вызываем оригинальную функцию с аргументами и добавляем обработку результата             nodeFunction.call(this, ...args, (error, data) => {                 if (error) {                     reject(error); // Если возникла ошибка, отклоняем промис                 } else {                     resolve(data); // Если все прошло успешно, разрешаем промис                 }             });         });     }; }`
// Пример использования: преобразование функции чтения файла в промис
const readFilePromise = promisify(fs.readFile);
// Теперь можно использовать функцию readFilePromise, чтобы получить данные из файла в виде промиса
`readFilePromise('example.txt', 'utf8')     .then(data => {         console.log('Data from file:', data);     })     .catch(error => {         console.error('Error reading file:', error);     });`
В этом примере мы создали функцию promisify, которая принимает традиционные Node.js функции, возвращающие обратные вызовы, и возвращает новые функции, возвращающие промисы. Мы используем утилиту util.promisify из модуля util, чтобы автоматически преобразовать функцию в промис. Теперь мы можем использовать readFilePromise, чтобы читать файлы в виде промисов, что делает код более читаемым и удобным для обработки ошибок.