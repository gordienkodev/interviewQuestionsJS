React — это JavaScript-библиотека для создания пользовательских интерфейсов.

для чего нужен

для создания пользовательских интерфейсов, причины выбрать реакт - Переиспользуемость кода, Легкость тестирования, Повышение производительности(вируальный дом), Управление состоянием(через редакси или контекст апи на уровне всего приложения), расширяемость(оширные инструменты), JSX

## What is JSX? Is it possible to use React without JSX?

JSX (JavaScript XML) – это синтаксическое расширение для JavaScript, которое позволяет писать HTML-подобный код внутри JavaScript.

JSX позволяет разработчикам описывать, как должен выглядеть пользовательский интерфейс, используя синтаксис, напоминающий HTML

### Пример с использованием JSX

```jsx
const element = <h1>Привет, мир!</h1>;
```

### Пример без использования JSX

```jsx
const element = React.createElement('h1', null, 'Привет, мир!');
```

В этом примере:

- `React.createElement` — это функция, которая принимает три аргумента: тип элемента (в данном случае `'h1'`), свойства (которые здесь равны `null`), и дочерние элементы (текст `'Привет, мир!'`).
- Метод `React.createElement` возвращает обычный JavaScript-объект, представляющий элемент.

### Пример простого компонента React без JSX

Вот пример простого компонента React, написанного без использования JSX:

```jsx
function MyComponent() {
  return React.createElement('div', { className: 'my-component' },
    React.createElement('h1', null, 'Привет, мир!')
  );
}
```

## Styled-components

Styled Components — это библиотека для React и React Native, которая позволяет вам использовать компоненты для стилизации вашего приложения. Она основана на идее CSS-in-JS, что означает, что вы можете писать CSS-стили прямо в JavaScript файлах.

Например:

```jsx
import styled from 'styled-components';

const Button = styled.button`
  background: blue;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  font-size: 16px;
`;
```

В этом примере создается стилизованный компонент `Button`, который будет выглядеть как кнопка с синим фоном, белым текстом и другими стилями.

1. Вы можете использовать созданные стилизованные компоненты так же, как и обычные React компоненты:
    
    ```jsx
    function App() {
      return (
        <div>
          <Button>Click Me</Button>
        </div>
      );
    }
    ```
    
2. **Пропсы и динамическое изменение стилей**
    
    Вы можете передавать пропсы в стилизованные компоненты для динамического изменения стилей. Например:
    
    ```jsx
    const Button = styled.button`
      background: ${props => props.primary ? 'blue' : 'gray'};
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      font-size: 16px;
    `;
    ```
    
    В этом примере, если проп `primary` установлен в `true`, кнопка будет синей, иначе — серой.
    
3. **Тема**
    
    Styled Components также поддерживает концепцию тем, что позволяет легко управлять глобальными стилями и темами. Вы можете использовать компонент `ThemeProvider` для предоставления темы вашему приложению:
    
    ```jsx
    import { ThemeProvider } from 'styled-components';
    
    const theme = {
      primaryColor: 'blue',
      secondaryColor: 'gray'
    };
    
    function App() {
      return (
        <ThemeProvider theme={theme}>
          <Button>Click Me</Button>
        </ThemeProvider>
      );
    }
    ```
    
    Затем, вы можете использовать тему внутри стилизованных компонентов:
    
    ```jsx
    const Button = styled.button`
      background: ${props => props.theme.primaryColor};
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      font-size: 16px;
    `;
    ```
    

Можно добавлять атрибуты

```jsx
import React from 'react';
import styled from 'styled-components';

// Создаем стилизованный компонент кнопки
const Button = styled.button.attrs({
  type: 'button', // Устанавливаем атрибут type со значением 'button'
})`
  background: blue;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  font-size: 16px;
`;

// Используем компонент
function App() {
  return (
    <div>
      <Button>Click Me</Button>
    </div>
  );
}

export default App;
```

Стилизовать другие компонеты

```jsx
// This could be react-router-dom's Link for example
const Link = ({ className, children }) => (
  <a className={className}>
    {children}
  </a>
);

const StyledLink = styled(Link)`
  color: #BF4F74;
  font-weight: bold;
`;

render(
  <div>
    <Link>Unstyled, boring Link</Link>
    <br />
    <StyledLink>Styled, exciting Link</StyledLink>
  </div>
);
```

**Преимущества Styled Components**

- **Изоляция стилей:** Каждый стилизованный компонент имеет свои собственные стили, что помогает избежать конфликтов между стилями.
- **Динамическое изменение:** Легко менять стили на основе пропсов или тем.
- **Переиспользование:** Компоненты можно переиспользовать в разных частях приложения.
- **Автоматическая генерация уникальных классов:** Библиотека автоматически генерирует уникальные классы для ваших стилей, предотвращая конфликты.

Минусы:

Styled Components увеличивает размер бандла, что может замедлить загрузку страницы. В больших приложениях возможны проблемы с производительностью из-за динамической генерации стилей. Концепция CSS-in-JS может быть непривычной и сложной для восприятия, особенно для разработчиков, привыкших к традиционным методам. Отладка стилей усложняется из-за сгенерированных классов, которые трудно сопоставить с исходным кодом. Интеграция с другими инструментами и библиотеками может быть затруднена, что требует дополнительных настроек. Библиотека тесно связана с React, что делает переход на другие фреймворки сложным.

## Component Definition (Class-based, Functional) Components Сomposition

В React существуют два основных подхода к созданию компонентов: **классовые компоненты** (class-based components) и **функциональные компоненты** (functional components).

**Пример функционального компонента:**

```jsx
const FunctionalComponent = () => {
  return <h1>Hello, world</h1>;
};
```

```jsx
function FunctionalComponent() {
  return <h1>Hello, world</h1>;
}
```

Функциональный компонент — это просто функция, возвращающая JSX.

**Пример классового компонента:**

```jsx
import React, { Component } from "react";
class ClassComponent extends Component {
  render() {
    return <h1>Hello, world</h1>;
  }
}
```

### Передача пропсов

Передача пропсов может быть запутанной, но давайте посмотрим, как они записываются в классовых и функциональных компонентах. Допустим, мы передаем пропсы с именем "Shiori", как в примере ниже.

```jsx
<Component name="Shiori" />
```

В функциональном компоненте пропсы передаются как аргумент функции. Обратите внимание, что здесь используется деструктуризация.

```jsx
const FunctionalComponent = ({ name }) => {
  return <h1>Hello, {name}</h1>;
}
```

Вместо деструктуризации можно также записать так:

```jsx
const FunctionalComponent = (props) => {
  return <h1>Hello, {props.name}</h1>;
};
```

В данном случае вы должны использовать `props.name`, а не просто `name`.

**Пример классового компонента:**

```jsx
class ClassComponent extends React.Component {
  render() {
    const { name } = this.props;
    return <h1>Hello, {name}</h1>;
  }
}
```

### Работа с состоянием

**Работа со состоянием в функциональных компонентах:**

```jsx
const FunctionalComponent = () => {
  const [count, setCount] = React.useState(0);
  return (
    <div>
      <p>count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Click</button>
    </div>
  );
};
```

**Работа со состоянием в классовых компонентах:**

```jsx
class ClassComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }
  render() {
    return (
      <div>
        <p>count: {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click
        </button>
      </div>
    );
  }
}
```

Также можно написать функцию `onClick` отдельно:

```jsx
onClick={() =>
  this.setState((state) => {
    return { count: state.count + 1 };
  })
}
```

### Методы жизненного цикла

 **`componentDidMount`:**

Метод `componentDidMount` вызывается сразу после завершения первого рендеринга.

**Пример функционального компонента:**

```jsx
const FunctionalComponent = () => {
  React.useEffect(() => {
    console.log("Hello");
  }, []);
  return <h1>Hello, World</h1>;
};
```

**Пример классового компонента:**

```jsx
class ClassComponent extends React.Component {
  componentDidMount() {
    console.log("Hello");
  }

  render() {
    return <h1>Hello, World</h1>;
  }
}
```

**`componentWillUnmount`**

```jsx
const FunctionalComponent = () => {
  React.useEffect(() => {
    return () => {
      console.log("Bye");
    };
  }, []);
  return <h1>Bye, World</h1>;
};
```

**Пример классового компонента:**

```jsx
class ClassComponent extends React.Component {
  componentWillUnmount() {
    console.log("Bye");
  }
  render() {
    return <h1>Bye, World</h1>;
  }
}
```

Обработка событий

**Классовые компоненты:**

- Методы обработки событий обычно нужно явно привязывать к контексту компонента с помощью `.bind(this)` в конструкторе или использовать стрелочные функции для автоматической привязки.

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    console.log('Clicked');
  }
  render() {
    return <button onClick={this.handleClick}>Click Me</button>;
  }
}
```

**Функциональные компоненты:**

```jsx
function MyComponent() {
  const handleClick = () => {
    console.log('Clicked');
  };

  return <button onClick={handleClick}>Click Me</button>;
}
```

## React DOM

React DOM — это библиотека, которая является частью экосистемы React и отвечает за взаимодействие React-компонентов с реальным DOM в веб-браузере.

### What is the virtual DOM? How does react use the virtual DOM to render the UI? Что такое Virtual DOM? Что такое виртуальный DOM в React

Virtual DOM (виртуальный документный объект) — это абстракция реального DOM. Это легковесная копия реального DOM-дерева, которая хранится в памяти. Каждый раз, когда состояние приложения изменяется, React создает новый виртуальный DOM, который затем сравнивается с предыдущей версией (процесс, называемый "диффингом").

### Как React использует виртуальный DOM для рендеринга UI?

1. **Создание виртуального DOM**: Когда React-компонент рендерится, создается виртуальное DOM-дерево, представляющее текущее состояние пользовательского интерфейса. Это дерево состоит из JavaScript-объектов, которые описывают элементы интерфейса, их структуру и свойства.
2. **Изменение состояния**: Когда происходит изменение состояния компонента (например, при вызове `this.setState()`), React создает новое виртуальное DOM-дерево, которое отражает обновленное состояние UI. Это новое дерево виртуального DOM отображает, как должен выглядеть интерфейс после изменений.
3. **Diffing (Сравнение)**: React сравнивает новое виртуальное DOM-дерево с предыдущей версией виртуального DOM, чтобы определить, какие части реального DOM необходимо обновить. Этот процесс называется "диффингом" (diffing). React использует алгоритм реконсиляции (reconciliation), который позволяет эффективно находить различия и минимальный набор изменений, необходимых для синхронизации реального DOM с новым виртуальным DOM.
    - **Принципы диффинга:**
        - **Сравнение элементов:** React сначала сравнивает элементы и их свойства, чтобы определить, какие из них изменились.
        - **Оптимизация для списков:** Использование ключей (`key`) для уникальной идентификации элементов списка помогает эффективно отслеживать изменения.
4. **Patch (Применение изменений)**: После нахождения различий React создает "патчи" — набор изменений, которые необходимо внести в реальный DOM. Эти патчи представляют собой минимальный набор операций, необходимых для обновления реального DOM. React применяет только эти изменения, что позволяет сократить количество операций с реальным DOM и улучшить производительность.
    - **Примеры патчей:** Если изменился только текст элемента, патч будет содержать операцию обновления текста этого элемента, а не перерисовку всего компонента.

### Is the virtual DOM the same as the shadow DOM?

Виртуальный DOM и Shadow DOM — это два разных концепта

**Виртуальный DOM** (Virtual DOM) — это концепция, используемая в библиотеках и фреймворках для построения пользовательских интерфейсов, таких как React. Виртуальный DOM представляет собой легковесное, в памяти, описание структуры реального DOM. **Виртуальный DOM**: В React при рендеринге компонента создается виртуальное DOM-дерево. После изменения состояния компонента React сравнивает старое и новое виртуальное DOM и обновляет только те части реального DOM, которые изменились.

**Shadow DOM** – это часть спецификации Web Components. Она позволяет разработчикам создавать инкапсулированные части DOM и стилей, которые не конфликтуют с остальной частью документа. Используется в Агнуляре. Цель - Создание изолированных компонентов, которые не нарушают стили и структуру остального документа. **Shadow DOM**: В веб-компоненте, использующем Shadow DOM, вы можете создать компонент с собственным инкапсулированным стилем и разметкой, который будет выглядеть и функционировать как единое целое, не затрагивая стили других элементов на странице.

### What is the difference between the virtual DOM and the real DOM? Какая разница между виртуальным DOM и реальным DOM?

Виртуальный DOM представляет собой JavaScript-объекты, которые описывают структуру и содержимое интерфейса. Это дерево виртуальных узлов, которое хранится в памяти и отражает текущее состояние UI. 

Реальный DOM представляет собой дерево узлов, где каждый узел соответствует элементу или тексту на странице. Это дерево отражает текущую структуру HTML-документа.

- **Реальный DOM**: Является прямым представлением структуры документа в браузере. Он отражает все элементы и их иерархию.
- **Виртуальный DOM**: Является легковесным описанием реального DOM в памяти. Он предназначен для оптимизации процесса рендеринга и обновления UI.

Изменения сначала происходят в виртуальном DOM, где они сравниваются и оптимизируются. Только необходимые изменения затем применяются к реальному DOM, что значительно ускоряет процесс обновления.

## Render

Функция `render()` в React играет ключевую роль в процессе рендеринга, создавая виртуальное представление компонента. Этот процесс позволяет React эффективно обновлять пользовательский интерфейс, минимизируя операции с реальным DOM и улучшая производительность приложений.

### When is a component rendered? Когда компонент обрабатывается?

Полный жизненный цикл компонента

1. Этап Монтирования (Mounting)

Когда компонент впервые добавляется в DOM, он проходит через следующие методы жизненного цикла:

- **`constructor()`**: Вызывается при создании компонента. Используется для инициализации состояния и привязки методов.
- **`static getDerivedStateFromProps(props, state)`**: Вызывается перед рендерингом. Позволяет обновить состояние на основе новых свойств.
- **`render()`**: Основной метод, который возвращает JSX или `null`. Это и есть процесс рендеринга компонента.
- **`componentDidMount()`**: Вызывается после того, как компонент был добавлен в DOM. Подходит для выполнения побочных эффектов, таких как запросы к API.

**Инфографика для этапа Монтирования:**

2. Этап Обновления (Updating)

Когда состояние или свойства компонента изменяются, компонент обновляется и проходит через следующие методы:

- **`static getDerivedStateFromProps(props, state)`**: Вызывается перед рендерингом при обновлении, позволяет изменять состояние на основе новых свойств.
- **`shouldComponentUpdate(nextProps, nextState)`**: Опционально позволяет оптимизировать рендеринг, предотвращая обновления компонента, если это не требуется.
- **`render()`**: Вызывается для обновления представления компонента.
- **`getSnapshotBeforeUpdate(prevProps, prevState)`**: Опционально вызывается непосредственно перед обновлением реального DOM. Позволяет захватить состояние перед изменением.
- **`componentDidUpdate(prevProps, prevState, snapshot)`**: Вызывается после обновления компонента. Позволяет выполнять действия после обновления, такие как запросы к API.

3. Этап Размонтирования (Unmounting)

Когда компонент удаляется из DOM, он проходит через следующий метод:

- **`componentWillUnmount()`**: Вызывается перед удалением компонента из DOM. Используется для очистки ресурсов, таких как таймеры или подписки.

### How not to render on props change? Как избежать рендеринга при изменении свойств (props)?

- **`shouldComponentUpdate`** для классовых компонентов.
- **`React.PureComponent`** для автоматической оптимизации классовых компонентов.

- **`React.memo`** и пользовательская функция сравнения для функциональных компонентов.
- **`useMemo`** для кэширования вычисленных данных в функциональных компонентах.

В функциональных компонентах можно использовать `React.memo`, чтобы предотвратить перерисовку компонента, если свойства не изменились.

```jsx
const MyComponent = React.memo(({ data }) => {
  console.log('Rendered');
  return <div>{data}</div>;
});

export default MyComponent;
```

**Принцип работы**: `React.memo` проверяет изменения в свойствах компонента и предотвращает повторный рендеринг, если свойства не изменились.

**Кэширование данных `useMemo`**

Если изменение свойств приводит к перерасчету каких-либо данных, используйте кэширование для предотвращения лишних вычислений и рендеринга. В функциональных компонентах можно использовать хук `useMemo` для этого.

```jsx
import React, { useMemo, useCallback, useState } from 'react';

const ExpensiveComponent = ({ data, onClick }) => {
  console.log("ExpensiveComponent rendered");
  return <button onClick={onClick}>Click me</button>;
};

function App() {
  const [count, setCount] = useState(0);

  const data = useMemo(() => calculateExpensiveValue(count), [count]);
  const handleClick = useCallback(() => setCount(c => c + 1), []);

  return (
    <ExpensiveComponent data={data} onClick={handleClick} />
  );
}
```

**Принцип работы**: `useMemo` кеширует результат вычислений и повторно использует его, если зависимости не изменились. `useCallback` используется для мемоизации функции `handleClick`, чтобы предотвратить её создание заново при каждом рендере компонента `App`. 
В данном случае массив зависимостей пустой (`[]`), что означает, что `handleClick` будет создана только один раз, когда компонент `App` рендерится впервые.

### Is it OK to use arrow functions in render methods? Можно ли использовать функции стрелки в методах rendering?

Использование стрелочных функций в методе `render` возможно, но рекомендуется учитывать влияние на производительность и по возможности оптимизировать код.

**Пример использования стрелочной функции в рендере**

В этом примере мы используем стрелочную функцию для обработки клика на кнопке прямо в рендере:

```jsx
import React from 'react';
const MyComponent = () => {
  return (
    <div>
      <button onClick={() => alert('Button clicked!')}>Click me</button>
    </div>
  );
};
export default MyComponent;
```

**Оптимизация с использованием `useCallback`**

При каждом рендере компонента создается новая стрелочная функция для обработчика клика. Если у вас есть компоненты-потомки, которые зависят от функции обработчика (например, через пропсы), это может вызвать лишние перерисовки.

Вот как можно оптимизировать этот код, используя `useCallback`:

```jsx
import React, { useCallback } from 'react';
const MyComponent = () => {
  // Мемоизируем функцию с помощью useCallback
  const handleClick = useCallback(() => {
    alert('Button clicked!');
  }, []); // Пустой массив зависимостей означает, что функция не будет пересоздаваться
  return (
    <div>
      <button onClick={handleClick}>Click me</button>
    </div>
  );
};
export default MyComponent;

```

Почему это важно

1. **Производительность**: Использование `useCallback` помогает избежать создания новой функции при каждом рендере компонента, что может улучшить производительность, особенно если функция передается в дочерние компоненты.
2. **Ссылочная идентичность**: Если функция передается в другие компоненты или используется в зависимости от `useEffect`, то изменение функции без `useCallback` может вызвать ненужные перерисовки.

### Components rendering system Система отображения компонентов

основные этапы рендеринга компонентов в React:

1. **Создание Компонентов**

- **Компоненты** определяются как функции или классы, которые возвращают JSX или ReactElement. Эти компоненты описывают, как должен выглядеть пользовательский интерфейс в зависимости от состояния и свойств.

2. **Инициализация и Вставка в DOM**

- **Первичное Рендеринг**: Когда вы вызываете `ReactDOM.render`, React создаёт начальное дерево VirtualDOM на основе корневого компонента и вставляет его в реальный DOM.

3. **Создание VirtualDOM**

- **VirtualDOM**: При первом рендеринге React создает объект VirtualDOM, представляющий текущее состояние UI. Этот объект является легковесной, виртуальной репрезентацией реального DOM.

4. **Обновления Состояния и Свойств**

- **Изменения**: Когда происходит изменение состояния (`setState`) или свойств (`props`), React создает новое VirtualDOM, отражающее эти изменения.

5. **Реконсиляция (Сравнение и Обновление)**

- **Сравнение VirtualDOM**: React сравнивает новый VirtualDOM с предыдущим. Это сравнение происходит в два этапа:
    - **Сравнение на Уровне Компонентов**: Если тип компонента изменился, React заменяет старый элемент новым и игнорирует его дочерние элементы.
    - **Сравнение на Уровне Элементов**: React сравнивает дочерние элементы, используя ключи (keys) для эффективного отслеживания изменений в списках.
- **Поиск Изменений**: React определяет, какие части VirtualDOM изменились по сравнению с предыдущим состоянием, и какие изменения нужно внести в реальный DOM.

6. **Обновление Реального DOM**

- **Пакетирование Изменений**: React группирует изменения и обновляет реальный DOM в одном или нескольких пакетах, чтобы минимизировать количество дорогостоящих операций с DOM.
- **Применение Изменений**: Реальные изменения в DOM наносятся на основе того, что было определено на этапе реконсиляции.

7. **Очистка и Размонтирование**

- **Очистка**: При удалении компонентов React также обновляет VirtualDOM и реальный DOM, чтобы удалить ненужные элементы.
- **Размонтирование**: React вызывает методы очистки, такие как `componentWillUnmount`, если компонент удаляется из UI.

8. **Актуализация**

- **Оптимизации**: React может применять различные оптимизации для минимизации работы с DOM, такие как `React.memo` и `shouldComponentUpdate`, чтобы предотвратить ненужные рендеринги.

## **Interaction between components**

### How do you pass a value from parent to child? Как передать значение от родителя к ребенку?

Props — это механизм в React, который позволяет передавать данные от родительского компонента к дочерним. 

### Как Передать Значение в Виде Props

1. **Определите Значение в Родительском Компоненте:**
Создайте переменную или состояние в родительском компоненте, которое хранит значение, которое вы хотите передать.
2. **Передайте Значение как Prop:**
Когда вы рендерите дочерний компонент внутри родительского компонента, вы передаете значение как атрибут. Например:
    
    ```jsx
    // Родительский Компонент
    function ParentComponent() {
      const message = "Привет от Родителя!";
      return (
        <div>
          <ChildComponent greeting={message} />
        </div>
      );
    }
    // Дочерний Компонент
    function ChildComponent(props) {
      return <p>{props.greeting}</p>;
    }
    ```
    
    В этом примере `message` передается в `ChildComponent` как prop с именем `greeting`.
    

### How do you pass a value from child to parent? Как передать значение от ребенка родительскому?

Чтобы передать значение от дочернего компонента к родительскому в React, можно использовать функцию, переданную из родительского компонента. Вот основные шаги, как это сделать:

1. **Создание функции в родительском компоненте:**
Родительский компонент создает функцию, которая будет обновлять состояние или обрабатывать данные, переданные из дочернего компонента.
    
    ```jsx
    // Родительский компонент
    import React, { useState } from 'react';
    import Child from './Child';
    function Parent() {
      const [value, setValue] = useState('');
      const handleValueChange = (newValue) => {
        setValue(newValue);
      };
      return (
        <div>
          <h1>Value from child: {value}</h1>
          <Child onValueChange={handleValueChange} />
        </div>
      );
    }
    export default Parent;
    ```
    
2. **Передача функции в дочерний компонент:**
Родительский компонент передает эту функцию дочернему компоненту через пропсы.
    
    ```jsx
    // Дочерний компонент
    import React, { useState } from 'react';
    
    function Child({ onValueChange }) {
      const [inputValue, setInputValue] = useState('');
      const handleChange = (e) => {
        setInputValue(e.target.value);
        onValueChange(e.target.value); // Вызов функции для передачи значения родителю
      };
      return (
        <input type="text" value={inputValue} onChange={handleChange} />
      );
    }
    export default Child;
    ```
    
3. **Использование переданного значения:**
Дочерний компонент вызывает функцию, переданную через пропсы, чтобы отправить данные родительскому компоненту.

### What is prop drilling? **передача некоторых пропсов на множество уровней вниз**

Проп-дриллинг (prop drilling) — это практика передачи пропсов от одного компонента к другому, который не использует эти данные, а только передает их дальше. Это может происходить на несколько уровней, что делает код сложно понимаемым и поддерживаемым. Проп-дриллинг часто становится проблемой, когда нужно передать данные через множество компонентов, например, настройки локали, тему или данные пользователя.

Проп-дриллинг не является самой плохой практикой, но его использование может привести к трудностям в поддержке кода. Существуют более элегантные и поддерживаемые подходы, такие как создание композитных компонентов или использование React Context. Однако и у этих решений есть свои ограничения.

🔑 Проп-дриллинг происходит, когда пропс передается более чем двум компонентам глубоко, а промежуточный компонент не использует эти данные сам, а просто передает их дальше.

Вот пример на React:

В этом примере данные передаются от компонента `Parent` через `Child1` и `Child2` к `Child3`. Это и есть **prop drilling**.

Вот пример на React:

```jsx
// Родительский компонент
function Parent() {
  const data = 'Hello, World!';
  return (
    <Child1 data={data} />
  );
}
// Дочерний компонент 1
function Child1({ data }) {
  return (
    <Child2 data={data} />
  );
}
// Дочерний компонент 2
function Child2({ data }) {
  return (
    <Child3 data={data} />
  );
}
// Дочерний компонент 3
function Child3({ data }) {
  return (
    <div>{data}</div>
  );
}
```

В этом примере данные передаются от компонента `Parent` через `Child1` и `Child2` к `Child3`. Это и есть **prop drilling**.

### Can a child component modify its own props? Может ли дочерний компонент изменять свои собственные реквизиты?

- **Props (Свойства)**: Это данные, которые передаются от родительского компонента к дочернему. Они являются неизменяемыми внутри дочернего компонента, что означает, что дочерний компонент не должен изменять свои собственные `props`. `Props` предназначены только для чтения. Изменять их можно только в родительском компоненте, который их передал.
- **State (Состояние)**: Это данные, которые управляются внутри компонента и могут изменяться. Состояние используется для хранения информации, которая может изменяться с течением времени и которая влияет на рендеринг компонента.

### Почему нельзя изменять Props в дочернем компоненте?

Props принадлежат родительскому компоненту. Дочерний компонент получает их как неизменяемые данные. Попытка изменить `props` в дочернем компоненте может привести к следующим проблемам:

1. **Непредсказуемое поведение**: Если дочерний компонент начнет изменять `props`, это может привести к неожиданным результатам и трудностям в отладке. Компоненты могут стать сложными для понимания и управления, так как изменение `props` не предусмотрено в концепции однонаправленного потока данных в React.
2. **Неуправляемое состояние**: Если дочерний компонент пытается изменить `props`, это нарушает принцип однонаправленного потока данных и может привести к сложным для отслеживания ошибкам.

### How do you pass a value from sibling to sibling? Как передать значение от родственника к родственнику?

В React, передача данных между "братьями" (составными компонентами, которые имеют общего родителя) может быть реализована с помощью "поднятия состояния" (lifting state up). Вот как это работает:

1. **Создайте общее состояние в родительском компоненте:**
В родительском компоненте, который является общим для двух "братьев", создайте состояние, которое будет хранить значение, которое вы хотите передать между ними.
    
    ```jsx
    import React, { useState } from 'react';
    import SiblingA from './SiblingA';
    import SiblingB from './SiblingB';
    function ParentComponent() {
      const [sharedValue, setSharedValue] = useState('');
      return (
        <div>
          <SiblingA value={sharedValue} setValue={setSharedValue} />
          <SiblingB value={sharedValue} />
        </div>
      );
    }
    export default ParentComponent;
    ```
    
2. **Передайте состояние и функцию для его изменения в дочерние компоненты:**
В данном случае `SiblingA` получает текущее значение состояния и функцию для его обновления, тогда как `SiblingB` получает только значение.
    
    ```jsx
    // SiblingA.jsx
    function SiblingA({ value, setValue }) {
      const handleChange = (event) => {
        setValue(event.target.value);
      };
      return (
        <div>
          <input type="text" value={value} onChange={handleChange} />
        </div>
      );
    }
    export default SiblingA;
    
    // SiblingB.jsx
    function SiblingB({ value }) {
      return (
        <div>
          <p>Received Value: {value}</p>
        </div>
      );
    }
    export default SiblingB;
    ```
    

**Объяснение:**

- **Родительский компонент** хранит состояние (`sharedValue`) и функцию для его изменения (`setSharedValue`).
- **SiblingA** может изменять это состояние с помощью `setValue`, а **SiblingB** получает это значение и может его отображать или использовать по своему усмотрению.

Такой подход позволяет вам централизованно управлять состоянием и передавать его между "братьями" через их общего родителя.

## **Lifecycle and State**

### What is the difference between props and state? В чем разница между пропсом и стейтом?

 
How does state in a class component differ from state in a functional component?
What is the component lifecycle?
How do you update lifecycle in function components? Controlled/uncontrolled components Statefull vs stateless components

Ref
What is the difference between refs and state variables?
When is the best time to use refs?
What is the proper way to update a ref in a function component?

Context
What is the difference between the context API and prop drilling?
When shouldn't you use the context API?

Redux
Enumerate base principles
What is the typical flow of data in a React + Redux app?
Benefits of Redux? Async Redux flow

State Management by managers
Mobx Reflux

Routing
React Router History

Other
Is it a good idea to use Math.random for keys?
What are the limitations of React?
What is a higher order component?
What are uncontrolled and controlled components?
React optimizations

Coding task
Small react app: form, button, results list

### 

## Какие есть state менеджеры?

State менеджеры — это инструменты, которые помогают управлять состоянием в приложениях, особенно когда оно становится сложным. Они могут быть особенно полезны в больших приложениях, где управление состоянием становится трудоемким. Вот краткий обзор популярных state менеджеров, а также объяснение, зачем они нужны и можно ли обойтись без них.

### Популярные State Менеджеры

1. **Redux**
    - **Описание**: Централизованное хранилище состояния с помощью редукторов и actions.
    - **Особенности**: Предлагает возможность использования middleware, таких как redux-thunk или redux-saga, для обработки асинхронных действий.
    - **Когда использовать**: Для крупных приложений с сложной бизнес-логикой и большим количеством компонентов.
2. **MobX**
    - **Описание**: Реактивное состояние с использованием observables. Прост в использовании и интеграции.
    - **Особенности**: Поддержка реактивного программирования и простой синтаксис для управления состоянием.
    - **Когда использовать**: Когда требуется простота в управлении состоянием и реактивность, особенно для небольших и средних проектов.
3. **Recoil**
    - **Описание**: Новый state менеджер от Facebook, поддерживающий атомы и селекторы для управления состоянием.
    - **Особенности**: Простота интеграции с React и поддержка асинхронных операций.
    - **Когда использовать**: Для современных React-приложений, где требуется гибкость и масштабируемость.
4. **Zustand**
    - **Описание**: Легковесный state менеджер с простым API.
    - **Особенности**: Минимум boilerplate-кода и простой хук для доступа к состоянию.
    - **Когда использовать**: Для небольших и средних приложений, где требуется простота и скорость.
5. **XState**
    - **Описание**: Управление состоянием с использованием конечных автоматов и стейтов.
    - **Особенности**: Поддержка сложных состояний и процессов с явным управлением переходами.
    - **Когда использовать**: Для приложений с сложной логикой состояний и процессами, требующими четкого определения состояний.
6. **React Context API**
    - **Описание**: Встроенный механизм React для управления состоянием на уровне дерева компонентов.
    - **Особенности**: Хорош для передачи состояния через несколько уровней компонентного дерева.
    - **Когда использовать**: Для управления глобальным состоянием в небольших и средних приложениях.

### Зачем нужны State Менеджеры?

1. **Управление сложностью**:
    - В больших приложениях состояние может быть распределено по множеству компонентов, что затрудняет его управление. State менеджеры помогают централизовать состояние и упрощают его обновление.
2. **Обработка асинхронных операций**:
    - State менеджеры, такие как Redux с redux-thunk или redux-saga, помогают эффективно управлять асинхронными действиями (например, запросами к серверу).
3. **Поддержка и тестирование**:
    - Четко структурированное состояние упрощает тестирование и поддержку кода. State менеджеры часто предоставляют инструменты и паттерны для упрощения тестирования.
4. **Изменения состояния**:
    - Управление изменениями состояния становится более предсказуемым и контролируемым. State менеджеры обеспечивают единую точку для обработки изменений состояния.
5. **Переиспользуемость**:
    - Управление состоянием в централизованном хранилище облегчает переиспользование логики в различных частях приложения.

### Можно ли обойтись без State Менеджеров?

**Да, можно.** В небольших приложениях или тех, которые имеют простую логику состояния, возможно обойтись без дополнительных state менеджеров. React сам по себе предоставляет возможности для управления состоянием с помощью локального состояния компонентов и Context API. Вот когда можно обойтись без state менеджеров:

1. **Маленькие или простые приложения**:
    - Если ваше приложение не имеет сложной логики состояния, может быть достаточно использовать локальное состояние и Context API.
2. **Когда управление состоянием не становится сложным**:
    - Если количество компонентов невелико и состояние не требует сложных манипуляций, то использование встроенных механизмов React может быть вполне достаточным.
3. **Упрощение кода**:
    - В некоторых случаях использование дополнительных state менеджеров может добавить избыточность в код. Простые проекты могут выигрывать от использования встроенных средств React.

## 1. **React Context API**

**Пример использования:**

```jsx
// Создание контекста
const ThemeContext = React.createContext('light');

// Компонент-поставщик
function ThemeProvider({ children }) {
  const [theme, setTheme] = React.useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Компонент-потребитель
function ThemedComponent() {
  const { theme, setTheme } = React.useContext(ThemeContext);

  return (
    <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#000' : '#fff' }}>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>Toggle Theme</button>
    </div>
  );
}
```

### 2. **Redux**

Редакс
Что такое
Как решить что лучше подходит Контекст Апи или редакс
Что такое редакс стор
что такое экшоны
что такое экшон криейторы
что такое редьюсеры
как осуществляется управление между ними
что делает фунция коннект
что делает мапстейтто пропс и  мапдиспатчтопровс
почему мы должны отправлять действия на обновления состояния а не обновлять хранилище напрямую
почему в редукторе надо возвращать новый объект а не обновлять текущий

**Пример использования:**

```jsx
// actions.js
export const increment = () => ({ type: 'INCREMENT' });

// reducers.js
const counter = (state = 0, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    default:
      return state;
  }
};

// store.js
import { createStore } from 'redux';
import counter from './reducers';

const store = createStore(counter);

// App.js
import { Provider, useSelector, useDispatch } from 'react-redux';
import { increment } from './actions';

function App() {
  const count = useSelector(state => state);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>Increment</button>
    </div>
  );
}

export default function Root() {
  return (
    <Provider store={store}>
      <App />
    </Provider>
  );
}
```

### 3. **MobX**

**Пример использования:**

```jsx
// store.js
import { makeAutoObservable } from 'mobx';

class CounterStore {
  count = 0;

  constructor() {
    makeAutoObservable(this);
  }

  increment() {
    this.count++;
  }
}

export const counterStore = new CounterStore();

// App.js
import React from 'react';
import { observer } from 'mobx-react';
import { counterStore } from './store';

const App = observer(() => (
  <div>
    <p>Count: {counterStore.count}</p>
    <button onClick={() => counterStore.increment()}>Increment</button>
  </div>
));

export default App;
```

### 4. **Recoil**

**Пример использования:**

```jsx
// store.js
import { atom, selector, useRecoilState } from 'recoil';

export const countState = atom({
  key: 'countState',
  default: 0,
});

export const doubleCountState = selector({
  key: 'doubleCountState',
  get: ({ get }) => {
    const count = get(countState);
    return count * 2;
  },
});

// App.js
import React from 'react';
import { useRecoilState, useRecoilValue } from 'recoil';
import { countState, doubleCountState } from './store';

function App() {
  const [count, setCount] = useRecoilState(countState);
  const doubleCount = useRecoilValue(doubleCountState);

  return (
    <div>
      <p>Count: {count}</p>
      <p>Double Count: {doubleCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default App;
```

### 5. **Zustand**

**Пример использования:**

```jsx
import create from 'zustand';

// store.js
const useStore = create(set => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 })),
}));

// App.js
import React from 'react';
import { useStore } from './store';

function App() {
  const { count, increment } = useStore();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

export default App;
```

### 6. **XState**

**Пример использования:**

```jsx
import { createMachine, interpret } from 'xstate';
import { useMachine } from '@xstate/react';

// machine.js
const counterMachine = createMachine({
  id: 'counter',
  initial: 'inactive',
  states: {
    inactive: {
      on: { START: 'active' }
    },
    active: {
      on: { INCREMENT: 'incremented' }
    },
    incremented: {
      on: { RESET: 'inactive' }
    }
  }
});

// App.js
import React from 'react';
import { useMachine } from '@xstate/react';
import { counterMachine } from './machine';

function App() {
  const [state, send] = useMachine(counterMachine);
  return (
    <div>
      <p>Current state: {state.value}</p>
      <button onClick={() => send('START')}>Start</button>
      <button onClick={() => send('INCREMENT')}>Increment</button>
      <button onClick={() => send('RESET')}>Reset</button>
    </div>
  );
}

export default App;
```

Выбор подходящего state менеджера зависит от сложности вашего приложения, ваших требований к функциональности и предпочтений по синтаксису и структуре. **React Context API** подходит для простых случаев и небольших приложений, **Redux** и **MobX** предлагают мощные возможности для крупных приложений, **Recoil** и **Zustand** предоставляют современные и гибкие решения, а **XState** помогает управлять сложными состояниями и процессами.

### Какие хуки могут оптимизировать React?

В React существует несколько хуков, которые могут быть использованы для оптимизации компонентов и улучшения производительности приложения. Ниже перечислены некоторые из таких хуков:
useMemo:
Хук useMemo используется для мемоизации (кэширования) результатов дорогостоящих вычислений.
Он принимает функцию и массив зависимостей и возвращает закэшированное значение, которое будет пересчитано только при изменении зависимостей.
useCallback:
useCallback мемоизирует колбэк-функции, предотвращая их пересоздание при каждом рендере компонента.
Это особенно полезно, когда колбэк используется в качестве зависимости для других хуков, чтобы избежать лишних повторных рендеров.
useEffect:
useEffect позволяет выполнять побочные эффекты в функциональных компонентах, например, подписку на внешние данные или обновление DOM.
Определенное использование useEffect может помочь избежать побочных эффектов и неопределенного поведения.

Бесконечный цикл в `useEffect`

React.memo:
React.memo - это функция высшего порядка, которая мемоизирует компоненты на основе их пропсов.
Это предотвращает ненужные повторные рендеры компонентов, если их пропсы не изменились.
useRef:
useRef позволяет сохранять мутабельное значение между рендерами без вызова повторного рендера компонента.
Это может быть полезно для сохранения мутабельных данных или для обращения к DOM-элементам напрямую.
Использование этих хуков помогает уменьшить ненужные повторные рендеры, улучшая производительность React-приложений. Важно применять их с умом в зависимости от конкретных требований и контекста приложения.

В React существует множество способов работы с API, каждый из которых имеет свои особенности и преимущества:

- **Fetch API** — простой встроенный метод.
- **Axios** — мощная библиотека с удобным API.
- **React Query** — для управления состоянием данных и кеширования.
- **SWR** — для фетчинга данных с кешированием и обновлением.
- **RTK Query** — интеграция с Redux Toolkit для управления запросами.

## Метод `OPTIONS`

Метод `OPTIONS` в HTTP используется для запроса информации о поддерживаемых методах HTTP для определённого ресурса или сервера. Это особенно полезно в контексте кросс-доменных запросов и работы с CORS (Cross-Origin Resource Sharing).

### Основные аспекты метода `OPTIONS`:

1. **Назначение метода `OPTIONS`**
    
    Метод `OPTIONS` позволяет клиенту узнать, какие HTTP-методы поддерживает сервер для указанного ресурса. Он не используется для получения данных или отправки данных, а для получения информации о серверных возможностях и разрешениях.
    
2. **Использование в CORS**
    
    Метод `OPTIONS` часто используется в запросах, которые включают предварительную проверку CORS (preflight request). Когда веб-приложение делает запрос к другому домену с использованием нестандартных HTTP-методов (например, `PUT` или `DELETE`) или нестандартных заголовков, браузер сначала отправляет запрос `OPTIONS` на сервер для проверки, разрешает ли он такой запрос.
    
3. **Ответ на запрос `OPTIONS`**
    
    Ответ на запрос `OPTIONS` содержит заголовки, которые указывают, какие методы разрешены для ресурса. Это может включать заголовки такие как `Allow` и `Access-Control-Allow-Methods`.
    

### Пример запроса и ответа `OPTIONS`

**Пример запроса `OPTIONS`:**

```
OPTIONS /resource HTTP/1.1
Host: example.com
Origin: http://anotherdomain.com
Access-Control-Request-Method: POS
```

**Пример ответа `OPTIONS`:**

```
HTTP/1.1 204 No Content
Allow: GET, POST, OPTIONS
Access-Control-Allow-Origin: http://anotherdomain.com
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Content-Type
```

В этом примере:

- `Allow` указывает, какие методы разрешены для ресурса.
- `Access-Control-Allow-Methods` указывает, какие методы разрешены для кросс-доменных запросов.
- `Access-Control-Allow-Origin` указывает, какие домены могут получить доступ к ресурсу.

### Применение в React и фронтенд-разработке

В React и других фронтенд-фреймворках вы, как правило, не взаимодействуете с методом `OPTIONS` напрямую, поскольку он обрабатывается браузером и сервером. Однако, понимание этого метода может быть полезным при настройке CORS на сервере или при отладке кросс-доменных запросов.

### Как настроить CORS на сервере

Чтобы сервер корректно обрабатывал запросы `OPTIONS` и соответствующим образом настраивал CORS, можно использовать следующие методы в разных серверных средах:

- **Node.js с Express:**
    
    ```jsx
    const express = require('express');
    const app = express();
    const cors = require('cors');
    
    // Использование middleware для обработки CORS
    app.use(cors());
    
    // Обработка запроса OPTIONS
    app.options('*', cors());
    
    app.get('/resource', (req, res) => {
      res.send('Resource');
    });
    
    app.listen(3000, () => {
      console.log('Server running on port 3000');
    });
    ```
    

Библиотеки для стилей для реакта в чем отличия особенности

вопросы база

Условный рендеринг (Conditional Rendering)
Рендеринг списков (List Rendering), на сколько важно иметь ключ для списка элементов
ошибки при использования индекса в качестве ключа в List Rendering
Методы жизненного цикла компонентов класса - этап монтирования, обновления, размонтирования и порядок вызова
Контекст Апи, как поможет против проп дриллинг
Хуки, зачем нужны
Юзстейт, юзеЕффект, юзКонтекст как они связаны компонентами класса
Чистые компоненты
Мемо
ЮзМемо и юзКаллбек
Как распределять логику между компонентами (компоненты высшего порядка, шаблонах рендеринга пропсов(Render props pattern), Кастомных хуках)
какие пакеты использовать вместе с реакт - стилизация, роутинг, обработка форм, стейт менеджмент

задачи на реакте:
компонент отрефакторить (мемо юзколбеки)
неработающий код потеря конеткста
счетчик не отчищается
компонент классовый переписать на функциональный
создать кастомный хук
оптимизация компонентов

## **Next.js Interview Questions**

General Questions:
What is Next.js, and how does it differ from traditional React applications?

Explain the concept of server-side rendering (SSR) in Next.js

How does Next.js handle client-side routing?

What are the benefits of using Next.js for building React applications?

What is the purpose of the getInitialProps function in Next.js? How is it different from using getStaticProps or getServerSideProps?

How does Next.js handle automatic code splitting, and why is it important?

What is the purpose of the Link component in Next.js, and how does it differ from traditional anchor (<a>) tags?

How can you configure routing in a Next.js application?

Data Fetching:
Compare and contrast getStaticProps and getServerSideProps in terms of use cases and performance considerations

When would you choose to use getStaticPaths in Next.js, and how does it relate to dynamic routes?

Advanced Topics:
Describe the purpose and use cases of API routes in Next.js

Explain the concept of middleware in Next.js and its role in the application lifecycle

How does Next.js handle authentication in applications?
