Парадигма программирования, которая стремится организовать программу в виде взаимодействующих объектов, каждый из которых представляет собой экземпляр определенного класса. Основные принципы ООП помогают создавать программы, которые легко понимать, изменять и поддерживать.
Инкапсуляция Объединение данных и методов в один объект и защита внутреннего состояния объекта от других воздействий. Пользователь должен видеть только список декларируемых свойств и методов и не вникать во внутренную реализацию. Пример инкапсуляции? Если у нас есть класс, который представляет кошелек с деньгами. Например у него будут два метода позволяющие просматривать количество денег и изменять его. Кошелек может хранить отрицательное количество денег. Для инкапсуляции нам нужно добавить методы: Добавить деньги если это положительное число, взять деньги, если это положительное число и количество денег не больше того что в кошельке. Таким образом мы не сможем потратить денег больше чем имеется и сумма в кошельке не будет отрицательной. Наследование Зависимость и отношение, один класс - продолжение другого. Инструмент позволяет избежать дублирования кода и позволяет реализовать полиморфизм. Пример наследования Например есть класс Человека с именем и фамилией и методом вывода кода на экран. Сделаем класс студент, который будет наследовать все поля и методы класса Человек. В новый класс студент мы можем добавить новый функционал, например метод Учиться. Мы так же можем переопределить работу методов базового класса. Полиморфизм (полиморфизм подтипов) Возможность использовать классы потомки в том же контексте что и базовый класс. Пример полиморфизма? Если у нас есть класс Машина и он имеет метод Управлять. У нас есть класс Человек и у него есть тоже метод Управлять, который принимает объект класса Машина, и у этого объекта мы вызываем метод Управлять. Мы можем добавить наследника Спортивная машина, в базовом классе метод Управлять мы сделаем виртуальным virtual и в классе наследнике добавим override метод Управлять, где мы реализуем возможность управления спортивной машиной. И в зависимости от того какой класс мы передадим человеку в методе Управления, реализуется логика - для обычный или спортивной машины. При этом мы никаким образом не меняем класс Человека в этом и заключается суть полиморфизма. 

**Абстракция**:

- Абстракция заключается в выделении наиболее значимых характеристик объекта и игнорировании несущественных деталей. Это позволяет моделировать сложные системы путем создания упрощенных представлений реальных объектов.

Пример абстракции? 
Представим, что мы разрабатываем систему для управления банковскими аккаунтами. Вместо того, чтобы моделировать все детали каждого типа аккаунта, мы создадим абстрактный класс `Account`, который будет содержать основные характеристики и методы, общие для всех типов аккаунтов.

**Чем отличается класс от абстрактного класса?
Абстрактный класс? зачем нужны?**
Абстрактный класс это некая идея, описание контракта с возможной частичной реализацией в наследниках класса. Нечто абстрактное которое должно делать что-то разными способами. В абстрактном классе можно указать астрактный метод без реализации. Так же можно указать конкретную реализацию - метод. Все наследуемые классы могут использовать этот метод. Другой класс в методах может использовать в качестве параметра объект типа нашего абстрактного класса, тогда любой объект который унаследован из астрактного класса может передаваться в качестве параметра. Наследники обязаны реализовать метод от абстрактного класса(override - для переопределения абстрактного метода).
Применение основных принципов ООП помогает создавать модульные, гибкие и масштабируемые программы, которые легко поддерживать и расширять. Эти принципы способствуют повышению производительности разработчика и качества программного обеспечения в целом.

Creational паттерны занимаются процессом создания объектов. Они обеспечивают гибкость в создании экземпляров объектов, сокрытие сложностей и зависимостей.
Примеры:
Factory Method (Фабричный метод): Определяет интерфейс для создания объекта, но позволяет субклассам выбрать класс для создания. Пример: классический пример - DocumentFactory, который позволяет создавать различные типы документов (текстовый документ, таблицу, презентацию и т. д.).

Structural паттерны занимаются композицией объектов и управлением отношениями между ними. Они помогают создавать более гибкую и эффективную структуру программы.
Примеры:
Adapter (Адаптер): Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом. Пример: адаптер для работы с различными системами баз данных.
Decorator (Декоратор): Динамически добавляет новую функциональность объекту без изменения его интерфейса. Пример: добавление дополнительных функций к объекту File для его шифрования или сжатия.
Composite (Компоновщик): Позволяет сгруппировать объекты в древовидную структуру для обработки композиции объектов как единого объекта. Пример: создание структуры дерева для файловой системы.

Behavioral паттерны занимаются взаимодействием объектов и распределением обязанностей между ними. Они позволяют управлять потоком данных и обеспечивать эффективное взаимодействие между объектами.
Примеры:
Observer (Наблюдатель): Определяет зависимость один ко многим между объектами таким образом, что при изменении состояния одного объекта все зависящие от него объекты автоматически оповещаются и обновляются. Пример: использование паттерна Observer в GUI-фреймворках для обновления интерфейса при изменении данных.
Strategy (Стратегия): Определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. Пример: использование различных стратегий для сортировки массивов (быстрая сортировка, сортировка пузырьком, сортировка вставками и т. д.).
Command (Команда): Инкапсулирует запрос как объект, позволяя передавать запросы как аргументы, сохранять их в стеке, отменять или повторять. Пример: использование паттерна Команда для реализации истории действий в редакторе текста.

Принцип SRP гласит, что каждый класс, метод и функция должны выполнять только одну задачу или иметь только одну причину для изменения. Это помогает упростить понимание и поддержку кода.

**Пример в проекте:** Разделение классов на уровни доступа к данным, бизнес-логику и отображение для управления изменениями и развитием приложения.

**Паттерны, соответствующие SRP:**

- **Фабрика (Factory)**
- **Одиночка (Singleton)**
- **Стратегия (Strategy)**

### Принцип открытости/закрытости (Open/Closed Principle - OCP)

Принцип OCP утверждает, что классы должны быть открыты для расширения, но закрыты для изменения. Это означает, что поведение класса должно изменяться без изменения его исходного кода.

**Пример в проекте:** Использование интерфейсов или абстрактных классов для определения базового поведения, а затем создание конкретных реализаций, которые могут быть добавлены без изменения основного кода.

**Паттерны, соответствующие OCP:**

- **Фабричный метод (Factory Method)**
- **Декоратор (Decorator)**
- **Стратегия (Strategy)**

### Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP)

Принцип LSP гласит, что объекты в программе должны быть заменяемыми экземплярами их базовых типов без нарушения корректности программы. Это обеспечивает совместимость подклассов с их суперклассами.

**Пример в проекте:** Использование полиморфизма для обеспечения заменяемости объектов, например, создание интерфейсов или абстрактных классов, которые определяют общее поведение для всех классов.

**Паттерны, соответствующие LSP:**

- **Фабрика (Factory)**
- **Стратегия (Strategy)**

### Принцип разделения интерфейса (Interface Segregation Principle - ISP)

Принцип ISP гласит, что клиенты не должны зависеть от интерфейсов, которые они не используют. Это способствует созданию более специализированных и независимых интерфейсов.

**Пример в проекте:** Разделение больших интерфейсов на более мелкие и специфичные, чтобы клиенты могли использовать только те методы, которые им нужны.

**Паттерны, соответствующие ISP:**

- **Адаптер (Adapter)**
- **Декоратор (Decorator)**

### Принцип инверсии зависимостей (Dependency Inversion Principle - DIP)

Принцип DIP гласит, что модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций. Это способствует гибкости и облегчает изменения и тестирование кода.

**Пример в проекте:** Использование внедрения зависимостей (dependency injection) для передачи зависимостей объекту через его конструктор или методы, что делает его независимым от конкретной реализации.

**Паттерны, соответствующие DIP:**

- **Внедрение зависимостей (Dependency Injection)**
- **Фабрика (Factory)**
- **Стратегия (Strategy)**

### Object-Oriented Programming (OOP)

Объектно-ориентированное программирование (ООП) в JavaScript представляет собой подход к разработке программного обеспечения, который основан на концепциях объектов и классов. ООП позволяет структурировать код в виде объектов, которые могут содержать данные в виде свойств и функции в виде методов. В JavaScript ООП реализуется с использованием прототипного наследования.

Что такое классы?

Основные концепции ООП в JavaScript:

- Объекты (Objects):
В JavaScript объекты представляют собой наборы пар ключ-значение, где ключи - это строки, а значения - любые типы данных, включая другие объекты, функции и т. д.
Объекты могут быть созданы с использованием литеральной нотации {}, ключевого слова new или конструктора функции.
- Прототипное наследование (Prototype Inheritance):
Прототипное наследование в JavaScript позволяет объектам наследовать свойства и методы от других объектов через их прототипы.
Все объекты в JavaScript имеют ссылку на прототип, который определяет набор свойств и методов, доступных для наследования.
Каждый объект может иметь только один прототип, и любые изменения в прототипе будут отражаться на всех объектах, которые наследуют его.
- Конструкторы и классы:
В JavaScript классы введены в ECMAScript 2015 (ES6) и представляют собой синтаксический сахар над прототипным наследованием.
Классы позволяют создавать объекты с общими свойствами и методами, определяя шаблон для создания объектов с помощью конструктора.
Конструкторы - это функции, которые используются для создания экземпляров классов с определенными свойствами и методами.
Ключевое слово class позволяет определять классы, а ключевое слово new используется для создания экземпляров классов.

### Что такое механизм наследования у классов?

Механизм наследования у классов в объектно-ориентированных языках программирования, таких как JavaScript, позволяет создавать новые классы на основе уже существующих. Это позволяет повторно использовать код и создавать иерархии классов, где новый класс (наследник) получает свойства и методы от базового класса (родителя).

### Основные концепции наследования

1. **Базовый класс (родительский класс)**:
    - Это класс, от которого наследуются свойства и методы. Он определяет общие характеристики и поведение, которые могут быть переопределены или расширены в дочерних классах.
2. **Наследник (дочерний класс)**:
    - Это класс, который наследует свойства и методы от базового класса. Наследник может расширять или изменять поведение, унаследованное от базового класса.
3. **Свойства и методы**:
    - Наследник получает доступ к публичным и защищенным свойствам и методам базового класса. Он также может добавлять новые свойства и методы или переопределять унаследованные методы.
4. **Конструкторы**:
    - Конструктор базового класса может быть вызван из конструктора наследника для инициализации унаследованных свойств.

### Пример наследования в JavaScript (ES6)

В JavaScript механизм наследования реализован с помощью ключевых слов `class` и `extends`. Ниже приведен пример, демонстрирующий как использовать наследование в JavaScript:

```jsx
// Базовый класс (родительский класс)
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}
// Наследник (дочерний класс)
class Dog extends Animal {
  constructor(name, breed) {
    super(name);  // Вызов конструктора базового класса
    this.breed = breed;
  }
  speak() {
    console.log(`${this.name} barks.`);
  }
  // Дополнительный метод
  getBreed() {
    console.log(`Breed: ${this.breed}`);
  }
}
// Создание экземпляра дочернего класса
const dog = new Dog('Rex', 'German Shepherd');
dog.speak();    // Output: Rex barks.
dog.getBreed(); // Output: Breed: German Shepherd
```

### Как это работает

1. **Ключевое слово `extends`**:
    - Используется для указания, что класс `Dog` наследует от класса `Animal`.
2. **Ключевое слово `super`**:
    - Используется для вызова конструктора базового класса и доступа к методам базового класса. В конструкторе дочернего класса необходимо вызывать `super` перед использованием `this`.
3. **Переопределение методов**:
    - Метод `speak` в классе `Dog` переопределяет метод `speak` из класса `Animal`, предоставляя специфичное поведение для `Dog`.
4. **Добавление новых методов**:
    - Класс `Dog` добавляет новый метод `getBreed`, который не присутствует в базовом классе `Animal`.

### Зачем используется наследование

1. **Повторное использование кода**:
    - Позволяет избежать дублирования кода, создавая общие свойства и методы в базовом классе, которые могут быть унаследованы и использованы в дочерних классах.
2. **Моделирование иерархий**:
    - Позволяет создавать иерархии классов, отражающие реальную иерархию объектов в мире. Например, `Dog` может быть подклассом `Animal`, который в свою очередь может быть частью более общей иерархии, включающей другие виды животных.
3. **Переопределение и расширение поведения**:
    - Позволяет изменять или расширять поведение базового класса, предоставляя более специфичное поведение для дочерних классов.

Функции-конструкторы

```jsx
function Person(name, age) {
    this.name = name;    this.age = age;}
Person.prototype.greet = function() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);}
const person1 = new Person('Alice', 30);person1.greet(); // Hello, my name is Alice and I am 30 years old.
```

Пример использования ООП в JavaScript:

```jsx
// Определение класса Person с конструктором и методомclass Person {
    constructor(name, age) {
        this.name = name;        this.age = age;    }
    greet() {
        console.log(`Привет, меня зовут ${this.name} и мне ${this.age} лет.`);    }
}
// Создание экземпляра класса Personconst person1 = new Person('Алиса', 30);// Вызов метода объектаperson1.greet(); // Выведет: Привет, меня зовут Алиса и мне 30 лет.console.log(person1.constructor === Person) //true =)
```

Преимущества ООП в JavaScript:

- Модульность и повторное использование кода: Классы позволяют организовать код в логические блоки, что упрощает его понимание и облегчает повторное использование.
-Инкапсуляция: ООП позволяет скрыть внутренние детали реализации объекта от внешнего мира, что способствует безопасности и стабильности кода.
-Упрощение сопровождения и расширения: Классы облегчают сопровождение кода и его расширение, позволяя добавлять новые функции и свойства без изменения существующего кода.
-Полиморфизм и наследование: ООП поддерживает полиморфизм и наследование, что позволяет создавать иерархии классов и использовать их для создания гибкого и масштабируемого кода.
-JavaScript, хотя и не является строго объектно-ориентированным языком, но поддерживает основные концепции ООП, что делает его мощным инструментом для разработки различных типов приложений и веб-сайтов.