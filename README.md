# interviewQuestionsJS

### в RS Interview Topics

## Basics of OOP
Парадигма программирования, которая стремится организовать программу в виде взаимодействующих объектов, каждый из которых представляет собой экземпляр определенного класса. Основные принципы ООП помогают создавать программы, которые легко понимать, изменять и поддерживать.  
 Инкапсуляция
Объединение данных и методов в один объект и защита внутреннего состояния объекта от других воздействий. Пользователь должен видеть только список декларируемых свойств и методов и не вникать во внутренную реализацию.
Пример инкапсуляции?
Если у нас есть класс, который представляет кошелек с деньгами. Например у него будут два метода позволяющие просматривать количество денег и изменять его. Кошелек может хранить отрицательное количество денег. Для инкапсуляции нам нужно добавить методы: Добавить деньги если это положительное число, взять деньги, если это положительное число и количество денег не больше того что в кошельке. Таким образом мы не сможем потратить денег больше чем имеется и сумма в кошельке не будет отрицательной.
Наследование
Зависимость и отношение, один класс - продолжение другого. Инструмент позволяет избежать дублирования кода и позволяет реализовать полиморфизм.
Пример наследования
Например есть класс Человека с именем и фамилией и методом вывода кода на экран. Сделаем класс студент, который будет наследовать все поля и методы класса Человек. В новый класс студент мы можем добавить новый функционал, например метод Учиться. Мы так же можем переопределить работу методов базового класса.
Полиморфизм (полиморфизм подтипов) Возможность использовать классы потомки в том же контексте что и базовый класс.
Пример полиморфизма?
Если у нас есть класс Машина и он имеет метод Управлять. У нас есть класс Человек и у него есть тоже метод Управлять, который принимает объект класса Машина, и у этого объекта мы вызываем метод Управлять. Мы можем добавить наследника Спортивная машина, в базовом классе метод Управлять мы сделаем виртуальным virtual и в классе наследнике добавим override метод Управлять, где мы реализуем возможность управления спортивной машиной. И в зависимости от того какой класс мы передадим человеку в методе Управления, реализуется логика - для обычный или спортивной машины. При этом мы никаким образом не меняем класс Человека в этом и заключается суть полиморфизма.
Чем отличается класс от абстрактного класса?
Абстрактный класс? зачем нужны?
Абстрактный класс это некая идея, описание контракта с возможной частичной реализацией в наследниках класса. Нечто абстрактное которое должно делать что-то разными способами. В абстрактном классе можно указать астрактный метод без реализации. Так же можно указать конкретную реализацию - метод. Все наследуемые классы могут использовать этот метод. Другой класс в методах может использовать в качестве параметра объект типа нашего абстрактного класса, тогда любой объект который унаследован из астрактного класса может передаваться в качестве параметра. Наследники обязаны реализовать метод от абстрактного класса(override - для переопределения абстрактного метода).
Применение основных принципов ООП помогает создавать модульные, гибкие и масштабируемые программы, которые легко поддерживать и расширять. Эти принципы способствуют повышению производительности разработчика и качества программного обеспечения в целом.

## Basic data structures and their organization (array, list, stack, queue, tree, hash table, etc.).

Вопрос: Какие базовые структуры данных вы знаете, и как они организованы?

# Массив (Array):
Хранит коллекцию элементов в смежных областях памяти. Элементы одного типа хранятся вместе, что обеспечивает легкий доступ к каждому элементу по индексу. Массивы могут быть фиксированной или изменяемой длины.
const simpleArray = [];
// Добавление элементов в массив
simpleArray[0] = "один";
simpleArray[1] = "два";
simpleArray[2] = "три";
Массивы (Arrays) широко используются для хранения упорядоченной коллекции элементов. Они обеспечивают доступ к данным и позволяют итерироваться по элементам. В веб-разработке массивы часто используются для хранения элементов интерфейса, таких как пункты меню и изображения. Они также подходят для обработки данных, таких как сортировка, фильтрация и поиск, а также для хранения структурированных данных, например, таблиц и матриц.

# Стек (Stack):
Хранит коллекцию элементов в линейном порядке, определяемом порядком операций.  "последний вошел, первый вышел" (LIFO) 
const stack = [];
// Добавление элементов в стек (push)
stack.push("элемент 1");
stack.push("элемент 2");
stack.push("элемент 3");
// Удаление элементов из стека (pop)
const removedElement = stack.pop();
Стек вызовов функций в JavaScript используется для управления вызовами функций. При вызове функции создается новый фрейм стека для хранения ее данных. После завершения функции, соответствующий фрейм удаляется из стека. Это происходит по принципу LIFO. В браузерной разработке стеки используются для обработки событий, таких как клики мыши и нажатия клавиш. События обрабатываются в порядке их поступления, следуя принципу LIFO. Управление историей браузера осуществляется с помощью стека. Веб-браузеры используют его для отслеживания переходов между страницами. При переходе на новую страницу или выполнении навигационных действий добавляется новый URL в стек, что позволяет перемещаться по истории браузера. Стеки также используются при реализации различных алгоритмов и структур данных, таких как обход деревьев и вычисление арифметических выражений в обратной польской записи.

# Очередь (Queue): 
Хранит коллекцию элементов, аналогично стеку, но порядок операций здесь всегда "первый вошел, первый вышел".
const queue = [];
// Добавление элементов в очередь (enqueue)
queue.push("элемент 1");
queue.push("элемент 2");
queue.push("элемент 3");
// Удаление элементов из очереди (dequeue)
const removedElement = queue.shift();
В браузерной разработке очереди используются для управления событиями и обработки асинхронных задач, таких как выполнение JavaScript кода, запросы к серверу и анимации. В Node.js и веб-приложениях очереди используются для обработки задач в фоновом режиме, например, запросов к базе данных или сообщений от пользователей. Очереди также используются для обработки данных в реальном времени, таких как сообщения в чате или обновления данных на веб-странице. Они также применяются при реализации различных алгоритмов, таких как поиск в ширину при обходе графов и FIFO планирование задач в операционных системах.

# Связанный список (Linked List): 
Хранит коллекцию элементов в линейном порядке. Каждый элемент, или узел, содержит элемент данных и ссылку на следующий элемент в списке.
// Создание узла списка
function createNode(data) {
  return {
    data: data, // Данные узла
    next: null   // Ссылка на следующий узел (изначально null)
  };
}
// Пример связанного списка
const node1 = createNode("узел 1");
const node2 = createNode("узел 2");
const node3 = createNode("узел 3");
// Связывание узлов в список
node1.next = node2;
node2.next = node3;
// Перебор элементов связанного списка
let currentNode = node1;
while (currentNode) {
  console.log(currentNode.data);
  console.log(currentNode.next);
  currentNode = currentNode.next;
}
Связанные списки обладают динамическим размером, который может изменяться по мере необходимости, в отличие от массивов. Эффективное добавление и удаление элементов делает их предпочтительными для операций вставки и удаления в начале или середине списка. Управление памятью упрощается, так как элементы списка могут быть разбросаны по памяти, не требуя непрерывного блока памяти. Они также используются для реализации других структур данных, таких как стеки и очереди. Кроме того, связанные списки могут быть полезны для работы с большими объемами данных, где требуется эффективное добавление и удаление элементов без перераспределения всего блока памяти, как это происходит с массивами.
Разновидности:
Односвязный список (Singly Linked List): Каждый узел списка содержит данные и ссылку (указатель) на следующий узел в списке. Последний узел указывает на null, что указывает на конец списка.
Двусвязный список (Doubly Linked List): Каждый узел списка содержит данные, ссылку на следующий узел и ссылку на предыдущий узел в списке. Это позволяет эффективно перемещаться как вперед, так и назад по списку.
Кольцевой список (Circular Linked List): В этом списке последний узел ссылается на первый узел, образуя цикл. Это позволяет обходить список бесконечно, просто следуя по ссылкам. /// и еще есть ...

# Дерево (Tree):
Хранит коллекцию элементов иерархически. У каждого узла есть ключевое значение, а родительские узлы связаны с дочерними.
// Создание узла дерева
function createNode(value) {
  return {
    data: value,    // Данные узла
    children: []    // Массив дочерних узлов (изначально пуст)
  };
}
// Пример дерева
const tree = createNode("корень");
const child1 = createNode("первый потомок");
const child2 = createNode("второй потомок");
const grandchild = createNode("внук");
// Связывание узлов в дерево
tree.children.push(child1);
tree.children.push(child2);
child2.children.push(grandchild);
// Функция для рекурсивного обхода дерева
function traverse(node) {
  console.log(node.data);
  if (node.children.length === 0) return; // Базовый случай: у узла нет детей
  node.children.forEach(child => traverse(child)); // Рекурсивный случай: обходим детей
}
// Обход дерева
traverse(tree);
Деревья организуют данные иерархически, как файловая система компьютера или структура документов HTML/XML веб-страницы. Они также используются для реализации алгоритмов и структур данных, например, бинарных деревьев поиска. В веб-разработке деревья представляют структуру веб-страницы через объектную модель документа (DOM), где каждый HTML элемент - это узел в дереве. Деревья также применяются в интерфейсах пользователя для организации компонентов, таких как меню и деревья файлов. Они используются в алгоритмах обхода и поиска данных, например, поиск в ширину или поиск в глубину. В JavaScript деревья могут быть реализованы с использованием объектов или классов для представления узлов и их отношений.

# Граф (Graph):
Хранит коллекцию элементов нелинейным образом. Состоит из конечного набора вершин (узлов) и связей (ребер) между ними.
// Создание пустого графа
const graph = {};
// Добавление вершин и рёбер
graph["A"] = ["B", "C"];
graph["B"] = ["A", "D"];
graph["C"] = ["A", "D"];
graph["D"] = ["B", "C"];
// Вывод всех вершин и их соседей
for (const vertex in graph) {
    const neighbors = graph[vertex];
    console.log(`Вершина ${vertex} соединена с вершинами: ${neighbors.join(", ")}`);
}
Графы моделируют отношения и связи между объектами, как в социальных сетях для представления дружеских связей или в графах зависимостей программного обеспечения для описания связей между компонентами. В алгоритмах поиска и обхода графов, таких как поиск в ширину или в глубину, используются для нахождения кратчайшего пути или обхода всех вершин. В анализе данных и машинном обучении графы помогают анализировать структуру сетей, выявлять сообщества или влиятельные узлы. Они также используются для моделирования задач оптимизации, например, задачи раскроя или планирования производства. Визуализация данных с помощью графов помогает отображать связи между объектами, будь то структура социальных связей, иерархия сайтов или каталогов.

# Хеш-таблица (Hash Table):
Хранит коллекцию элементов в ассоциативном массиве, который сопоставляет ключи и значения. Использует хеш-функцию для преобразования индекса в массиве бакетов, содержащих соответствующий элемент данных.
class HashTable {
    constructor() {
        this.table = {};
    }
    // Метод для добавления информации о котике в хеш-таблицу
    addCat(name, details) {
        this.table[name] = details;
    }
    // Метод для получения информации о котике по его имени
    getCat(name) {
        return this.table[name];
    }
}
// Создаем хеш-таблицу для котиков
const catTable = new HashTable();
// Добавляем информацию о котиках в хеш-таблицу
catTable.addCat("Fluffy", { age: 3, color: "white" });
catTable.addCat("Whiskers", { age: 5, color: "gray" });
catTable.addCat("Mittens", { age: 2, color: "black" });
// Получаем информацию о котике по его имени
console.log(catTable.getCat("Fluffy"));
Хеш-таблицы используются для эффективного хранения данных, особенно когда требуется быстрый доступ по ключу, например, для кэширования, пользовательских данных или конфигурационных параметров. Благодаря эффективной хеш-функции, доступ к данным в хеш-таблице происходит быстро, что делает их превосходным выбором для работы с большими объемами данных, к которым нужен быстрый доступ. Хеш-таблицы также могут использоваться для генерации уникальных идентификаторов или URL, а также для реализации других структур данных, например, множеств или множеств с поддержкой быстрого поиска и удаления элементов. Они помогают оптимизировать использование памяти, поскольку позволяют быстро находить данные по ключу без необходимости больших объемов оперативной памяти для хранения индексов.
Коллизия - это ситуация, когда два или более ключа объекта или элементы структуры данных хеш-таблицы сопоставляются с одним и тем же индексом массива (бакетом) после применения хеш-функции. JavaScript автоматически обрабатывает коллизии, используя внутренние механизмы хранения данных, которые могут включать в себя метод цепочек или другие стратегии управления коллизиями.

## Basic sorting and searching algorithms

Основные алгоритмы сортировки включают в себя:

# Пузырьковая сортировка (Bubble Sort) O(n^2):
Проходит через список множество раз, сравнивая каждую пару соседних элементов и меняя их местами, если они находятся в неправильном порядке.

Он подходит в следующих случаях:
Когда нужно отсортировать небольшой массив данных.
Когда требуется реализация сортировки с минимальным объемом кода или простой логикой.
Но он неэффективен в случаях:
Для больших массивов данных, так как его временная сложность составляет O(n^2), что делает его медленным на больших объемах данных.
Когда нужно сортировать данные, требующие высокой производительности, так как другие алгоритмы, такие как быстрая сортировка или сортировка слиянием, работают значительно быстрее на больших наборах данных.
let bubbleSort = (arr) => {
	const sortArr = [...arr]
    let len = sortArr.length;
    for (let i = 0; i < len; i++) {
        for (let j = 0; j < len; j++) {
            if (sortArr[j] > sortArr[j + 1]) {
                let temp = sortArr[j];
                sortArr[j] = sortArr[j + 1];
                sortArr[j + 1] = temp;
            }
        }
    }
    return sortArr;
};
// Пример использования
let arr = [5, 3, 8, 1, 2];
console.log(bubbleSort(arr));

О малое (O-нотация):
Время выполнения сортировки пузырьком зависит от размера входного списка. В худшем случае (когда список уже отсортирован в обратном порядке), алгоритм будет иметь квадратичное время выполнения, т.е. O(n^2). Это означает, что время выполнения будет расти пропорционально квадрату размера входного списка.
О большое (Ω-нотация):
В лучшем случае (когда список уже отсортирован), сортировка пузырьком все равно проходит через весь список, чтобы убедиться, что он отсортирован. Поэтому даже в лучшем случае алгоритм имеет линейное время выполнения, т.е. Ω(n). Это означает, что время выполнения не может быть лучше, чем линейная функция от размера входного списка.
Таким образом, для сортировки пузырьком:
О малое (O-нотация) говорит нам о худшем случае, когда время выполнения квадратично от размера входного списка.
О большое (Ω-нотация) указывает на лучший случай, когда время выполнения линейно от размера входного списка.

# Сортировка выбором (Selection Sort) O(n^2):
Выбирает минимальный элемент из оставшихся и перемещает его в начало списка. Сортировка выбором полезна в случаях, когда нужно отсортировать небольшой массив данных или когда производительность не является критическим фактором. Этот метод эффективен для сортировки небольших списков или массивов, но не рекомендуется для сортировки больших объемов данных из-за его низкой эффективности по времени выполнения. 
function selectionSort(arr) {
    const len = arr.length;
    for (let i = 0; i < len - 1; i++) {
        let minIndex = i;
        for (let j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex !== i) {
            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; // Меняем местами элементы
        }
    }
    return arr;
}
// Пример использования
const arr = [64, 25, 12, 22, 11];
console.log("Исходный массив: " + arr);
console.log("Отсортированный массив: " + selectionSort(arr));

# Сортировка вставками (Insertion Sort) O(n^2):
Проходит по списку и вставляет каждый элемент на свое место в уже отсортированную часть списка. Сортировка вставками (Insertion Sort) полезна в случаях, когда требуется сортировать небольшие массивы или когда массив уже частично отсортирован. 
function insertionSort(arr) {
    const len = arr.length;
    for (let i = 1; i < len; i++) {
        let current = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > current) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = current;
    }
    return arr;
}
// Пример использования
const arr = [12, 11, 13, 5, 6];
console.log("Исходный массив: " + arr);
console.log("Отсортированный массив: " + insertionSort(arr));


# Быстрая сортировка (Quick Sort) в среднем O(n log n):
Разделяет список на две части вокруг опорного элемента, затем рекурсивно сортирует каждую из частей. Сортировка Quick Sort эффективна в большинстве случаев и широко используется из-за своей скорости и производительности. Она особенно полезна для сортировки больших объемов данных. 
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    const pivot = arr[0];
    const left = [];
    const right = [];

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat(pivot, quickSort(right));
}
const arr = [10, 7, 8, 9, 1, 5];
const sortedArr = quickSort(arr);
console.log(sortedArr); // Output: [1, 5, 7, 8, 9, 10]

# Сортировка слиянием (Merge Sort) O(n log n)::
Разделяет список на две равные части, рекурсивно сортирует каждую часть, а затем объединяет их в один отсортированный список. Merge Sort является стабильным методом сортировки, что означает, что порядок элементов с одинаковыми значениями не меняется. Это может быть важно для определенных типов данных или сценариев. 
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    const middle = Math.floor(arr.length / 2);
    const left = arr.slice(0, middle);
    const right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
    let result = [];
    let leftIndex = 0;
    let rightIndex = 0;
    while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
            result.push(left[leftIndex]);
            leftIndex++;
        } else {
            result.push(right[rightIndex]);
            rightIndex++;
        }
    }
    return result.concat(left.slice(leftIndex), right.slice(rightIndex));
}
const arr = [38, 27, 43, 3, 9, 82, 10];
const sortedArr = mergeSort(arr);
console.log(sortedArr); // Output: [3, 9, 10, 27, 38, 43, 82]

Основные алгоритмы поиска включают в себя:

# Линейный поиск (Linear Search):O(n)
Проходит по списку последовательно и ищет заданный элемент. 
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Возвращаем индекс найденного элемента
        }
    }
    return -1; // Возвращаем -1, если элемент не найден
}
const arr = [5, 3, 9, 2, 7];
const target = 9;
const index = linearSearch(arr, target);
console.log("Index of", target, "is", index);

# Бинарный поиск (Binary Search) O(log n):
Работает на отсортированном списке и делит его на две части, сравнивая искомый элемент с элементом в середине списка и продолжая поиск только в той части, где может быть найден элемент. Упорядоченные массивы: Бинарный поиск эффективен для поиска элементов в упорядоченных массивах, так как основан на делении массива на половины и исключении половины элементов на каждой итерации. Большие объемы данных: При работе с большими объемами данных бинарный поиск может значительно сократить количество операций поиска по сравнению с линейным поиском.
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) {
            return mid; // Возвращаем индекс найденного элемента
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1; // Возвращаем -1, если элемент не найден
}
const arr = [2, 5, 7, 9, 12, 15, 17];
const target = 9;
const index = binarySearch(arr, target);
console.log("Index of", target, "is", index); 

///Сортировка подсчётом (Counting Sort) - это алгоритм сортировки, который работает для ограниченного диапазона целых чисел. Он основан на подсчёте количества элементов каждого значения в массиве и последующем формировании отсортированного массива на основе этих подсчётов.
 
## Binary number system
Двоичная система счисления, использующая только цифры 0 и 1, является основной для компьютеров, включая JavaScript, по нескольким причинам. В компьютерах все данные хранятся и обрабатываются в виде двоичных чисел, а JavaScript также работает с этой системой. Она поддерживает арифметические операции, хранение данных в памяти и битовые операции, что полезно для работы с флагами и состояниями.
Можно использовать встроенный метод toString(), указав основание системы счисления в качестве параметра.
let decimal = 10;
let binary = decimal.toString(2);
console.log(binary); // Вывод: "1010"

## Basics of HTML/CSS:
HTML (HyperText Markup Language) - это основной язык разметки, используемый для создания веб-страниц. Он представляет собой набор тегов и атрибутов, которые определяют структуру и содержимое веб-страницы. HTML документ содержит элементы разметки для заголовка, навигации, основного содержимого и подвала страницы. Каждый элемент имеет свою собственную роль в структуре страницы, что помогает браузеру и поисковым системам правильно интерпретировать содержимое.
CSS (Cascading Style Sheets) - это язык таблиц стилей, который используется для задания внешнего вида и форматирования веб-страниц, созданных с помощью HTML. Он позволяет определить цвета, шрифты, размеры, расположение элементов и другие аспекты оформления, чтобы сделать веб-страницы более привлекательными и удобочитаемыми для пользователей.
XML (Extensible Markup Language) - это язык разметки, который используется для хранения и передачи структурированных данных в формате, который читаем как людьми, так и компьютерами.

# Как подключить JS в HTML?
1. <script src="script.js"></script>
Скрипт будет загружен и выполнен сразу же, блокируя парсинг HTML.
2. Внешний файл JavaScript с defer:
<script src="script.js" defer></script>
Скрипт будет загружен параллельно с парсингом HTML, но выполнится после завершения парсинга и до события DOMContentLoaded.
3. Внешний файл JavaScript с async:
<script src="script.js" async></script>
Скрипт будет загружен параллельно с парсингом HTML и выполнится сразу после загрузки, независимо от порядка загрузки и выполнения остального контента.
4. Встроенный JavaScript код:
<script>
    // Ваш JavaScript код здесь
</script>
Скрипт будет выполнен сразу же, блокируя парсинг HTML.
Обычно тег script помещают внутри тега <head> или перед закрывающим тегом </body> для оптимальной загрузки и исполнения JavaScript кода.

# Box model

это основной концепт веб-разработки, используемый для описания того, как элементы HTML отображаются и взаимодействуют друг с другом на веб-странице.
Основные компоненты модели блочной модели включают:
- Content (Содержимое): Это фактическое содержимое элемента, такое как текст, изображения или другие элементы.
- Padding (Отступы): Пространство вокруг содержимого элемента. Отступы используются для создания промежутков между содержимым и границей элемента.
- Border (Граница): Линия, которая окружает содержимое и отступы элемента. Границы обрамляют элемент и помогают отделить его от других элементов на странице.
- Margin (Внешний отступ): Пространство вокруг границы элемента. Маржа используется для создания промежутков между элементами и для управления распределением пространства на веб-странице.
Эта модель предоставляет разработчикам контроль над внешним видом и расположением элементов на веб-странице, позволяя им точно определять размеры, отступы и границы элементов с помощью CSS.

- Блочные элементы (block-level elements): Эти элементы всегда начинают новую строку и занимают всю доступную ширину по горизонтали. Примеры блочных элементов включают div, p, h1-h6, ul, ol и другие.
- Строчные элементы (inline elements): Эти элементы не начинают новую строку и занимают только столько горизонтального пространства, сколько необходимо для отображения их содержимого. Примеры строчных элементов включают span, a, strong, em, img и другие.
- Инлайн-блочные элементы (inline-block elements): Эти элементы считаются чем-то средним между блочными и строчными элементами. Они занимают только столько горизонтального пространства, сколько необходимо для отображения содержимого, но при этом сохраняют свою блочную природу, позволяя устанавливать ширину и высоту и использовать отступы и границы. Примеры инлайн-блочных элементов включают input, button и другие.

Чтобы сделать изображение блочным элементом в HTML и CSS, вы можете использовать следующий подход:
HTML: Оберните тег img внутри блочного элемента, такого как div, либо установите для тега img атрибут display: block.
CSS: Установите стиль CSS для изображения, чтобы сделать его блочным элементом с помощью свойства display: block.

# Display attribute values

Атрибут display используется в CSS для определения способа отображения элемента. Он контролирует, как элемент будет отображаться в документе, задавая его тип отображения, такой как блочный (block), строчный (inline), инлайн-блочный (inline-block), скрытый (none) и другие значения.

# Selector weights
Вес селекторов (specificity) - это понятие в CSS, которое определяет, какой стиль будет применен к элементу, когда на него одновременно действует несколько правил. Чем более специфичен селектор, тем больший вес он имеет
1. !important: Это ключевое слово, используемое в правилах стилей, которое назначает наивысший приоритет. Если стиль помечен как !important, то он будет переопределять любые другие стили, даже если они имеют более высокий вес селекторов.
2. Inline styles (style=""): Стили, определенные непосредственно в HTML с помощью атрибута style, имеют очень высокий приоритет, но ниже, чем стили, помеченные как !important.
3. ID селекторы (#id): Селекторы с идентификаторами (например, #myId) имеют высокий приоритет и переопределяют стили классов, тегов и псевдоэлементов.
4. Классы, атрибуты, псевдоклассы (.class, [attribute], :pseudoclass): Селекторы классов (например, .myClass), атрибутов (например, [type="text"]) и псевдоклассов (например, :hover) имеют средний приоритет и переопределяют стили тегов и псевдоэлементов.
5. Теги и псевдоэлементы (tag, ::pseudoelement): Селекторы тегов (например, div, p) и псевдоэлементов (например, ::before, ::after) имеют самый низкий приоритет и могут быть легко переопределены другими стилями.

Если селектор составной, то для определения его веса суммируются веса каждого компонента. Например, селектор .myClass p имеет вес селекторов "0 0 0 2", потому что у класса один класс (.myClass) и один тег (p), каждый из которых имеет вес "0 0 0 1".

# em vs rem, relative and absolute values

em и rem - это единицы измерения, используемые для задания размеров шрифтов и других элементов на веб-страницах в CSS. 
- em (от "относительный размер элемента"): Это единица измерения, которая определяется относительно размера шрифта родительского элемента. Например, если у родительского элемента установлен размер шрифта 16 пикселей, а у дочернего элемента размер шрифта задан как 1.5em, то размер шрифта дочернего элемента будет равен 24 пикселям (16 * 1.5).
- rem (от "относительный размер корневого элемента"): Это единица измерения, которая определяется относительно размера шрифта корневого элемента документа (обычно это html). Размер шрифта в rem остается постоянным независимо от размера шрифта родительского элемента. Например, если размер шрифта корневого элемента установлен как 16 пикселей, то размер шрифта элемента с 2rem будет равен 32 пикселям (16 * 2).
- relative and absolute values Относительные и абсолютные значения в контексте веб-разработки относятся к способам задания размеров, расположения и других свойств элементов на веб-странице.
Относительные значения: Эти значения определяются относительно других элементов на веб-странице. Например, относительное позиционирование элемента позволяет ему сдвигаться относительно его нормального положения на странице, но при этом сохранять поток содержимого.Абсолютные значения: Эти значения определяются независимо от других элементов на странице и обычно задаются в фиксированных единицах измерения, таких как пиксели (px) или точки (pt). 
! единицы измерения представлены в виде префиксов (lv, sv, dv) и используются для определения размеров элементов на веб-страницах с учетом различных состояний видового окна на мобильных устройствах. Это позволяет более точно управлять макетами и размерами элементов, особенно в ситуациях, когда пользовательские интерфейсы браузера динамически изменяются.

# Positioning: document flow, position property, overflow, and z-index
- Document Flow - браузер рассчитывает и располагает элементы на веб-странице. Элементы могут быть блочными, строчными или инлайн-блочными, и их расположение в документном потоке определяет их положение на странице относительно других элементов.
- position property - Свойство position в CSS позволяет управлять позиционированием элемента на странице. Возможные значения этого свойства:
 static: Это значение по умолчанию для всех элементов. Элементы с позиционированием static располагаются в документном потоке.
 relative: Элементы с позиционированием relative перемещаются относительно своего исходного положения. Они по-прежнему занимают свое место в документном потоке, но их окружение на странице не изменяется.
 absolute: Элементы с позиционированием absolute полностью удаляются из документного потока и позиционируются относительно ближайшего родительского элемента с позиционированием, отличным от static, или относительно корневого элемента (html), если такого родительского элемента нет.
 fixed: Элементы с позиционированием fixed также удаляются из документного потока и остаются видимыми на экране даже при прокрутке страницы. Они позиционируются относительно окна браузера.
 sticky - это CSS-свойство, которое позволяет элементу сначала вести себя как обычный элемент в документном потоке, но когда он достигает определенной позиции на экране при прокрутке страницы, он "прилипает" к заданной точке и остается там, пока не будет прокручен дальше.
- overflow - Свойство overflow в CSS определяет, как браузер должен обрабатывать содержимое элемента, если оно не помещается в его контейнер. Возможные значения:
 visible: Содержимое не обрезается и видно за пределами границы элемента.
 hidden: Содержимое обрезается и не видно за пределами границы элемента.
 scroll: Появляется полоса прокрутки, чтобы пользователь мог прокручивать содержимое, если оно не помещается.
 auto: Полоса прокрутки появляется только при необходимости (если содержимое не помещается).
- z-index - Свойство z-index в CSS определяет порядок слоев элементов на странице по глубине (ось Z). Это позволяет управлять тем, какие элементы находятся поверх других при наложении. Значение z-index может быть положительным, отрицательным или нулевым, и элементы с более высоким z-index будут находиться поверх элементов с более низким z-index. Числа в индексе используются обычно с интервальным разбиванием.

# способы оцентрировать div на странице
С помощью абсолютного позиционирования и отрицательных отступов:
.centered-div {
    position: absolute; /* Устанавливаем абсолютное позиционирование */
    top: 50%; /* Позиционируем блок по вертикали на 50% от верхнего края родительского элемента */
    left: 50%; /* Позиционируем блок по горизонтали на 50% от левого края родительского элемента */
    margin-top: -50px; /* Сдвигаем блок обратно на 50px вверх, чтобы его верхний край оказался по центру */
    margin-left: -50px; /* Сдвигаем блок обратно на 50px влево, чтобы его левый край оказался по центру */
    width: 100px; /* Устанавливаем ширину блока */
    height: 100px; /* Устанавливаем высоту блока */
    background-color: red; 
}
С помощью position: fixed; и отрицательных отступов:
.centered-div {
    position: fixed; /* Устанавливаем фиксированное позиционирование */
    top: 50%; /* Позиционируем блок по вертикали на 50% от верхнего края окна браузера */
    left: 50%; /* Позиционируем блок по горизонтали на 50% от левого края окна браузера */
    margin-top: -50px; /* Сдвигаем блок обратно на 50px вверх, чтобы его верхний край оказался по центру */
    margin-left: -50px; /* Сдвигаем блок обратно на 50px влево, чтобы его левый край оказался по центру */
    width: 100px; /* Устанавливаем ширину блока */
    height: 100px; /* Устанавливаем высоту блока */
    background-color: red;
}
С помощью margin: auto; и position: fixed;:
.centered-div {
    width: 100px; /* Устанавливаем ширину блока */
    height: 100px; /* Устанавливаем высоту блока */
    background-color: red; 
    margin: auto; /* Автоматически центрируем блок по горизонтали и вертикали */
    position: fixed; /* Устанавливаем фиксированное позиционирование */
    top: 0; /* Выравниваем блок по верхнему краю окна браузера */
    left: 0; /* Выравниваем блок по левому краю окна браузера */
    bottom: 0; /* Выравниваем блок по нижнему краю окна браузера */
    right: 0; /* Выравниваем блок по правому краю окна браузера */
}
С помощью top: 50%;, left: 50%; и transform: translate(-50%, -50%);:
.centered-div {
    position: fixed; /* Устанавливаем фиксированное позиционирование */
    top: 50%; /* Позиционируем блок по вертикали на 50% от верхнего края окна браузера */
    left: 50%; /* Позиционируем блок по горизонтали на 50% от левого края окна браузера */
    transform: translate(-50%, -50%); /* Сдвигаем блок обратно на 50% его собственной ширины и высоты */
    width: 100px; /* Устанавливаем ширину блока */
    height: 100px; /* Устанавливаем высоту блока */
    background-color: red; 
}
С помощью top: 50%;, left: 50%;, margin-top: -50px;, margin-left: -50px;:
.centered-div {
    position: fixed; /* Устанавливаем фиксированное позиционирование */
    top: 50%; /* Позиционируем блок по вертикали на 50% от верхнего края окна браузера */
    left: 50%; /* Позиционируем блок по горизонтали на 50% от левого края окна браузера */
    margin-top: -50px; /* Сдвигаем блок обратно на 50px вверх, чтобы его верхний край оказался по центру */
    margin-left: -50px; /* Сдвигаем блок обратно на 50px влево, чтобы его левый край оказался по центру */
    width: 100px; /* Устанавливаем ширину блока */
    height: 100px; /* Устанавливаем высоту блока */
    background-color: red; 
}
С помощью flex
body {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100vw;
    height: 100vh;
}

.centered-div {
    width: 100px;
    height: 100px;
    background-color: red;
}
С помощью grid
body {
    display: grid;
    place-items: center;
    width: 100vw;
    height: 100vh;
}

.centered-div {
    width: 100px;
    height: 100px;
    background-color: red;
}


# Pseudo-classes and pseudo-elements
Псевдоклассы и псевдоэлементы - это специальные ключевые слова, которые добавляются к селекторам в CSS, чтобы выбирать определенные части элементов на веб-странице. Они предоставляют дополнительные возможности для стилизации элементов, основанные на их состоянии или позиции в структуре документа.
- Псевдоклассы применяются к элементам в определенных состояниях или контекстах, таких как hover (наведение), focus (фокус), и так далее. Например, :hover применяет стили к элементу при наведении на него курсора мыши.
- Псевдоэлементы создают виртуальные элементы внутри других элементов и позволяют стилизовать их отдельно от основного содержимого элемента. Например, ::before и ::after позволяют добавлять контент перед или после содержимого элемента.
Эти возможности полезны для создания интерактивных и красиво оформленных пользовательских интерфейсов. Они позволяют создавать различные эффекты, анимации и макеты, не добавляя дополнительный HTML-код или JavaScript.

# Flexbox
Flexbox - это модуль CSS, который предоставляет удобные средства для создания гибких макетов на веб-страницах. Он позволяет располагать элементы в контейнере таким образом, чтобы они автоматически масштабировались и выравнивались, чтобы адаптироваться под различные размеры экрана и разные устройства.

# Grid
Двумерное позиционирование: Гриды предоставляют возможность контролировать расположение элементов как по горизонтали, так и по вертикали. Это позволяет создавать более сложные макеты, включая сетки с колонками и строками, что может быть сложно или невозможно сделать с помощью флексов.
Сложные макеты: Гриды лучше подходят для создания сложных и многоуровневых макетов, таких как сетки с фиксированными и адаптивными частями, макеты с несколькими уровнями вложенности и т. д. В то время как флексы предназначены в основном для одномерных макетов.
Легкость в выравнивании: Гриды обеспечивают более широкие возможности для выравнивания элементов по обеим осям, включая более сложные сценарии, такие как выравнивание по центру или выравнивание по обеим осям одновременно.
Рабочий поток сетки: Для создания сеток с использованием гридов обычно требуется меньше кода и меньше вложенности, что делает процесс проектирования и разработки более эффективным.
Поддержка для сложных макетов: Гриды предоставляют более гибкий и мощный инструмент для создания сложных и многоуровневых макетов, что делает их более подходящими для проектов с большим количеством сложных компонентов и макетов.

## Data types
 Примитивные типы данных:
1 Number: Представляет числовые значения, как целые, так и дробные. Пример: 42, 3.14.
2 String: Представляет последовательность символов. Пример: "Hello, world!".
3 Boolean: Представляет логическое значение true или false.
4 Null: Представляет отсутствие значения или пустое значение. typeof выдает объект из-за исторических причин для сохранения совместимости существующего кода
5 Undefined: Представляет переменную, которая была объявлена, но ей не было присвоено значение.
6 BigInt: Представляет целые числа произвольной длины.
7 Symbol: Представляет уникальные и неизменяемые значения, используемые для идентификации объектов.
 Ссылочные типы данных:
1 Object: Представляет коллекцию ключ-значение или объекты.
2 Array: Представляет упорядоченную коллекцию элементов.
3 Function: Представляет блок кода, который можно вызывать.
4 Date: Представляет дату и время.
5 RegExp: Представляет шаблон для поиска или замены текста в строке.	

NaN - это специальное значение в JavaScript, которое обозначает "Не число" (Not a Number). Оно используется для представления результата математических операций, которые не могут быть определены как число.
Примеры операций, которые могут привести к NaN:
Деление на ноль: 0 / 0.
Деление бесконечности на бесконечность: Infinity / Infinity.
Попытка выполнить математическую операцию с нечисловым значением, например, умножить число на строку: 5 * "hello".
Попытка выполнить математическую операцию с неопределенным значением или значением, которое не является числом: Math.sqrt(-1).
NaN имеет несколько особенностей:
Любая операция с NaN, включая сравнения, возвращает false.
NaN не равно ни одному другому значению, даже себе: NaN === NaN вернёт false. Для проверки на NaN используется функция isNaN() или оператор Number.isNaN().
При использовании в математических операциях, NaN распространяется и может "заразить" любое другое число, сделав их NaN.

## Variables
В JavaScript переменные можно создавать с помощью ключевых слов var, let и const.
 var было первым ключевым словом для объявления переменных в JavaScript.
Переменные, объявленные с помощью var, имеют функциональную область видимости (function scope), что означает, что они видны только внутри функции, в которой они были объявлены.
 let было введено в ECMAScript 6 (ES6) и стало предпочтительным способом объявления переменных в современном JavaScript.
Переменные, объявленные с помощью let, имеют блочную область видимости (block scope), что означает, что они видны только в блоке кода, в котором они были объявлены.
 const также было введено в ECMAScript 6 (ES6) и используется для объявления переменных с неизменяемым значением (констант).
Переменные, объявленные с помощью const, также имеют блочную область видимости (block scope).
Константы должны быть инициализированы при объявлении и их значение не может быть изменено.

## Type conversions
Преобразование типов данных (type conversions) в JavaScript происходит при необходимости привести значение одного типа к другому типу. JavaScript автоматически выполняет преобразования типов во время выполнения операций или при сравнении значений разных типов.
- Преобразование в строку (String Conversion):
Происходит при конкатенации с строкой (+ оператор).
let number = 123;
let string = 'Number: ' + number;
- Преобразование в число (Number Conversion):
Происходит при арифметических операциях или вызове функции Number().
let string = '456';
let number = Number(string);
let number = +string;
let number = 2;
let result = string * number;
let result = string - number;
- Преобразование в логическое значение (Boolean Conversion):
Происходит при использовании логических операторов (!, &&, ||), операторов сравнения или вызове функции Boolean().
let value = 0;
let boolean = Boolean(value);
- Явное преобразование (Explicit Conversion):
Происходит при использовании явных преобразований с помощью методов String(), Number() и Boolean().

## Ternary, Nullish Coalescing, Optional Chaining, and Logical Operators – Syntax and Use Cases
Тернарный оператор (Ternary Operator) в JavaScript — это условный оператор, который позволяет выполнить различные действия в зависимости от условия.
let age = 20;
let message = (age >= 18) ? 'Совершеннолетний' : 'Несовершеннолетний';

Nullish Coalescing Operator (оператор слияния на основе нулевого значения) в JavaScript используется для выбора значения из двух вариантов, основываясь на том, является ли первый операнд null или undefined. Этот оператор полезен, когда вам нужно выбрать значение по умолчанию, но при этом не следует использовать пустые строки, нулевые значения или другие "ложные" значения. В отличие от оператора ||, который возвращает второй операнд, если первый является "ложным" значением (false, 0, '', NaN, null или undefined), оператор ?? возвращает второй операнд только в случае, если первый строго равен null или undefined.
let value1 = null;
let value2 = 'значение по умолчанию';
let result = value1 ?? value2;

Optional Chaining (опциональная цепочка) - это новая возможность в JavaScript, которая позволяет безопасно доступаться к вложенным свойствам объекта или вызывать методы у объектов, которые могут быть null или undefined, без необходимости проверки каждого уровня вложенности. Основная цель - избежать ошибок TypeError, которые могут возникнуть при попытке доступа к свойствам или вызове методов у нулевых или undefined значений.
let user = {
  name: 'John',
  address: {
    city: 'New York'
  }
};
// Без optional chaining
let city = user.address ? user.address.city : 'unknown';
console.log(city); // Вывод: 'New York'
// С optional chaining
let city2 = user.address?.city;
console.log(city2); // Вывод: 'New York'
// Если свойство address отсутствует, city будет равен undefined
let city3 = user.address?.city?.toUpperCase();
console.log(city3); // Вывод: undefined

Logical Operators – Syntax and Use Cases
Логические операторы в JavaScript используются для выполнения логических операций с булевыми значениями.
1. Логическое И (&&)
Синтаксис: условие1 && условие2
Использование: Возвращает true, если оба условия истинны, и false в противном случае.
2. Логическое ИЛИ (||)
Синтаксис: условие1 || условие2
Использование: Возвращает true, если хотя бы одно из условий истинно, и false в противном случае.
3. Логическое НЕ (!)
Синтаксис: !условие
Использование: Инвертирует значение условия. Если условие истинно, то !условие будет ложным, и наоборот.
Логические операторы часто используются в условных выражениях (if, else, while, for и т.д.) для выполнения различных действий в зависимости от условий. Они также могут быть использованы в составных условиях для более сложных логических проверок.

Сравнение объектов c примитивами по значению
const a = {c: 5}; 
const b = {c: 5};
console.log(JSON.stringify(a) === JSON.stringify(b));


## Loops - for, while, do while
Цикл for: Цикл, который выполняет итерации по заданному количеству раз.
for (инициализация; условие; шаг) {
}
Цикл while: Цикл, который выполняет итерации, пока условие истинно.
while (условие) {
}
Цикл do...while: Цикл, который выполняет итерации, пока условие истинно, но по крайней мере одну итерацию выполнит даже если условие неверно.
do {
} while (условие);

## Switch case - examples where it can be useful
Конструкция switch в JavaScript полезна в ситуациях, когда у вас есть одно выражение, которое нужно сравнить с несколькими возможными значениями.
switch (new Date().getDay()) {
    case 0:
        console.log('Воскресенье');
        break;
    case 1:
        console.log('Понедельник');
        break;
    case 2:
        console.log('Вторник');
        break;
    // и так далее...
    default:
        console.log('Неизвестный день');
}
 switch может работать только с определенными типами данных (например, числами, строками и некоторыми другими), в то время как if-else может проверять любые логические условия.

## задачки
как скопировать массив с примитивами
const copiedArray = [...originalArray]; // оператора spread
const copiedArray = Array.from(originalArray);
const copiedArray = originalArray.slice();

как скопировать объект с примитивами
const copiedObject = {...originalObject};
const copiedObject = Object.assign({}, originalObject);

распарсить строку в объект https://www.youtube.com/watch?student=Vasya&Github=Vasya99&status=true
const parseString = (string) => {
	return string
    		.split("?")[1]
    		.split("&")
    		.reduce((acc, currentValue) => {
              const [key, value] = currentValue.split("=");
              acc[key] = value;
              return acc;
    		}, {});
};

## Event Loop

Event Loop - это механизм, который управляет исполнением кода в JavaScript и обеспечивает асинхронное выполнение операций. 
Вот как он работает:
-Выполнение синхронного кода: Когда вы запускаете JavaScript-приложение, сначала выполняется синхронный код по порядку сверху вниз.
-Обработка асинхронных операций: Если встречается асинхронная операция, например, чтение файла или выполнение запроса к серверу, она отправляется в стек вызовов (call stack) и передается браузеру или окружению выполнения (например, Node.js). JavaScript не ожидает завершения этих операций и продолжает выполнение следующего кода.
-Добавление колбэков в очередь событий: Когда асинхронная операция завершается, ее колбэк (callback) помещается в очередь событий (event queue). Это означает, что функция, переданная в качестве колбэка, будет вызвана после того, как все синхронные операции будут завершены.
-Ожидание выполнения: В то время как стек вызовов пуст и нет выполняющегося синхронного кода, интерпретатор JavaScript проверяет очередь событий. Если там есть колбэк, он добавляется в стек вызовов и выполняется.
-Повторение процесса: Этот процесс повторяется снова и снова, пока есть асинхронные операции и колбэки в очереди событий.


## Number methods

Number.isFinite(value): Проверяет, является ли переданное значение конечным числом (не Infinity или -Infinity).
Number.isInteger(value): Проверяет, является ли переданное значение целым числом.
Number.isNaN(value): Проверяет, является ли переданное значение NaN (не числом).
Number.isSafeInteger(value): Проверяет, является ли переданное значение "безопасным" целым числом в пределах -(2^53 - 1) и 2^53 - 1.
Number.parseFloat(string): Преобразует строку в число с плавающей точкой.
Number.parseInt(string): Преобразует строку в целое число.

## String methods & String templates

charAt(index): Возвращает символ в указанной позиции.
charCodeAt(index): Возвращает код символа в указанной позиции.
concat(string2, string3, ..., stringN): Объединяет строки.
includes(searchString, position): Проверяет, содержит ли строка указанную подстроку.
indexOf(searchValue, fromIndex): Возвращает индекс первого вхождения подстроки.
lastIndexOf(searchValue, fromIndex): Возвращает индекс последнего вхождения подстроки.
slice(start, end): Извлекает часть строки и возвращает новую строку.
split(separator, limit): Разбивает строку на массив подстрок.
substring(start, end): Возвращает подстроку между указанными индексами.
toLowerCase(): Преобразует строку в нижний регистр.
toUpperCase(): Преобразует строку в верхний регистр.
trim(): Удаляет пробельные символы в начале и конце строки.
startsWith(searchString, position): Проверяет, начинается ли строка с указанной подстроки.
endsWith(searchString, length): Проверяет, заканчивается ли строка указанной подстрокой.
repeat(count): Повторяет строку указанное количество раз.
replace(searchValue, replaceValue): Заменяет подстроку другой строкой.
match(regexp): Выполняет поиск совпадений с указанным регулярным выражением.
padStart(targetLength, padString): Дополняет строку указанным символом слева до указанной длины.
padEnd(targetLength, padString): Дополняет строку указанным символом справа до указанной длины.
trimStart() / trimLeft(): Удаляет пробельные символы в начале строки.
trimEnd() / trimRight(): Удаляет пробельные символы в конце строки.

## Strict comparison
Строгое сравнение, часто называемое "строгой равенством", - это метод сравнения в языках программирования, таких как JavaScript, который проверяет как значения, так и типы операндов, которые сравниваются.
В отличие от строгого сравнения, нестрогое или абстрактное сравнение (двойное равенство ==) выполняет приведение типов, то есть пытается преобразовать значения в один и тот же тип перед их сравнением. Это может привести к неожиданным результатам и обычно считается менее надежным, чем строгое сравнение. 

### в чем отличие null и underfind

null и undefined - это два разных значения в JavaScript, и они оба представляют отсутствие значения, но в разных контекстах.
undefined:
undefined означает, что переменная была объявлена, но ей не было присвоено значение.
Когда переменной объявленной без присвоения значения, ее тип и значение по умолчанию будут undefined.
Также undefined является значением, возвращаемым функцией, если она ничего не возвращает явно.
null:
null также представляет отсутствие значения, но используется, когда программист явно присваивает переменной "ничего" или "пустоту".
Это явное присвоение значения, и если переменной присвоено null, это означает, что она не указывает на какой-либо объект или значение.
Во многих случаях undefined сигнализирует о том, что что-то не было инициализировано, в то время как null часто используется для явного указания на отсутствие значения. Однако, в некоторых ситуациях, они могут быть взаимозаменяемыми. Когда вы объявляете переменную без присвоения значения, она автоматически получает значение undefined.

### что возвращает асинхронная функция 

Асинхронная функция в JavaScript возвращает объект Promise. Promise - это объект, представляющий успешное выполнение или ошибку асинхронной операции и позволяющий обработать результат в будущем. Promise может находиться в одном из трех состояний: ожидание (pending), выполнено (fulfilled) или отклонено (rejected).

Если асинхронная функция не содержит оператора return или завершается без явного возврата значения, она также будет возвращать объект Promise с состоянием "выполнено" (fulfilled), и результатом этого Promise будет undefined. То есть, по умолчанию, если асинхронная функция завершается без явного возврата значения, её Promise будет разрешен значением undefined.

### что такое замыкание в JavaScript

Замыкание (closure) в JavaScript — это особенность языка, которая позволяет функции сохранять доступ к переменным из внешней области видимости, даже после завершения выполнения этой функции. Замыкания создаются тогда, когда функция определена внутри другой функции (родительской) и имеет доступ к переменным родительской функции.

Пример замыкания:

  function outerFunction() {
    var outerVariable = 10;
    function innerFunction() {
      console.log(outerVariable);
    }
    return innerFunction;
  }
  var closure = outerFunction();
  closure(); // Выведет 10

В приведенном примере innerFunction является замыканием, потому что она определена внутри outerFunction и имеет доступ к переменной outerVariable из внешней области видимости. Когда outerFunction вызывается и возвращает innerFunction, создается замыкание closure. Затем вызов closure() сохраняет доступ к переменной outerVariable, и она может быть использована внутри innerFunction.

Замыкания в JavaScript часто используются для создания приватных переменных, сохранения состояния функции между вызовами, а также для создания функций обратного вызова и функций высшего порядка.


### Что такое Promise (Промис)?

### Что такое микро и макро таски?

### Get и POST в чем их различие?

Они определяют тип запроса, который клиент отправляет серверу, и обычно используются в различных контекстах.
GET:
Используется для запроса данных от сервера.
Параметры передаются в URL (через строку запроса).
Данные ограничены по длине (ограничение URL-длины браузера).
Данные передаются открыто, видны в URL.
Часто используется для запросов, которые не изменяют состояние на сервере
POST:
Используется для отправки данных на сервер для обработки.
Параметры передаются в теле запроса.
Данные могут быть более объемными и безопасными, так как они не отображаются в URL.
Обычно используется для запросов, которые изменяют состояние на сервере (например, отправка данных формы).


### Можно ли передать данные в GET запросе?

Данные передаются через строку запроса (query string), которая добавляется к URL. Эти данные обычно представлены в виде параметров ключ-значение. Данные, передаваемые в GET-запросе, видны в URL, и они могут быть легко увидены пользователями, что может быть проблематичным с точки зрения безопасности, особенно если эти данные содержат чувствительную информацию, такую как пароли. Поэтому, для передачи более конфиденциальных данных, часто используется метод POST

## JSCORE

JavaScript Topics:

Advanced Expressions

### Understanding Object.is (optional).
Object.is() в JavaScript - это метод, который используется для сравнения двух значений на строгое равенство, без приведения типов. В отличие от операторов сравнения (=== и ==), Object.is() обрабатывает специальные значения, такие как NaN и -0, более точно.


### Differences between let, var, and const.
let, var, и const - это ключевые слова для объявления переменных в JavaScript, но они имеют различное поведение и область видимости.
var:
Переменные, объявленные с помощью var, имеют функциональную область видимости (function scope), что означает, что они доступны только внутри функции, в которой они объявлены.
При использовании var переменные могут быть объявлены повторно в той же области видимости без вызова ошибки.
Переменные var поднимаются (hoisted) в начало своей области видимости.
let:
Переменные, объявленные с помощью let, имеют блочную область видимости (block scope), что означает, что они доступны только в блоке, в котором они объявлены (например, внутри циклов, условных выражений, функций и т. д.).
let не позволяет повторное объявление переменных в той же области видимости. Попытка повторного объявления вызовет ошибку.
Переменные let также поднимаются (hoisted), но они не инициализируются до момента фактического объявления.
const:
Переменные, объявленные с помощью const, также имеют блочную область видимости.
Переменные const обязаны быть инициализированы при объявлении и их значение не может быть изменено после этого.
Попытка изменения значения переменной const вызовет ошибку.


### Exploring the Temporal Dead Zone.
Концепция временной мертвой зоны (Temporal Dead Zone, TDZ) является важной особенностью в JavaScript, которая возникает при доступе к переменным, объявленным с использованием ключевых слов let и const, до их инициализации. В это время попытка доступа к таким переменным вызовет ошибку времени выполнения. Это происходит потому, что хотя переменные, объявленные с помощью var, поднимаются (hoisted) и инициализируются значением undefined, переменные, объявленные с let и const, также поднимаются, но не инициализируются, и любая попытка доступа к ним до их фактической инициализации приведет к ошибке ReferenceError.

Вот пример, иллюстрирующий временную мертвую зону:
console.log(x); // Вызовет ReferenceError
let x = 10;
В этом примере, хотя x объявлена позже в коде, попытка доступа к ней до ее объявления приведет к ошибке ReferenceError из-за нахождения переменной во временной мертвой зоне.
 
### Concepts of Hoisting.
Поднятие (hoisting) - это механизм в JavaScript, который поднимает объявления переменных и функций вверх внутри их области видимости перед выполнением кода. Это означает, что даже если вы обращаетесь к переменной или функции до их фактического объявления в коде, JavaScript все равно "поднимет" их объявления вверх области видимости.
Поднятие переменных (var):
Переменные, объявленные с помощью ключевого слова var, поднимаются в начало своей области видимости. Однако, они инициализируются значением undefined, если им не было присвоено другое значение.
Пример:
console.log(x); // undefined
var x = 10;
console.log(x); // 10
Поднятие функций:
Объявления функций также поднимаются вверх в своей области видимости.
Пример:
sayHello(); // "Hello!"
function sayHello() {
    console.log("Hello!");
}
Поднятие let и const:
Переменные, объявленные с помощью let и const, также поднимаются в начало своей области видимости, но они остаются в "зоне временной мертвой зоны" (Temporal Dead Zone, TDZ) до момента их фактического объявления. Попытка доступа к таким переменным до их инициализации вызовет ошибку.
Пример:
console.log(y); // Throws a ReferenceError
let y = 10;

### The role of polyfills.
Полифиллы представляют собой кодовые фрагменты или скрипты, которые эмулируют функциональность новых функций в старых браузерах, что позволяет разработчикам писать код с использованием последних стандартов и обеспечивать совместимость с широким спектром браузеров.

Вот более подробное объяснение роли полифиллов:
Заполнение пробелов в поддержке браузеров:
Полифиллы заполняют пробелы в поддержке браузеров, предоставляя реализации JavaScript для функций, которые не поддерживаются нативно в старых браузерах. Например, если браузер не поддерживает объект Promise, можно использовать полифилл, чтобы обеспечить необходимую функциональность.
Обеспечение кросс-браузерной совместимости:
При помощи полифиллов разработчики могут обеспечить однородное поведение и функциональность своих веб-приложений в разных браузерах, независимо от того, поддерживают ли эти браузеры определенные функции нативно или нет. Это помогает обеспечить однородный пользовательский опыт для всех пользователей, независимо от используемого ими браузера.
Возможность прогрессивного улучшения:
Полифиллы позволяют применять прогрессивное улучшение, позволяя разработчикам использовать современные технологии веба, обеспечивая при этом обратную совместимость со старыми браузерами. Разработчики могут писать код, используя последние стандарты, и затем использовать полифиллы для обеспечения поддержки старых браузеров, тем самым гарантируя, что пользователи с новыми браузерами получают расширенные возможности, а пользователи со старыми браузерами всё равно получают функциональный опыт.
Снижение необходимости в коде, специфичном для браузера:
Вместо написания кода, специфичного для браузера, для обработки поддержки функций, разработчики могут полагаться на полифиллы для обеспечения однородной функциональности в разных браузерах. Это снижает сложность разработки и поддержки, позволяя разработчикам писать код на стандартизированных API и функциях.
Содействие внедрению новых стандартов:
Полифиллы могут помочь в внедрении новых веб-стандартов, позволяя разработчикам использовать новые функции в своих проектах даже до их широкой поддержки в браузерах. Это стимулирует экспериментирование и инновации в веб-разработке, так как разработчики могут начать использовать новые возможности без ожидания универсальной поддержки браузерами.

Functions

### Differences and uses of arrow functions, function expressions, and function declarations.
Объявления функций (function declarations):
Синтаксис: Объявление функций происходит с использованием ключевого слова function, за которым следует имя функции и список параметров в круглых скобках.
Поднятие (hoisting): Функции, объявленные таким образом, поднимаются вверх своей области видимости, что позволяет вызывать их до фактического объявления в коде.
this: Привязка this зависит от того, как функция вызывается. В методах объекта this указывает на сам объект.
Использование: Объявления функций удобны для определения и использования функций в глобальной области видимости или в области видимости блока кода.
function greet() {
    console.log("Hello, " + this.name + "!");
}
const obj = {
    name: "John",
    sayHello: greet
};

obj.sayHello(); // Выведет "Hello, John!"
Выражения функций (function expressions):
Синтаксис: Функции определяются как часть выражения и могут быть присвоены переменной или использованы в качестве аргумента функции.
Поднятие (hoisting): Функции, определенные как выражения, не поднимаются вверх, и их необходимо определять перед использованием.
this: Привязка this также зависит от контекста вызова функции.
Использование: Выражения функций часто используются для определения анонимных функций или для передачи функций в качестве аргументов другим функциям.
const greet = function() {
    console.log("Hello, " + this.name + "!");
};
const obj = {
    name: "John",
    sayHello: greet
};
obj.sayHello(); // Выведет "Hello, John!"
Стрелочные функции (arrow functions):
Синтаксис: Стрелочные функции имеют более короткий синтаксис с использованием оператора =>.
Лексическое this: Значение this внутри стрелочной функции берется из лексического контекста, в котором она была определена, а не из контекста вызова. Это означает, что this в стрелочной функции наследуется из окружающей области видимости.
Отсутствие arguments: Стрелочные функции также не имеют своего собственного объекта arguments.
Использование: Стрелочные функции обычно используются для написания более короткого и читаемого кода, особенно в обработчиках событий и внутри других функций.
const greet = () => {
    console.log("Hello, " + this.name + "!");
};
const obj = {
    name: "John",
    sayHello: greet
};
obj.sayHello(); // Выведет "Hello, undefined!"
Важно помнить, что использование различных типов функций зависит от конкретной задачи и требований проекта. Если вам нужна привязка this к объекту, обычно предпочтительнее использовать объявления функций или выражения функций. Однако, если вам нужно использовать лексическое this или если вы хотите написать более краткий и читаемый код, стрелочные функции могут быть хорошим выбором.


### Functional Scope

Функциональная область видимости (Functional Scope) относится к области видимости переменных, определенных внутри функций в JavaScript. Каждая функция создает свою собственную область видимости, в которой переменные, объявленные внутри функции, могут быть доступны только из этой функции и из вложенных функций.

### Global scope vs functional scope.

Глобальная область видимости охватывает всю программу JavaScript, включая все функции и переменные, определенные в глобальной области.
Доступность переменных: Переменные, объявленные без ключевого слова var, let или const, автоматически становятся глобальными и доступны из любой части программы.

Функциональная область видимости создается при объявлении функции и ограничивает доступность переменных внутри этой функции и вложенных в нее функций.
Доступность переменных: Переменные, объявленные внутри функции с помощью ключевых слов var, let или const, видны только внутри этой функции и не доступны из внешних областей видимости.
Функциональная область видимости также позволяет создавать замыкания, когда внутренняя функция сохраняет ссылку на переменные из внешней функции, даже после завершения выполнения внешней функции.

### Variable visibility areas.

Глобальная область видимости (Global Scope):
Переменные, объявленные в глобальной области видимости, доступны во всем скрипте.
Они могут быть использованы в любой части программы, включая функции и блоки кода.
Переменные, объявленные без ключевых слов var, let или const, автоматически становятся глобальными.

Функциональная область видимости (Functional Scope):
Переменные, объявленные внутри функций, имеют функциональную область видимости и доступны только внутри этой функции и вложенных в нее функций.
Они недоступны вне функции, в которой они были объявлены.
Переменные, объявленные с помощью ключевых слов var, let или const внутри функции, будут видны только внутри этой функции.

Блочная область видимости (Block Scope):
Введена в ECMAScript 6 (ES6) с использованием ключевых слов let и const.
Переменные, объявленные с помощью let или const, имеют блочную область видимости и доступны только в блоке кода, в котором они были объявлены.
Блоки кода могут быть областью видимости для условных операторов if, циклов for, while, блоков функций и т. д.

### Working with nested scopes.

Доступ к переменным внешних областей видимости:
Вложенная функция или блок кода может получить доступ к переменным из внешней области видимости.
Это происходит благодаря механизму замыканий, когда вложенная функция сохраняет ссылку на область видимости внешней функции.
Пример:
function outerFunction() {
    let outerVar = 'I am from outer function';
    function innerFunction() {
        console.log(outerVar); // Доступ к outerVar из внутренней функции
    }
    innerFunction();
}
outerFunction(); // Выведет "I am from outer function"
Замыкания (Closures):
Когда функция объявлена внутри другой функции, она захватывает (замыкает) область видимости внешней функции, что позволяет ей сохранить доступ к переменным этой внешней функции даже после завершения выполнения внешней функции.
Это позволяет создавать гибкие и мощные конструкции в JavaScript.
Понимание областей видимости:
При работе с вложенными областями видимости важно понимать, что внутренняя область видимости имеет доступ к переменным из внешней области, но не наоборот.
То есть переменные, объявленные внутри вложенной функции, не будут доступны во внешней области видимости.

### Functions Parameters / Arguments
Параметры функции:
Параметры функции - это переменные, которые объявляются в скобках при определении функции и используются для передачи данных внутрь функции.
Параметры являются локальными переменными внутри функции и доступны только внутри этой функции.
Функция может иметь любое количество параметров или не иметь их вовсе.
Аргументы функции:
Аргументы функции - это значения, передаваемые при вызове функции и соответствующие параметрам функции.
Аргументы могут быть любого типа данных: строки, числа, массивы, объекты и т. д.
Количество аргументов должно соответствовать количеству параметров функции при вызове, иначе будут использоваться значения по умолчанию (если они определены) или будет считаться, что параметры, для которых нет аргументов, равны undefined.
Использование параметров и аргументов:
Параметры и аргументы используются для передачи данных в функцию.
Параметры функции можно использовать внутри функции так же, как локальные переменные.
Значения аргументов можно использовать для выполнения операций внутри функции или для передачи в другие функции.
Значения по умолчанию для параметров:
В JavaScript можно установить значения по умолчанию для параметров функции, которые будут использоваться, если вызванная функция не передает аргумент для этого параметра или передает undefined


### Defining function parameters.
Определение параметров:
Параметры функции указываются в скобках после имени функции при ее определении.
Каждый параметр представляет собой локальную переменную внутри функции, которая будет использоваться для хранения переданных значений.
Вы можете указать любое количество параметров для функции, от нуля и более.
Использование параметров:
Параметры функции могут использоваться внутри функции точно так же, как обычные локальные переменные.
Вы можете использовать параметры для выполнения операций внутри функции или для передачи в другие функции.
Значения по умолчанию:
Вы можете установить значения по умолчанию для параметров функции, которые будут использоваться, если вызванная функция не передает аргумент для этого параметра или передает undefined.
Значения по умолчанию указываются в определении функции с помощью оператора присваивания (=).
Деструктуризация параметров:
Вы можете использовать деструктуризацию объектов для работы с параметрами функции.
Это позволяет передавать объект в качестве аргумента и извлекать значения из этого объекта внутри функции.

### Differences in parameters passing by value and by reference.
Передача параметров по значению:
При передаче параметров по значению копия значения передается в функцию, а не сама переменная.
Это означает, что изменения, внесенные в параметр внутри функции, не влияют на оригинальную переменную, из которой был передан аргумент.
Пример:
function increment(x) {
    x = x + 1;
    console.log(x); // Выведет значение, увеличенное на 1
}
let num = 5;
increment(num); // Передача значения переменной num в функцию
console.log(num); // Выведет оригинальное значение переменной num (5), не изменившееся
Передача параметров по ссылке:
При передаче параметров по ссылке передается ссылка на объект в памяти, а не его копия.
Это означает, что если вы измените свойство объекта внутри функции, это изменение отразится на оригинальном объекте, из которого был передан аргумент.
Пример:
function changeName(person) {
    person.name = 'Alice';
    console.log(person); // Выведет объект с измененным свойством name
}
let user = { name: 'Bob' };
changeName(user); // Передача ссылки на объект user в функцию
console.log(user); // Выведет объект с измененным свойством name ('Alice')
Заключение:
Передача по значению применяется к простым типам данных, таким как числа и строки.
Передача по ссылке применяется к сложным типам данных, таким как объекты и массивы.
Понимание этих различий поможет в избежании неожиданных побочных эффектов и правильном управлении данными в вашем коде.


### Handling a dynamic amount of function parameters.
Обработка динамического количества параметров функции является важной возможностью в JavaScript, которая позволяет функции принимать переменное количество аргументов без необходимости предварительного определения их числа. Давайте рассмотрим различные методы обработки динамического количества параметров подробнее:
Использование объекта arguments:
В JavaScript любая функция имеет доступ к объекту arguments, который представляет собой массивоподобный объект, содержащий все переданные функции аргументы.
arguments можно использовать для доступа к переданным аргументам внутри функции, независимо от их количества.
Пример использования arguments:
function sum() {
    let result = 0;
    for (let i = 0; i < arguments.length; i++) {
        result += arguments[i];
    }
    return result;
}
console.log(sum(1, 2, 3)); // Выведет 6
console.log(sum(1, 2, 3, 4, 5)); // Выведет 15
Использование оператора rest (...):
В современном JavaScript есть более удобный способ работы с динамическим количеством параметров - оператор rest (...).
Оператор rest позволяет собирать оставшиеся аргументы функции в массив, что делает код более читаемым и удобным.
Пример использования оператора rest:
function sum(...args) {
    return args.reduce((acc, current) => acc + current, 0);
}
console.log(sum(1, 2, 3)); // Выведет 6
console.log(sum(1, 2, 3, 4, 5)); // Выведет 15
Выбор между arguments и оператором rest:
В большинстве случаев предпочтительнее использовать оператор rest, так как он более читаемый и имеет более явное поведение.
Однако arguments все еще полезен, если вам нужно работать с аргументами как с массивом в старом коде или если вам нужна поддержка старых версий JavaScript.


Closures Advanced
### Understanding context and lexical environments.
Контекст выполнения (Execution Context) - это абстрактное понятие, которое описывает среду, в которой выполняется код JavaScript.
Каждый раз, когда JavaScript интерпретирует и выполняет код, он создает новый контекст выполнения.
Контекст выполнения содержит информацию о переменных, функциях, объектах и других данных, доступных в текущем контексте выполнения.
Каждая функция создает свой собственный контекст выполнения при вызове.
В JavaScript существует глобальный контекст выполнения, а также контекст выполнения функций.
Лексическая среда (Lexical Environment) представляет собой структуру данных, которая связывает идентификаторы (например, переменные и функции) с их значениями во время выполнения кода.
Каждая функция в JavaScript имеет свою собственную лексическую среду, которая содержит ссылку на лексическую среду, в которой эта функция была определена.
Это позволяет функциям иметь доступ к переменным и функциям из своего лексического окружения, даже если они вызываются в другом месте.
Концепция лексической среды играет ключевую роль в работе замыканий в JavaScript.
Пример:
function outerFunction() {
    let outerVar = 'Outer Variable';

    function innerFunction() {
        let innerVar = 'Inner Variable';
        console.log(outerVar); // Доступ к outerVar из лексического окружения внешней функции
    }

    innerFunction();
}
outerFunction(); // Выведет 'Outer Variable'
Здесь функция innerFunction имеет доступ к переменной outerVar, объявленной в лексическом окружении функции outerFunction. Это происходит потому, что лексическая среда innerFunction сохраняет ссылку на лексическую среду outerFunction.


### Differences between scope and context.
Область видимости (Scope) определяет доступность переменных, объектов и функций в программе в том или ином контексте исполнения.
Область видимости определяется местоположением, где переменная была объявлена, и определяет, где именно эта переменная может быть использована.
Типы областей видимости:
Глобальная область видимости (Global Scope) - переменные, объявленные вне любой функции или блока кода, доступны в любом месте программы.
Локальная область видимости (Local Scope) - переменные, объявленные внутри функции или блока кода, доступны только внутри этой функции или блока кода.
Пример:
// Глобальная область видимости
let globalVar = 'I am global';
function exampleFunction() {
    // Локальная область видимости
    let localVar = 'I am local';
    console.log(globalVar); // Можно использовать переменную из глобальной области
}
console.log(globalVar); // Выведет 'I am global'
console.log(localVar); // Ошибка: localVar не определен в этой области видимости
Контекст (Context) в JavaScript обычно относится к значению this внутри функции или метода объекта.
Значение this зависит от того, как функция вызывается, и может относиться к глобальному объекту, объекту, метод которого вызывается, или быть определенным явным образом при вызове функции.
Типы контекстов:
Глобальный контекст (Global Context) - контекст выполнения, когда код выполняется в глобальной области видимости. В этом контексте this обычно ссылается на глобальный объект, такой как window в браузере.
Контекст функции (Function Context) - контекст, в котором код выполняется внутри функции. this внутри функции зависит от способа вызова функции.
Пример:
let obj = {
    name: 'John',
    greet: function() {
        console.log('Hello, ' + this.name);
    }
};
obj.greet(); // Выведет 'Hello, John', здесь this ссылается на объект obj
Заключение:
Область видимости (scope) определяет доступность переменных в программе, в то время как контекст (context) определяет значение this внутри функций и методов. 

### The mechanism of lexical environment traversal.
Механизм обхода лексической среды (lexical environment traversal) относится к способу, с помощью которого JavaScript ищет переменные в лексических областях видимости во время выполнения кода. Давайте разберемся, как это происходит более подробно:
Создание лексической среды:
Когда функция создается в JavaScript, ей присваивается своя собственная лексическая среда (lexical environment).
Эта лексическая среда содержит информацию о всех переменных, объявленных внутри функции, а также ссылку на лексическую среду внешней функции (если такая имеется).
Обход лексической среды:
При выполнении кода JavaScript интерпретатор ищет переменные в лексической среде текущей функции.
Если переменная не найдена в текущей лексической среде, интерпретатор переходит к родительской лексической среде и продолжает поиск там.
Этот процесс продолжается до тех пор, пока переменная не будет найдена или до тех пор, пока не будет достигнута глобальная область видимости.
Использование ссылки на родительскую лексическую среду:
Каждая лексическая среда сохраняет ссылку на свою родительскую лексическую среду.
Это позволяет JavaScript обеспечивать цепочку обхода лексических сред, когда переменные не могут быть найдены в текущей области видимости.
Завершение поиска:
Если переменная найдена в лексической среде, поиск завершается, и переменная используется в соответствующем контексте.
Если переменная не найдена ни в одной лексической среде, это приведет к ошибке ReferenceError.
Пример:
let globalVar = 'Global Variable';
function outerFunction() {
    let outerVar = 'Outer Variable';

    function innerFunction() {
        console.log(globalVar); // Найдет переменную в глобальной области видимости
        console.log(outerVar); // Найдет переменную во внешней лексической среде
    }

    innerFunction();
}
outerFunction();
В этом примере при вызове innerFunction, JavaScript сначала ищет переменную globalVar в глобальной области видимости, а затем переменную outerVar во внешней лексической среде outerFunction, поскольку она не найдена внутри innerFunction.


### Connection between function and its lexical environment.
Создание лексической среды:
Когда функция создается в JavaScript, ей автоматически присваивается своя собственная лексическая среда.
Лексическая среда функции включает в себя все переменные, объявленные внутри функции, а также ссылку на лексическую среду внешней функции, в которой эта функция была определена.
Захват переменных (Variable capturing):
Когда функция сохраняет ссылку на переменную из внешней области видимости, этот процесс называется захватом переменной (variable capturing).
При создании замыкания (closure) функция сохраняет ссылку на переменные из своей лексической среды, которые ей могут понадобиться в будущем.
Использование переменных из лексической среды:
Функция может использовать переменные из своей лексической среды независимо от того, где она вызывается.
Это позволяет функциям сохранять доступ к переменным и значениям из контекста, в котором они были определены, даже после того, как этот контекст завершил свою работу.
Пример:
function outerFunction() {
    let outerVar = 'Outer Variable';
    function innerFunction() {
        console.log(outerVar); // Функция innerFunction имеет доступ к переменной outerVar из лексической среды outerFunction
    }
    return innerFunction;
}
let closure = outerFunction();
closure(); // Выведет 'Outer Variable'
В этом примере функция innerFunction является замыканием, потому что она сохраняет ссылку на переменную outerVar из лексической среды outerFunction, даже после того, как outerFunction завершила свою работу. Когда closure() вызывается в глобальной области видимости, она все еще имеет доступ к переменной outerVar, что позволяет ей вывести её значение.

Advanced Functions
### this in functions
this представляет ссылку на текущий объект, к которому привязан контекст выполнения функции.
this позволяет функции получать доступ к своему контексту выполнения и работать с соответствующими данными.
Значение this в различных ситуациях:
В глобальной области видимости:
В глобальной области видимости this ссылается на глобальный объект, такой как window в браузере или global в Node.js.
В методах объекта:
В методах объекта this ссылается на объект, который вызывает метод.
В конструкторах:
В конструкторах this ссылается на созданный экземпляр объекта, который создается при вызове конструктора с оператором new.
В функциях:
В обычных функциях (не методах объекта и не стрелочных функциях) значение this зависит от того, как функция вызывается:
Если функция вызывается как часть объекта (например, obj.method()), то this ссылается на объект, к которому привязан метод.
Если функция вызывается без объекта (например, function()), то this ссылается на глобальный объект (в строгом режиме это будет undefined).
В стрелочных функциях:
В стрелочных функциях this привязано к значению this окружающего контекста, в котором они были созданы. Они не имеют своего собственного контекста выполнения.
Как изменить значение this:
Методы call(), apply() и bind():
Эти методы позволяют явно устанавливать значение this при вызове функции.
Использование замыканий:
Замыкания могут использоваться, чтобы сохранить значение this и обращаться к нему внутри функции.
Примеры:
let obj = {
    name: 'John',
    greet: function() {
        console.log('Hello, ' + this.name);
    }
};
obj.greet(); // Выведет 'Hello, John'
function Person(name) {
    this.name = name;
    this.sayName = function() {
        console.log('My name is ' + this.name);
    };
}
let person1 = new Person('Alice');
person1.sayName(); // Выведет 'My name is Alice'
let sayNameFunc = person1.sayName;
sayNameFunc(); // Выведет 'My name is undefined' или приведет к ошибке в строгом режиме
В этом примере значение this в методе greet объекта obj ссылается на сам объект obj, в то время как в конструкторе Person оно ссылается на созданный экземпляр объекта. Однако, когда метод sayName присваивается переменной и вызывается без объекта (sayNameFunc()), значение this становится неопределенным или ссылается на глобальный объект.

Методы call(), apply() и bind() предоставляют способы явного управления значением this при вызове функции в JavaScript. Давайте рассмотрим их функционал более подробно:
1. call():
Метод call() вызывает функцию с заданным значением this и аргументами, переданными в виде списка.
Синтаксис: function.call(thisArg, arg1, arg2, ...).
thisArg: значение, которое будет использоваться как this внутри функции.
arg1, arg2, ...: аргументы, которые будут переданы в вызываемую функцию.
По сути, call() позволяет вызвать функцию с заданным контекстом выполнения и набором аргументов.
Пример использования call():
function greet() {
    console.log('Hello, ' + this.name);
}
let person = { name: 'John' };
greet.call(person); // Выведет 'Hello, John'
2. apply():
Метод apply() работает аналогично методу call(), за исключением того, что аргументы передаются в виде массива.
Синтаксис: function.apply(thisArg, [argsArray]).
thisArg: значение, которое будет использоваться как this внутри функции.
argsArray: массив аргументов, которые будут переданы в вызываемую функцию.
Пример использования apply():
function greet() {
    console.log('Hello, ' + this.name);
}
let person = { name: 'Alice' };
let args = ['Bob']; // Аргументы передаются в виде массива
greet.apply(person, args); // Выведет 'Hello, Alice'
3. bind():
Метод bind() создает новую функцию с определенным значением this, которое не может быть изменено ни при каких обстоятельствах.
Синтаксис: function.bind(thisArg[, arg1[, arg2[, ...]]]).
thisArg: значение, которое будет привязано к this в новой функции.
При вызове новой функции, значение this будет установлено в thisArg, а также переданные аргументы будут привязаны к новой функции.
Пример использования bind():
function greet() {
    console.log('Hello, ' + this.name);
}

let person = { name: 'Kate' };
let greetPerson = greet.bind(person);
greetPerson(); // Выведет 'Hello, Kate'
Эти методы полезны, когда требуется явно установить значение this внутри функции или когда нужно создать функцию с привязанными аргументами, которую можно вызывать позднее.

### Reference Type & losing this
Reference Type & Losing this - это ключевая проблема в JavaScript, которая часто возникает при передаче методов объекта как колбэков или при работе с асинхронным кодом. Давайте подробно рассмотрим эту проблему:
1. Объекты как ссылочный тип:
В JavaScript объекты передаются по ссылке, а не по значению. Это значит, что переменные, содержащие объекты, на самом деле хранят не сами объекты, а ссылки на них.
2. Потеря контекста this:
Когда метод объекта передается как колбэк функции, контекст this теряется.
В колбэках this ссылается на глобальный объект или на undefined, если используется строгий режим ('use strict';).
3. Пример потери контекста this:
let obj = {
    name: 'John',
    greet: function() {
        console.log('Hello, ' + this.name);
    }
};
setTimeout(obj.greet, 1000); // В этом случае контекст `this` потеряется
В этом примере, когда метод greet объекта obj передается как колбэк функции setTimeout, он вызывается в контексте глобального объекта или undefined, а не объекта obj. Поэтому вы получите ошибку или неправильный результат.
4. Решение проблемы:
Существует несколько способов решить проблему потери контекста this:
Использование методов call(), apply() или bind() для явного установления контекста.
Использование стрелочных функций, которые не создают собственный контекст this и захватывают контекст родительской области видимости.
Примеры решений:
Использование метода bind():
setTimeout(obj.greet.bind(obj), 1000);
Использование стрелочной функции:
setTimeout(() => obj.greet(), 1000);
Эти методы позволяют сохранить контекст this и гарантировать корректное поведение при вызове методов объекта как колбэков.

### Understand difference between function and method
Функция (Function):
Функция - это блок кода, который можно вызывать для выполнения определенной задачи.
Функция может быть объявлена глобально или внутри другой функции, а также может быть анонимной.
Она может принимать параметры (аргументы), а также возвращать результат.
Пример функции:
function greet(name) {
    console.log('Hello, ' + name);
}
greet('John'); // Вызов функции
2. Метод (Method):
Метод - это функция, связанная с объектом и вызываемая как свойство этого объекта.
Методы представляют собой действия или операции, которые объект может выполнять.
Методы определяются как свойства объекта и могут иметь доступ к другим свойствам и методам этого объекта через ключевое слово this.
Пример метода:
let obj = {
    name: 'John',
    greet: function() {
        console.log('Hello, ' + this.name);
    }
};
obj.greet(); // Вызов метода объекта
3. Различия между функцией и методом:
Контекст вызова: Функции могут быть вызваны независимо от объекта и не привязаны к какому-либо контексту. Методы вызываются в контексте объекта и имеют доступ к его свойствам и методам через this.
Объявление: Функции могут быть объявлены глобально или внутри других функций. Методы объявляются как свойства объекта.
Вызов: Функции вызываются напрямую, в то время как методы вызываются через объект, к которому они принадлежат.

### Understand how this works, realize this possible issues
Как работает this:
Контекст выполнения: Значение this зависит от контекста, в котором функция вызывается.
Значение this:
В методах объекта this ссылается на сам объект.
В глобальной области видимости и внутри обычных функций this ссылается на глобальный объект (например, window в браузере).
В строгом режиме ('use strict';) внутри обычных функций this ссылается на undefined.
В стрелочных функциях this ссылается на значение this окружающего контекста.
2. Возможные проблемы с this:
2.1 Потеря контекста:
Проблема: Контекст this теряется, когда функция передается как колбэк или вызывается в другом контексте.
Решение: Использование методов bind(), call() или apply(), чтобы явно установить контекст.
2.2 Привязка контекста к вложенным функциям:
Проблема: Вложенные функции могут иметь другой контекст this, если они вызываются отдельно от своего родительского объекта.
Решение: Использование лексической привязки this через стрелочные функции или сохранение контекста в переменных внутри замыканий.
2.3 Контекст в асинхронном коде:
Проблема: Контекст this может измениться в асинхронных операциях, таких как setTimeout, setInterval или обработчики событий.
Решение: Использование стрелочных функций, чтобы сохранить контекст или использование методов привязки контекста.
2.4 Использование в качестве метода объекта:
Проблема: Если функция используется как метод объекта, но вызывается независимо от объекта, контекст this может быть неправильно установлен.
Решение: Убедитесь, что функция вызывается от имени объекта, к которому она принадлежит.

### Manage this
Использование методов привязки контекста:
1.1 Метод bind():
bind() создает новую функцию, которая, при вызове, имеет указанный контекст this, с определенными начальными аргументами.
Пример использования:
function greet() {
    console.log('Hello, ' + this.name);
}

let obj = { name: 'John' };
let boundGreet = greet.bind(obj);
boundGreet(); // Выведет 'Hello, John'
1.2 Методы call() и apply():
call() и apply() позволяют вызывать функцию с заданным значением this, а также передавать аргументы в виде списка или массива соответственно.
Примеры использования:
function greet() {
    console.log('Hello, ' + this.name);
}
let obj1 = { name: 'Alice' };
let obj2 = { name: 'Bob' };
greet.call(obj1); // Выведет 'Hello, Alice'
greet.apply(obj2); // Выведет 'Hello, Bob'
2. Использование стрелочных функций:
Стрелочные функции не создают собственного контекста this, а используют контекст окружающего кода.
Пример использования:
let obj = {
    name: 'Kate',
    greet: function() {
        setTimeout(() => {
            console.log('Hello, ' + this.name);
        }, 1000);
    }
};

obj.greet(); // Выведет 'Hello, Kate' через 1 секунду
3. Сохранение контекста в переменных:
Если необходимо сохранить контекст this для использования во вложенных функциях или асинхронных операциях, его можно сохранить в переменной.
Пример использования:
let obj = {
    name: 'Alex',
    greet: function() {
        let self = this; // Сохранение контекста в переменной
        setTimeout(function() {
            console.log('Hello, ' + self.name);
        }, 1000);
    }
};
obj.greet(); // Выведет 'Hello, Alex' через 1 секунду

### Be able to replace this value
Метод bind():
function greet() {
    console.log('Hello, ' + this.name);
}

let obj = { name: 'John' };
let boundGreet = greet.bind(obj);
boundGreet(); // Выведет 'Hello, John'
1.2. Методы call() и apply():
function greet() {
    console.log('Hello, ' + this.name);
}
let obj = { name: 'Alice' };
greet.call(obj); // Выведет 'Hello, Alice'
greet.apply(obj); // Выведет 'Hello, Alice'
2. Стрелочные функции:
let obj = {
    name: 'Kate',
    greet: function() {
        setTimeout(() => {
            console.log('Hello, ' + this.name);
        }, 1000);
    }
};
obj.greet(); // Выведет 'Hello, Kate' через 1 секунду
3. Сохранение контекста в переменной:
let obj = {
    name: 'Alex',
    greet: function() {
        let self = this; // Сохранение контекста в переменной
        setTimeout(function() {
            console.log('Hello, ' + self.name);
        }, 1000);
    }
};
obj.greet(); // Выведет 'Hello, Alex' через 1 секунду
Эти методы позволяют явно устанавливать значение this и гарантировать корректное выполнение функций в различных контекстах.


### Be able to use call and apply Function built-in methods
Метод call():
Метод call() вызывает функцию с указанным значением this и переданными аргументами. Синтаксис:
functionName.call(thisArg, arg1, arg2, ...)
thisArg: Значение, которое будет использоваться в качестве this внутри функции.
arg1, arg2, ...: Аргументы, которые будут переданы в вызываемую функцию.
Пример использования call():
function greet() {
    console.log('Hello, ' + this.name);
}

let obj = { name: 'John' };
greet.call(obj); // Выведет 'Hello, John'
2. Метод apply():
Метод apply() работает аналогично методу call(), за исключением того, что аргументы передаются в виде массива. Синтаксис:
functionName.apply(thisArg, [arg1, arg2, ...])
thisArg: Значение, которое будет использоваться в качестве this внутри функции.
[arg1, arg2, ...]: Массив аргументов, который будет передан в вызываемую функцию.
Пример использования apply():
function greet() {
    console.log('Hello, ' + this.name);
}

let obj = { name: 'Alice' };
let args = ['Bob'];
greet.apply(obj, args); // Выведет 'Hello, Alice'
Общие сведения:
call() и apply() полезны, когда нужно использовать функцию с определенным контекстом, например, вызвать метод объекта с контекстом этого объекта.
Оба метода могут быть использованы для вызова функций с контекстом, не связанным с объектом.
apply() особенно удобен, когда количество аргументов для передачи в функцию заранее неизвестно и они представлены в виде массива.


### Know how to bind this scope to function
Привязка области видимости this к функции в JavaScript является важным инструментом для управления контекстом выполнения функций. Это позволяет явно указать, к чему должен относиться this внутри функции, независимо от того, как она была вызвана. Давайте рассмотрим несколько способов привязки this к функции:
1. Метод bind():
Метод bind() создает новую функцию с указанным значением this, которая не изменяется при ее вызове. Синтаксис:
const boundFunc = func.bind(thisArg);
func: Функция, к которой будет привязан контекст this.
thisArg: Значение, которое будет использоваться в качестве this внутри привязанной функции.
Пример использования bind():
const obj = {
    name: 'John',
    greet: function() {
        console.log('Hello, ' + this.name);
    }
};

const boundGreet = obj.greet.bind(obj);
boundGreet(); // Выведет 'Hello, John'
2. Стрелочные функции:
Стрелочные функции не создают собственного контекста this и используют контекст окружающего кода. Это делает их удобным способом привязки контекста this. Пример:
const obj = {
    name: 'Alice',
    greet: function() {
        setTimeout(() => {
            console.log('Hello, ' + this.name);
        }, 1000);
    }
};

obj.greet(); // Выведет 'Hello, Alice' через 1 секунду
3. Использование замыканий:
Можно сохранить контекст this в замыкании и использовать его внутри функции. Пример:
const obj = {
    name: 'Kate',
    greet: function() {
        const self = this;
        setTimeout(function() {
            console.log('Hello, ' + self.name);
        }, 1000);
    }
};
obj.greet(); // Выведет 'Hello, Kate' через 1 секунду
Заключение:
Привязка контекста this к функции позволяет эффективно управлять контекстом выполнения функций в JavaScript. Используйте метод bind(), стрелочные функции или замыкания в зависимости от вашего контекста и требований, чтобы гарантировать корректное поведение функций.


### Binding, binding one function twice
Привязка одной функции несколько раз:
Вы можете привязать одну и ту же функцию к разным контекстам несколько раз. Каждый вызов метода bind() создает новую функцию с привязанным контекстом. Рассмотрим пример:
const obj1 = { name: 'Alice' };
const obj2 = { name: 'Bob' };
function greet() {
    console.log('Hello, ' + this.name);
}
// Привязываем функцию greet к объектам obj1 и obj2
const greetToAlice = greet.bind(obj1);
const greetToBob = greet.bind(obj2);
// Вызываем привязанные функции с разными контекстами
greetToAlice(); // Выведет 'Hello, Alice'
greetToBob();   // Выведет 'Hello, Bob'
В этом примере функция greet привязывается дважды к разным объектам obj1 и obj2, создавая две новые функции greetToAlice и greetToBob. Каждая из этих функций вызывается с соответствующим контекстом this.


ECMAScript Intermediate
### Function default parameters.
Функциональные параметры по умолчанию (default parameters) - это возможность задать значения по умолчанию для аргументов функции. Если аргумент не был передан при вызове функции, его значение будет заменено значением по умолчанию. Это удобно, когда вы хотите обеспечить гибкость функции, предоставив значения по умолчанию для некоторых аргументов.
Вот пример использования параметров по умолчанию:
function greet(name = 'World') {
    console.log('Hello, ' + name + '!');
}
greet();         // Выведет 'Hello, World!'
greet('Alice');  // Выведет 'Hello, Alice!'
В этом примере функция greet() имеет один аргумент name, для которого задано значение по умолчанию 'World'. Если аргумент name не передается при вызове функции, он автоматически принимает значение 'World'.
Подробнее о функциональных параметрах по умолчанию:
Значения по умолчанию могут быть любыми выражениями:
function sum(a, b = 2 * a) {
    return a + b;
}
console.log(sum(2)); // Выведет 6, так как b = 2 * 2 = 4
Параметры по умолчанию могут ссылаться на предыдущие параметры:
function greet(name, greeting = 'Hello') {
    console.log(greeting + ', ' + name + '!');
}
greet('Alice'); // Выведет 'Hello, Alice!'
Параметры по умолчанию не ограничены только примитивными значениями:
function getDefault() {
    return 'World';
}
function greet(name = getDefault()) {
    console.log('Hello, ' + name + '!');
}
greet(); // Выведет 'Hello, World!'
Параметры по умолчанию вычисляются только при необходимости:
let defaultValue = 'World';
function greet(name = defaultValue) {
    console.log('Hello, ' + name + '!');
}
greet(); // Выведет 'Hello, World!'
defaultValue = 'Alice';
greet(); // Выведет 'Hello, Alice!'

### Using spread operator for function arguments.
Оператор расширения (spread operator) для аргументов функции в JavaScript позволяет передавать переменное количество аргументов в функцию без явного определения их количества. Это делает функции более гибкими и удобными для использования с различными типами данных. Давайте рассмотрим, как использовать оператор расширения для аргументов функции подробнее:
Оператор расширения для массивов:
function sum(a, b, c) {
    return a + b + c;
}
const numbers = [1, 2, 3];
console.log(sum(...numbers)); // Выведет 6
В этом примере массив numbers расширяется в качестве аргументов функции sum(). Это эквивалентно вызову sum(1, 2, 3), где значения из массива numbers используются в качестве аргументов.
Оператор расширения для объединения массивов:
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combinedArray = [...arr1, ...arr2];
console.log(combinedArray); // Выведет [1, 2, 3, 4, 5, 6]
В этом примере массивы arr1 и arr2 объединяются в один массив combinedArray с использованием оператора расширения.
Оператор расширения для объектов:
const obj1 = { foo: 'bar' };
const obj2 = { baz: 'qux' };
const mergedObject = { ...obj1, ...obj2 };
console.log(mergedObject); // Выведет { foo: 'bar', baz: 'qux' }
В этом примере объекты obj1 и obj2 объединяются в один объект mergedObject с использованием оператора расширения.
Применение оператора расширения в функциях:
function greet(...names) {
    names.forEach(name => {
        console.log('Hello, ' + name + '!');
    });
}
greet('Alice', 'Bob', 'Charlie'); // Выведет 'Hello, Alice!', 'Hello, Bob!', 'Hello, Charlie!'
В этом примере оператор расширения ...names позволяет передавать переменное количество аргументов в функцию greet(). Все переданные аргументы сохраняются в массиве names, который затем можно перебрать и обработать.

### Comparing arguments and rest parameters.
Аргументы функции (Function Arguments):
Аргументы функции - это значения, переданные при вызове функции. Они доступны через встроенный объект arguments. Основные особенности аргументов функции:
arguments - это объект, представляющий все аргументы, переданные функции.
arguments - это массивоподобный объект, но не массив. Он имеет свойства, похожие на массив, но не имеет методов массива, таких как forEach, map и т. д.
Количество аргументов может отличаться от количества объявленных параметров в определении функции.
Можно получить доступ к аргументам по индексу: arguments[0], arguments[1], и т. д.
Пример использования аргументов функции:
function sum() {
    let result = 0;
    for (let i = 0; i < arguments.length; i++) {
        result += arguments[i];
    }
    return result;
}
console.log(sum(1, 2, 3)); // Выведет 6
2. Параметры остаточных параметров (Rest Parameters):
Параметры остаточных параметров - это специальный тип параметров функции, который позволяет собирать остаточные аргументы функции в один массив. Основные особенности параметров остаточных параметров:
Они представлены тремя точками (...) перед последним параметром функции.
Они собирают все остальные аргументы, переданные функции, и помещают их в массив.
Можно использовать любое имя для параметра остаточных параметров.
Они позволяют избежать использования объекта arguments.
Пример использования параметров остаточных параметров:
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}
console.log(sum(1, 2, 3)); // Выведет 6
Сравнение:
Гибкость: Параметры остаточных параметров предоставляют более гибкий способ работы с переменным количеством аргументов, в то время как аргументы функции более ограничены.
Массив vs. объект: Параметры остаточных параметров собирают аргументы в массив, тогда как аргументы функции представлены объектом arguments.
Доступность: Параметры остаточных параметров доступны только для параметров функции, в то время как аргументы функции могут использоваться в любом месте функции.
В общем, параметры остаточных параметров обеспечивают более современный и гибкий подход к обработке переменного числа аргументов в функции, в то время как использование аргументов функции может быть менее удобным из-за их ограниченной функциональности.

### Array concatenation with spread operator.
Оператор расширения (spread operator) в JavaScript также может использоваться для объединения (конкатенации) массивов. Он позволяет развернуть (распаковать) элементы одного массива и вставить их в другой массив. Это делает оператор расширения мощным инструментом для работы с массивами. Рассмотрим его подробнее:
Пример использования оператора расширения для конкатенации массивов:
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const concatenatedArray = [...arr1, ...arr2];
console.log(concatenatedArray); // Выведет [1, 2, 3, 4, 5, 6]
В этом примере оператор расширения ...arr1 разворачивает (распаковывает) элементы массива arr1, а оператор расширения ...arr2 разворачивает элементы массива arr2. Затем эти элементы объединяются в один новый массив concatenatedArray.
Применение оператора расширения к пустым массивам:
const arr1 = [1, 2, 3];
const arr2 = [];
const concatenatedArray = [...arr1, ...arr2];
console.log(concatenatedArray); // Выведет [1, 2, 3]
В этом примере оператор расширения также может использоваться с пустым массивом arr2. В этом случае пустой массив не добавляет никаких элементов в конечный массив concatenatedArray.
Применение оператора расширения к массиву с элементами и значениями:
const arr1 = [1, 2, 3];
const value = 4;
const concatenatedArray = [...arr1, value];
console.log(concatenatedArray); // Выведет [1, 2, 3, 4]
В этом примере оператор расширения также может использоваться для добавления значения value в конец массива arr1, создавая новый массив concatenatedArray.
Преимущества использования оператора расширения для конкатенации массивов:
Более компактный и читаемый синтаксис по сравнению с использованием методов массивов, таких как concat().
Возможность быстрого и гибкого объединения массивов с элементами и значениями.
Использование оператора расширения для конкатенации массивов предоставляет простой и эффективный способ создания новых массивов на основе существующих массивов и значений.

### Destructuring assignments for variables and function arguments.
Деструктуризация (Destructuring) в JavaScript - это способ извлечения значений из массивов или объектов и присвоения их переменным в одной строке кода. Деструктуризация часто используется для удобного доступа к элементам массивов или свойствам объектов. Давайте подробнее рассмотрим деструктуризацию для переменных и аргументов функций:
Деструктуризация для переменных:
Деструктуризация массивов:
const numbers = [1, 2, 3];
const [a, b, c] = numbers;
console.log(a); // Выведет 1
console.log(b); // Выведет 2
console.log(c); // Выведет 3
Деструктуризация объектов:
const person = { name: 'Alice', age: 30 };
const { name, age } = person;
console.log(name); // Выведет 'Alice'
console.log(age);  // Выведет 30
Деструктуризация для аргументов функций:
Деструктуризация массивов:
function sum([a, b, c]) {
    return a + b + c;
}
console.log(sum([1, 2, 3])); // Выведет 6
Деструктуризация объектов:
function greet({ name, age }) {
    console.log(`Hello, ${name}! You are ${age} years old.`);
}
greet({ name: 'Alice', age: 30 }); // Выведет 'Hello, Alice! You are 30 years old.'
Преимущества деструктуризации:
Краткость и ясность: Позволяет избежать длинных последовательностей обращений к свойствам объекта или элементам массива.
Удобство работы с данными: Упрощает доступ к структурированным данным, делая код более понятным и читаемым.
Повышение производительности: Меньше кода означает меньше вероятности ошибок и более быструю разработку.

### for..of loop (optional).
Цикл for...of в JavaScript предоставляет простой и удобный способ перебора элементов итерируемых объектов, таких как массивы, строки, коллекции и другие объекты, которые поддерживают протокол итераторов. Давайте подробно рассмотрим его использование:
Использование for...of с массивами:
const array = [1, 2, 3, 4];
for (const element of array) {
    console.log(element); // Выведет каждый элемент массива по очереди
}
Использование for...of со строками:
const str = "Hello";
for (const char of str) {
    console.log(char); // Выведет каждый символ строки по очереди
}
Использование for...of с коллекциями:
const set = new Set([1, 2, 3, 4]);
for (const item of set) {
    console.log(item); // Выведет каждый элемент множества по очереди
}
Примечания:
При использовании for...of не требуется явно указывать индексы или ключи элементов объекта, как это делается в цикле for...in.
Цикл for...of автоматически обходит все элементы итерируемого объекта, начиная с первого и заканчивая последним.
Использование for...of удобно, когда вам нужно пройти по всем элементам массива, строки или других коллекций без необходимости следить за индексами или ключами.

Objects Built-in Methods
### Utilizing Object.keys and Object.values.
Object.keys() и Object.values() - это методы встроенного объекта JavaScript Object, которые используются для работы с объектами. Давайте рассмотрим их подробнее:
Метод Object.keys() возвращает массив строк, содержащих имена собственных перечисляемых свойств объекта. Вот как он используется:
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
console.log(keys); // Выведет ['a', 'b', 'c']
В этом примере метод Object.keys() возвращает массив строк, содержащих имена свойств объекта obj.
Примечания по Object.keys():
Метод Object.keys() возвращает только собственные перечисляемые свойства объекта, игнорируя унаследованные свойства и свойства, которые не перечисляемы.
Результат будет массивом строк, содержащим имена свойств объекта в том же порядке, в котором они были определены (если движок JavaScript поддерживает этот порядок).
Метод Object.values() возвращает массив значений собственных перечисляемых свойств объекта в том же порядке, что и с помощью цикла for...in (при условии, что движок JavaScript поддерживает этот порядок). Вот пример:
const obj = { a: 1, b: 2, c: 3 };
const values = Object.values(obj);
console.log(values); // Выведет [1, 2, 3]
В этом примере метод Object.values() возвращает массив значений свойств объекта obj.
Примечания по Object.values():
Метод Object.values() возвращает только значения собственных перечисляемых свойств объекта, игнорируя унаследованные свойства и свойства, которые не перечисляемы.
Примечания по обоим методам:
Эти методы очень полезны для итерации по свойствам объекта и работы с ними в функциональном стиле, используя методы массива, такие как map(), filter() и reduce().
Оба метода работают в современных версиях всех основных браузеров и движков JavaScript, включая Node.js. Однако, если вы используете старые версии JavaScript или необходима поддержка старых браузеров, проверьте совместимость методов перед использованием.

### Working with static Object methods.
1. Object.keys()
Этот метод возвращает массив строк, содержащих имена собственных перечисляемых свойств объекта.
Пример использования:
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
console.log(keys); // ['a', 'b', 'c']
2. Object.values()
Этот метод возвращает массив значений собственных перечисляемых свойств объекта.
Пример использования:
const obj = { a: 1, b: 2, c: 3 };
const values = Object.values(obj);
console.log(values); // [1, 2, 3]
3. Object.entries()
Этот метод возвращает массив пар ключ-значение для каждого собственного перечисляемого свойства объекта в виде массива.
Пример использования:
const obj = { a: 1, b: 2, c: 3 };
const entries = Object.entries(obj);
console.log(entries); // [['a', 1], ['b', 2], ['c', 3]]
4. Object.assign()
Этот метод используется для копирования значений всех перечисляемых собственных свойств из одного или нескольких исходных объектов в целевой объект.
Пример использования:
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };
const merged = Object.assign(target, source);
console.log(merged); // { a: 1, b: 4, c: 5 }
5. Object.freeze()
Этот метод "замораживает" объект, что означает, что нельзя добавлять новые свойства, изменять существующие свойства или удалять их.
Пример использования
const obj = { a: 1, b: 2 };
Object.freeze(obj);
obj.c = 3; // Ошибка в строгом режиме
console.log(obj); // { a: 1, b: 2 }
6. Object.seal()
Этот метод запечатывает объект, что означает, что нельзя добавлять новые свойства и удалять существующие свойства, но можно изменять существующие свойства.
Пример использования:
const obj = { a: 1, b: 2 };
Object.seal(obj);
obj.c = 3; // Ошибка в строгом режиме
delete obj.a; // Ошибка в строгом режиме
console.log(obj); // { a: 1, b: 2 }
7. Object.create()
Этот метод создает новый объект с указанным прототипом и набором собственных свойств.
Пример использования:
const obj = Object.create({ a: 1, b: 2 });
console.log(obj); // {}
console.log(obj.a); // 1
Примечание:
Все эти методы Object являются статическими, поэтому они вызываются напрямую через объект Object, а не через экземпляр объекта.

### Property flags and descriptors.
Свойства объектов в JavaScript могут иметь различные характеристики, называемые флагами свойств и дескрипторами. Они определяют поведение и доступ к свойствам объектов. Давайте рассмотрим их подробнее:
1. Флаги свойств:
Writable (записываемость): Определяет, можно ли изменять значение свойства. Если установлен в true, значение свойства можно изменять. По умолчанию true.
Enumerable (перечисляемость): Определяет, будет ли свойство перечисляться при итерации через цикл for...in или методы Object.keys() и Object.values(). Если установлен в true, свойство будет перечисляемым. По умолчанию true.
Configurable (настраиваемость): Определяет, можно ли изменять атрибуты свойства и удалять его из объекта. Если установлен в true, свойство может быть изменено или удалено. По умолчанию true.
2. Дескрипторы свойств:
Дескриптор свойства - это объект, содержащий флаги и другие характеристики свойства.
Value (значение): Значение свойства.
Writable (записываемость): Флаг записываемости.
Enumerable (перечисляемость): Флаг перечисляемости.
Configurable (настраиваемость): Флаг настраиваемости.
Пример использования:
const obj = {};
Object.defineProperty(obj, 'prop', {
  value: 42,
  writable: false,
  enumerable: true,
  configurable: true
});
console.log(obj.prop); // Выведет 42
obj.prop = 100; // Ошибка в строгом режиме или silent mode
console.log(obj.prop); // Выведет 42
delete obj.prop; // Работает, так как configurable установлен в true
console.log(obj.prop); // Выведет undefined
Методы для работы с дескрипторами:
Object.defineProperty(): Определяет новое свойство непосредственно на объекте или изменяет существующее свойство и возвращает объект.
Object.defineProperties(): Определяет новые или изменяет существующие свойства непосредственно на объекте, возвращая объект.
Object.getOwnPropertyDescriptor(): Возвращает дескриптор указанного свойства объекта.
Object.getOwnPropertyDescriptors(): Возвращает объект, содержащий дескрипторы всех собственных свойств объекта.
Примечания:
Использование дескрипторов позволяет более точно контролировать поведение свойств объекта.
Object.defineProperty() и Object.defineProperties() позволяют явно задавать флаги свойств объекта.
Object.getOwnPropertyDescriptor() и Object.getOwnPropertyDescriptors() позволяют получить информацию о свойствах объекта.

### Creating iterable objects and using Symbol.iterator (optional).

В JavaScript итерируемые объекты позволяют перебирать их элементы с помощью циклов for...of, распространенных методов массивов (например, map, filter, reduce) и оператора распространения (...). Для создания итерируемых объектов используется символ Symbol.iterator, который представляет метод, возвращающий итератор для объекта. Вот как это работает:
Создание итерируемого объекта:
Создание метода Symbol.iterator: Определяем метод Symbol.iterator в прототипе объекта или непосредственно в объекте.
Метод Symbol.iterator: Этот метод возвращает итератор для объекта. Итератор - это объект, который должен иметь метод next(), возвращающий объект с двумя свойствами: value (значение следующего элемента) и done (логическое значение, показывающее, завершен ли перебор).
Пример создания итерируемого объекта:
const myIterable = {
  data: ['one', 'two', 'three'],
  [Symbol.iterator]: function() {
    let index = 0;
    return {
      next: () => {
        return {
          value: this.data[index++],
          done: index > this.data.length
        };
      }
    };
  }
};

for (const item of myIterable) {
  console.log(item); // Выведет 'one', 'two', 'three'
}
Примечания:
Метод Symbol.iterator может быть определен непосредственно в объекте или в его прототипе.
Возвращаемый итератор должен иметь метод next(), который возвращает объект с полями value и done.
После завершения перебора done должен быть установлен в true.
Использование итерируемых объектов упрощает работу с данными и делает код более понятным и функциональным, особенно в контексте современных возможностей JavaScript, таких как цикл for...of и оператор распространения (...).

ECMAScript Data Types & Expressions
### Working with Object computed properties.
С вычисляемыми свойствами объекта вы можете создавать свойства, имена которых вычисляются во время выполнения программы. В JavaScript для этого используется выражение в квадратных скобках [], в котором можно указывать любые выражения, включая переменные или вызовы функций. Давайте рассмотрим это подробнее:
Создание объекта с вычисляемыми свойствами:
const prefix = 'foo';
const obj = {
  [prefix + '_bar']: 'baz',
  ['get' + 'Value']() {
    return this.foo_bar; // Доступ к вычисляемому свойству
  }
};
console.log(obj.foo_bar); // Выведет 'baz'
console.log(obj.getValue()); // Выведет 'baz'
Примечания:
Внутри квадратных скобок [] можно использовать любые выражения, которые могут быть вычислены в строку.
Свойства, созданные с использованием вычисляемых имен, имеют те же характеристики, что и обычные свойства объекта.
Вы можете использовать вычисляемые свойства для динамического создания свойств объекта или создания свойств с удобными именами на основе переменных или других вычислений.
Это очень мощный инструмент, который позволяет гибко создавать и манипулировать свойствами объектов в JavaScript. Он часто используется в ситуациях, когда имена свойств заранее неизвестны и зависят от контекста выполнения программы.


### Iterating through Object keys.
Итерация по ключам объекта - это процесс перебора всех ключей объекта и выполнение определенных действий для каждого ключа. В JavaScript есть несколько способов сделать это. Давайте рассмотрим их подробнее:
1. Цикл for...in:
Цикл for...in используется для перебора всех перечисляемых свойств объекта. Он перебирает имена всех свойств, включая унаследованные.
const obj = { a: 1, b: 2, c: 3 };
for (const key in obj) {
  console.log(key); // Выведет 'a', 'b', 'c'
}
2. Метод Object.keys():
Метод Object.keys() возвращает массив строк, содержащих имена собственных перечисляемых свойств объекта.
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
for (const key of keys) {
  console.log(key); // Выведет 'a', 'b', 'c'
}
3. Метод Object.entries() с деструктуризацией:
Метод Object.entries() возвращает массив пар ключ-значение для каждого собственного перечисляемого свойства объекта в виде массива. Можно использовать деструктуризацию для итерации по ключам и значениям одновременно.
const obj = { a: 1, b: 2, c: 3 };
for (const [key, value] of Object.entries(obj)) {
  console.log(key); // Выведет 'a', 'b', 'c'
}
Примечания:
Каждый из этих методов имеет свои особенности и подходит для разных сценариев использования.
Цикл for...in удобен для перебора всех перечисляемых свойств, но он также перебирает унаследованные свойства.
Метод Object.keys() возвращает только имена собственных перечисляемых свойств объекта.
Метод Object.entries() возвращает массив пар ключ-значение, что может быть полезно при итерации как по ключам, так и по значениям объекта.

Arrays Built-in Methods
### Copying and modifying arrays.
Копирование и изменение массивов - это частая задача в JavaScript, особенно при работе с данными. Давайте рассмотрим различные методы для копирования и изменения массивов подробно:
1. Копирование массива:
1.1. Метод slice():
Метод slice() создает копию массива, начиная с указанного индекса и до указанного конечного индекса (не включая его). Если параметры не указаны, создается полная копия массива.
const array = [1, 2, 3, 4, 5];
const copyArray = array.slice();
console.log(copyArray); // [1, 2, 3, 4, 5]
1.2. Оператор распространения (...):
Оператор распространения (...) также создает поверхностную копию массива.
const array = [1, 2, 3, 4, 5];
const copyArray = [...array];
console.log(copyArray); // [1, 2, 3, 4, 5]
2. Изменение массива:
2.1. Метод concat():
Метод concat() создает новый массив, объединяя существующий массив с другими массивами или значениями.
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];
const newArray = array1.concat(array2);
console.log(newArray); // [1, 2, 3, 4, 5, 6]
2.2. Методы изменения массива:
Методы, изменяющие массив, такие как push(), pop(), shift(), unshift(), splice(), изменяют исходный массив. Их следует использовать для добавления, удаления или замены элементов в массиве.
const array = [1, 2, 3];
array.push(4); // Добавляет элемент в конец массива
console.log(array); // [1, 2, 3, 4]
array.pop(); // Удаляет последний элемент массива
console.log(array); // [1, 2, 3]
array.shift(); // Удаляет первый элемент массива
console.log(array); // [2, 3]
array.unshift(1); // Добавляет элемент в начало массива
console.log(array); // [1, 2, 3]
array.splice(1, 0, 5); // Вставляет элемент в заданную позицию
console.log(array); // [1, 5, 2, 3]
Примечания:
При копировании массива с помощью slice() или оператора распространения (...) создается поверхностная копия массива. Для глубокого копирования массива с вложенными структурами данных потребуется дополнительный код.
Методы изменения массива, такие как push(), pop(), shift(), unshift(), splice(), изменяют исходный массив.

### Flattening nested arrays.
Сглаживание (flattening) вложенных массивов - это процесс преобразования массива с вложенными массивами в одномерный массив, в котором все элементы находятся на одном уровне. Для выполнения этой задачи в JavaScript существует несколько подходов. Давайте рассмотрим некоторые из них:
1. Использование метода flat():
Метод flat() создает новый массив, удаляя все вложенные массивы до указанной глубины. По умолчанию глубина устанавливается в 1.
const nestedArray = [1, [2, 3], [4, [5, 6]]];
const flattenedArray = nestedArray.flat();
console.log(flattenedArray); // [1, 2, 3, 4, [5, 6]]
2. Использование метода reduce():
Метод reduce() может быть использован для сглаживания массива рекурсивно.
const nestedArray = [1, [2, 3], [4, [5, 6]]];
function flattenArray(arr) {
  return arr.reduce((acc, curr) => {
    return Array.isArray(curr) ? acc.concat(flattenArray(curr)) : acc.concat(curr);
  }, []);
}
const flattenedArray = flattenArray(nestedArray);
console.log(flattenedArray); // [1, 2, 3, 4, 5, 6]
3. Использование рекурсии:
Рекурсивная функция может быть использована для обхода всех элементов массива и сглаживания вложенных массивов.
const nestedArray = [1, [2, 3], [4, [5, 6]]];
function flattenArray(arr) {
  let result = [];
  arr.forEach(item => {
    if (Array.isArray(item)) {
      result = result.concat(flattenArray(item));
    } else {
      result.push(item);
    }
  });
  return result;
}
const flattenedArray = flattenArray(nestedArray);
console.log(flattenedArray); // [1, 2, 3, 4, 5, 6]
Примечания:
Метод flat() является наиболее простым способом сглаживания массивов, но может не поддерживаться в старых версиях JavaScript или во всех браузерах.
Использование рекурсии дает большую гибкость и контроль, но может потребовать больше кода.
При сглаживании массива следует учитывать возможные циклические ссылки в структуре данных.

Arrays Iterating, Sorting, Filtering
### Sorting and custom sorting arrays.
Сортировка массивов - это процесс упорядочивания элементов массива в определенном порядке. В JavaScript для этого используется метод sort(). Помимо стандартной сортировки, которая сортирует элементы в лексикографическом порядке, вы также можете определить собственную функцию сравнения для настройки сортировки по вашему усмотрению.
1. Стандартная сортировка:
Метод sort() сортирует элементы массива как строки Unicode.
const array = [5, 2, 8, 1, 4];
array.sort();
console.log(array); // [1, 2, 4, 5, 8]
2. Пользовательская сортировка:
Метод sort() принимает функцию сравнения, которая определяет порядок сортировки. Функция должна возвращать отрицательное число, если первый аргумент меньше второго, положительное число, если первый аргумент больше второго, и 0, если они равны.
const array = [5, 2, 8, 1, 4];
array.sort((a, b) => a - b); // Сортировка по возрастанию
console.log(array); // [1, 2, 4, 5, 8]
const array = [5, 2, 8, 1, 4];
array.sort((a, b) => b - a); // Сортировка по убыванию
console.log(array); // [8, 5, 4, 2, 1]
3. Сортировка объектов:
Если вы сортируете массив объектов, вы также можете передать функцию сравнения для сортировки по определенному свойству объекта.
const people = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
  { name: 'Charlie', age: 35 }
];
people.sort((a, b) => a.age - b.age); // Сортировка по возрасту
console.log(people);
/* Вывод:
[
  { name: 'Bob', age: 25 },
  { name: 'Alice', age: 30 },
  { name: 'Charlie', age: 35 }
]
*/
Примечания:
Пользовательская сортировка позволяет точно определить порядок сортировки в зависимости от ваших потребностей.
При сортировке объектов убедитесь, что функция сравнения правильно обрабатывает случаи, когда свойства объектов имеют различные типы данных или отсутствуют.

### Filtering array elements.
ильтрация элементов массива - это процесс удаления элементов, которые не соответствуют определенному условию, и оставление только тех, которые удовлетворяют этому условию. В JavaScript для этого обычно используется метод filter(). Давайте рассмотрим его подробнее:
Использование метода filter():
Метод filter() создает новый массив, содержащий только те элементы исходного массива, для которых функция обратного вызова возвращает true.
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // [2, 4]
Примечания:
Функция обратного вызова, передаваемая в метод filter(), принимает три аргумента: элемент массива, индекс элемента и сам массив.
Если функция обратного вызова возвращает true, элемент добавляется в новый массив, если false - элемент пропускается.
Метод filter() не изменяет исходный массив, а создает новый массив на основе элементов, прошедших фильтрацию.
Вы можете использовать filter() для фильтрации массивов объектов, применяя к ним различные условия, включая значения свойств объектов.


JavaScript in Browser:
### Global Object Window
Глобальный объект window - это главный объект в браузерной среде JavaScript. В контексте веб-разработки, window представляет глобальное окно браузера, в котором отображается текущая веб-страница. В этом объекте содержатся множество встроенных свойств и методов, предоставляемых браузером для управления окном и другими аспектами веб-платформы. Давайте рассмотрим основные характеристики глобального объекта window:
1. Глобальные переменные и функции:
Все переменные и функции, объявленные на верхнем уровне в скрипте, становятся свойствами глобального объекта window.
var globalVariable = 'Hello';
function globalFunction() {
  console.log('World');
}
console.log(window.globalVariable); // 'Hello'
window.globalFunction(); // 'World'
2. Встроенные свойства и методы:
window содержит множество встроенных свойств и методов, таких как document, location, navigator, setTimeout, setInterval и многое другое, которые предоставляют доступ к различным функциям и компонентам браузера.
console.log(window.document); // Объект Document, представляющий текущий HTML-документ
console.log(window.location.href); // URL текущей веб-страницы
console.log(window.navigator.userAgent); // Строка, представляющая информацию о браузере пользователя
3. Обработка событий:
window также предоставляет методы для обработки событий, такие как addEventListener() и removeEventListener(), которые используются для добавления и удаления обработчиков событий на глобальном уровне.
window.addEventListener('load', () => {
  console.log('Страница загружена');
});
Примечания:
В контексте браузера, где отсутствует внешняя оболочка, глобальный объект window является главным контейнером для всех глобальных переменных и функций.
Использование свойств и методов window может быть полезным для взаимодействия с браузером и его окружением при разработке веб-приложений.

### Understanding the Document Object Model (DOM).
Модель объектов документа (Document Object Model, DOM) - это структура и интерфейс программирования приложений (API) для HTML и XML документов. Она представляет структуру документа в виде древовидной структуры объектов, которая позволяет JavaScript взаимодействовать с содержимым и структурой веб-страницы. Вот ключевые концепции, которые следует понимать о DOM:

1. Иерархия узлов:
DOM представляет документ в виде дерева узлов, которые представляют различные части документа, такие как элементы HTML, атрибуты, текстовые узлы и т. д. Верхний уровень дерева представляет сам документ, а его потомки представляют элементы и содержимое документа.
<!DOCTYPE html>
<html>
  <head>
    <title>Пример</title>
  </head>
  <body>
    <h1>Привет, мир!</h1>
    <p>Это пример веб-страницы.</p>
  </body>
</html>
2. Доступ к элементам:
С помощью JavaScript вы можете получить доступ к элементам документа, используя методы API DOM, такие как getElementById(), getElementsByClassName(), getElementsByTagName() или querySelector(). Эти методы позволяют получить ссылки на элементы по их идентификатору, классу, тегу или CSS селектору.
const header = document.getElementById('header');
const paragraphs = document.getElementsByTagName('p');
const firstParagraph = document.querySelector('p');
3. Изменение содержимого:
JavaScript также позволяет изменять содержимое документа, включая текстовое содержимое элементов, атрибуты и структуру документа. Например, вы можете изменить текст внутри элемента или добавить новый элемент в документ.
const paragraph = document.getElementById('paragraph');
paragraph.textContent = 'Новый текст'; // Изменение текстового содержимого элемента
const newElement = document.createElement('div'); // Создание нового элемента
newElement.textContent = 'Новый элемент';
document.body.appendChild(newElement); // Добавление элемента в конец документа
Примечания:
DOM предоставляет множество методов и свойств для взаимодействия с элементами документа, что делает его мощным инструментом для динамического изменения веб-страницы.
Понимание DOM важно для разработчиков веб-приложений, так как это позволяет им создавать интерактивные и динамические пользовательские интерфейсы.

Events Basics
### Types of DOM Events.
События DOM (Document Object Model) представляют собой действия или сигналы, которые браузер отправляет в ваше веб-приложение при определенных действиях пользователя или изменениях веб-страницы. События играют важную роль в создании интерактивных веб-приложений, так как позволяют реагировать на действия пользователя. Вот некоторые из наиболее распространенных типов событий DOM:
1. События мыши:
click: Происходит при клике на элемент.
mouseover: Происходит, когда указатель мыши наводится на элемент.
mouseout: Происходит, когда указатель мыши покидает элемент.
mousedown, mouseup: Происходит при нажатии и отпускании кнопки мыши над элементом.
2. События клавиатуры:
keydown, keyup: Происходит при нажатии и отпускании клавиши на клавиатуре.
3. События фокуса:
focus, blur: Происходит, когда элемент получает или теряет фокус ввода.
4. События формы:
submit: Происходит при отправке формы.
input, change: Происходит при изменении значения элемента формы (текстового поля, чекбокса, радиокнопки и т. д.).
5. События загрузки документа:
DOMContentLoaded: Происходит, когда документ был полностью загружен и разобран (без ожидания загрузки изображений и стилей).
load: Происходит, когда весь контент (включая изображения, стили и т. д.) был полностью загружен.
6. События CSS анимации и переходов:
transitionend: Происходит после завершения CSS перехода.
animationstart, animationend, animationiteration: Происходит при начале, завершении или итерации CSS анимации.
7. Свои события:
Возможно создание и вызов собственных пользовательских событий с помощью методов createEvent() и dispatchEvent().
Примечания:
События DOM позволяют вашему веб-приложению реагировать на действия пользователя и изменения веб-страницы.
Обработчики событий могут быть привязаны к элементам DOM с помощью методов addEventListener() или встроенных атрибутов HTML, таких как onclick, onmouseover, и т. д.
При разработке веб-приложений важно понимать различные типы событий DOM и уметь использовать их для создания интерактивных и отзывчивых пользовательских интерфейсов.


### Working with Mouse and Keyboard Events.
Работа с событиями мыши и клавиатуры в веб-приложениях играет важную роль в создании интерактивного пользовательского интерфейса. С помощью событий мыши и клавиатуры можно отслеживать действия пользователя, такие как щелчки мышью, нажатия клавиш и другие взаимодействия. Давайте рассмотрим основные аспекты работы с этими типами событий подробнее:
Работа с событиями мыши:
click: Происходит при клике на элемент.
element.addEventListener('click', () => {
  console.log('Кликнули на элемент');
});
mouseover, mouseout: Происходит при наведении курсора мыши на элемент и его убирании.
element.addEventListener('mouseover', () => {
  console.log('Курсор наведен на элемент');
});
element.addEventListener('mouseout', () => {
  console.log('Курсор убран с элемента');
});
mousedown, mouseup: Происходит при нажатии и отпускании кнопки мыши над элементом.
element.addEventListener('mousedown', () => {
  console.log('Кнопка мыши нажата');
});
element.addEventListener('mouseup', () => {
  console.log('Кнопка мыши отпущена');
});
Работа с событиями клавиатуры:
keydown, keyup: Происходит при нажатии и отпускании клавиши на клавиатуре.
document.addEventListener('keydown', event => {
  console.log(`Нажата клавиша: ${event.key}`);
});
document.addEventListener('keyup', event => {
  console.log(`Отпущена клавиша: ${event.key}`);
});
Обработка нажатия клавиш с помощью кодов клавиш:
document.addEventListener('keydown', event => {
  if (event.key === 'Enter') {
    console.log('Нажата клавиша Enter');
  }
});
Примечания:
События мыши и клавиатуры могут быть использованы для создания интерактивных элементов управления, игр, форм и других веб-компонентов.
Обработчики событий мыши и клавиатуры могут быть привязаны к любому элементу DOM с помощью метода addEventListener().
В обработчиках событий мыши и клавиатуры можно использовать объект события для получения дополнительной информации о событии, такой как нажатая клавиша или координаты мыши.

### Handling Form and Input Events.
Обработка событий формы и ввода данных в веб-приложениях является важной частью создания интерактивных пользовательских интерфейсов. События формы и ввода позволяют отслеживать изменения в полях ввода, отправку формы и другие взаимодействия пользователя с элементами формы. Давайте рассмотрим основные аспекты работы с этими типами событий подробнее:

События формы:
submit: Происходит при отправке формы.
const form = document.querySelector('form');
form.addEventListener('submit', event => {
  event.preventDefault(); // Отменяет стандартное поведение отправки формы
  console.log('Форма отправлена');
});
reset: Происходит при сбросе формы.
form.addEventListener('reset', () => {
  console.log('Форма сброшена');
});
События ввода данных:
input: Происходит при изменении значения поля ввода.
const input = document.querySelector('input');

input.addEventListener('input', () => {
  console.log('Изменено значение поля ввода:', input.value);
});
change: Происходит при изменении значения поля ввода и потере им фокуса.
input.addEventListener('change', () => {
  console.log('Изменено значение поля ввода и потерян фокус:', input.value);
});
События фокуса:
focus: Происходит при получении фокуса элементом формы.
input.addEventListener('focus', () => {
  console.log('Получен фокус на поле ввода');
});
blur: Происходит при потере фокуса элементом формы.
input.addEventListener('blur', () => {
  console.log('Потерян фокус на поле ввода');
});
Примечания:
Обработчики событий формы и ввода данных могут быть привязаны к любым элементам формы, таким как текстовые поля, кнопки отправки и сброса формы, элементы выбора и т. д.
События формы, такие как submit и reset, позволяют вам контролировать отправку и сброс формы, а события ввода данных, такие как input и change, позволяют реагировать на изменения значений полей ввода в реальном времени.
При обработке событий формы и ввода данных можно использовать объект события для получения дополнительной информации о событии, такой как значения полей ввода или тип события.

### Event Listeners.
События и слушатели событий (Event Listeners) являются важным механизмом взаимодействия JavaScript с элементами HTML. Они позволяют вашему приложению реагировать на действия пользователя, такие как клики, наведение мыши, ввод данных и многое другое. Давайте рассмотрим основные аспекты работы событий и слушателей событий:
Добавление слушателей событий:
Вы можете добавить слушатели событий к элементам DOM с помощью метода addEventListener().
const button = document.querySelector('button');
button.addEventListener('click', () => {
  console.log('Кнопка была нажата');
});
Обработчики событий:
Функция, переданная в addEventListener(), называется обработчиком события. Она будет выполнена при наступлении события.
const button = document.querySelector('button');
function handleClick() {
  console.log('Кнопка была нажата');
}
button.addEventListener('click', handleClick);
Удаление слушателей событий:
Вы можете удалить слушателей событий с помощью метода removeEventListener().
const button = document.querySelector('button');
function handleClick() {
  console.log('Кнопка была нажата');
}
button.addEventListener('click', handleClick);
// Удаление слушателя
button.removeEventListener('click', handleClick);
Объект события:
Обработчики событий получают объект события, который содержит информацию о событии, такую как тип события, целевой элемент и многое другое.
const button = document.querySelector('button');

button.addEventListener('click', event => {
  console.log('Тип события:', event.type);
  console.log('Целевой элемент:', event.target);
});
Примечания:
События и слушатели событий позволяют создавать интерактивные пользовательские интерфейсы и реагировать на действия пользователя.
Вы можете добавлять несколько слушателей событий к одному элементу, а также удалять их при необходимости.
Обработчики событий могут быть анонимными функциями или именованными функциями.
В обработчиках событий можно использовать объект события для доступа к дополнительной информации о событии.

### Event Phases and their differences.
Фазы событий в DOM (Document Object Model) определяют порядок, в котором события обрабатываются при их возникновении. Событие проходит через три основные фазы: захват (capture), цель (target) и всплытие (bubble). Рассмотрим каждую фазу подробнее:
1. Фаза захвата (Capture Phase):
В этой фазе событие начинает свой путь с корневого элемента DOM и спускается по иерархии DOM к целевому элементу. Во время этой фазы событие не достигает целевого элемента, но слушатели событий, установленные на предках целевого элемента, могут перехватывать и обрабатывать событие.
2. Фаза цели (Target Phase):
В этой фазе событие достигает целевого элемента, на котором произошло событие. Событие вызывает все слушатели событий, установленные непосредственно на целевом элементе. Эта фаза является пунктом входа в обработку события для этого элемента.
3. Фаза всплытия (Bubble Phase):
После завершения фазы цели событие начинает свой путь обратно к корневому элементу DOM. Во время этой фазы событие всплывает по иерархии DOM, вызывая слушатели событий на каждом предке целевого элемента. Это позволяет реализовать обработку событий вверх по иерархии элементов.
Различия между фазами:
Цель vs. Погружение: В фазе цели событие достигает элемента, на котором произошло событие, в то время как в фазе погружения событие движется от корневого элемента к целевому элементу.
Порядок обработки: Событие проходит через фазы в определенном порядке: сначала захват, затем цель, и, наконец, всплытие.
Обработка слушателей: В каждой фазе события вызываются только те слушатели, которые были установлены на элементах, принимающих участие в данной фазе.
Использование фаз событий позволяет более гибко управлять обработкой событий и реализовывать различные сценарии взаимодействия с пользователем.

### Custom events (optional).
Пользовательские события (Custom events) - это механизм в JavaScript, который позволяет создавать и запускать собственные события. В отличие от встроенных браузерных событий, пользовательские события могут быть определены и использованы в вашем коде для обмена информацией между различными частями вашего приложения. Давайте рассмотрим подробнее:
Создание пользовательского события:
Для создания пользовательского события используется конструктор CustomEvent.
// Создание пользовательского события с именем "customEvent"
const customEvent = new CustomEvent('customEvent', {
  detail: { message: 'Привет, мир!' } // Дополнительные данные, передаваемые событию
});
Добавление слушателя пользовательского события:
После создания пользовательского события можно добавить слушателя, который будет реагировать на это событие.
// Добавление слушателя пользовательского события
document.addEventListener('customEvent', event => {
  console.log('Сообщение из пользовательского события:', event.detail.message);
});
Запуск пользовательского события:
После создания и настройки пользовательского события, его можно запустить с помощью метода dispatchEvent().
// Запуск пользовательского события
document.dispatchEvent(customEvent);
Передача данных через пользовательское событие:
Вы можете передать дополнительные данные через пользовательское событие, используя свойство detail в объекте конфигурации события при его создании. Эти данные будут доступны в обработчике события через свойство event.detail.
Преимущества пользовательских событий:
Гибкость: Пользовательские события позволяют создавать собственные механизмы взаимодействия между частями вашего приложения.
Масштабируемость: Они упрощают разработку крупных и сложных приложений, позволяя модулям взаимодействовать без прямой зависимости друг от друга.
Расширяемость: Вы можете расширять функциональность вашего кода, добавляя новые пользовательские события для определенных действий или событий.
Использование пользовательских событий может значительно улучшить структуру вашего кода и обеспечить более эффективное взаимодействие между его различными частями.

Events Propagation / Preventing
### Event propagation cycle.
Цикл распространения события (Event propagation cycle) описывает последовательность этапов, через которые проходит событие от момента его возникновения до обработки всеми слушателями. Этот процесс состоит из трех основных фаз: захват (capture), цель (target), и всплытие (bubble). Давайте рассмотрим каждую фазу подробнее:
1. Фаза захвата (Capture Phase):
В этой фазе событие начинает свой путь с корневого элемента DOM и движется вниз по иерархии DOM к целевому элементу. Во время этой фазы событие не достигает целевого элемента, но слушатели событий, установленные на предках целевого элемента, могут перехватывать и обрабатывать событие.
2. Фаза цели (Target Phase):
В этой фазе событие достигает целевого элемента, на котором произошло событие. Событие вызывает все слушатели событий, установленные непосредственно на целевом элементе. Эта фаза является пунктом входа в обработку события для этого элемента.
3. Фаза всплытия (Bubble Phase):
После завершения фазы цели событие начинает свой путь обратно к корневому элементу DOM. Во время этой фазы событие всплывает по иерархии DOM, вызывая слушатели событий на каждом предке целевого элемента. Это позволяет реализовать обработку событий вверх по иерархии элементов.
Порядок обработки:
События проходят через фазы в определенном порядке: сначала захват, затем цель, и, наконец, всплытие. Этот порядок позволяет реализовать различные сценарии взаимодействия с пользователем и обеспечивает гибкость при обработке событий.
Примечания:
Обработчики событий могут быть установлены как на захват, так и на всплытие, используя третий аргумент метода addEventListener() (true для захвата и false или опущенный для всплытия).
Порядок обработки событий позволяет реализовать различные сценарии взаимодействия с пользователем и обеспечивает гибкость при обработке событий.
Понимание цикла распространения событий помогает эффективно управлять взаимодействием пользовательского интерфейса в вашем веб-приложении.

### Stopping event propagation.
Остановка распространения события (Stopping event propagation) - это процесс предотвращения дальнейшего распространения события вверх или вниз по иерархии DOM. Это полезный механизм, который позволяет контролировать, какие элементы должны обрабатывать событие, а какие нет. Давайте рассмотрим, как можно остановить распространение события подробнее:
Остановка распространения во время захвата и всплытия:
stopPropagation(): Метод stopPropagation() вызывается на объекте события и предотвращает дальнейшее распространение события вверх или вниз по иерархии DOM.
element.addEventListener('click', event => {
  event.stopPropagation(); // Остановить распространение события
  console.log('Событие обработано на этом элементе');
});
Остановка распространения во время захвата:
В случае захвата, можно использовать третий аргумент метода addEventListener(), чтобы установить слушателя события в режим захвата. В этом случае событие будет перехвачено на самом раннем этапе, ещё до достижения целевого элемента.
element.addEventListener('click', event => {
  console.log('Событие захвачено на этом элементе');
}, true); // Установка режима захвата
Примечания:
Использование stopPropagation() может быть полезным, когда вы хотите предотвратить вызов слушателей событий на родительских или дочерних элементах определенного элемента.
Остановка распространения события может быть полезна для предотвращения неожиданных взаимодействий между различными частями интерфейса или конфликтов между различными компонентами приложения.
Будьте осторожны при использовании stopPropagation(), чтобы не создать ситуацию, когда некоторые элементы перестают реагировать на события вообще.

### Preventing default browser behavior.
Предотвращение стандартного поведения браузера (Preventing default browser behavior) - это процесс предотвращения выполнения действия по умолчанию, которое обычно происходит при возникновении определенного события. Например, клик по ссылке перенаправляет нас на другую страницу, а отправка формы загружает новую страницу или обновляет текущую. Предотвращение этого стандартного поведения может быть полезным для реализации более интерактивных пользовательских интерфейсов. Давайте рассмотрим, как можно предотвратить стандартное поведение браузера подробнее:
Использование preventDefault():
preventDefault(): Метод preventDefault() вызывается на объекте события и предотвращает выполнение стандартного действия, связанного с событием.
element.addEventListener('click', event => {
  event.preventDefault(); // Предотвратить стандартное действие браузера
  console.log('Стандартное действие предотвращено');
});
Применение к различным типам событий:
Для ссылок (click): Предотвращение перехода по ссылке.
document.querySelector('a').addEventListener('click', event => {
  event.preventDefault();
});
Для форм (submit): Предотвращение отправки формы.
document.querySelector('form').addEventListener('submit', event => {
  event.preventDefault();
});
Примечания:
Предотвращение стандартного поведения браузера особенно полезно при разработке веб-приложений с использованием AJAX или SPA (Single Page Application), где страницы не перезагружаются при многих взаимодействиях пользователя.
При использовании preventDefault() убедитесь, что вы предоставляете пользователю альтернативные способы выполнения действий, которые могут быть предотвращены. Например, предоставьте кнопку "Отмена" для форм или инструкции о том, что произойдет после клика по ссылке.

### Event delegation and its pros/cons.
Делегирование событий (Event delegation) - это паттерн в JavaScript, который позволяет обрабатывать события на родительском элементе вместо непосредственно на дочерних элементах. При использовании этого паттерна события "всплывают" вверх по DOM-дереву, что позволяет обрабатывать их на более высоком уровне, чем на конкретном элементе. Давайте рассмотрим подробнее, как работает делегирование событий и его преимущества и недостатки:
Принцип работы:
Установка обработчика на родительский элемент: Обработчик события устанавливается на родительский элемент, который содержит целевые элементы, на которые вы хотите реагировать.
Использование событий всплытия (bubbling): События всплывают от дочерних элементов к родительским, что позволяет обрабатывать их на родительском элементе.
Определение целевого элемента: В обработчике события можно определить целевой элемент, на котором произошло событие, и выполнить соответствующие действия.
Преимущества:
Уменьшение количества обработчиков: При использовании делегирования событий вы можете установить один обработчик на родительский элемент вместо установки обработчика на каждый дочерний элемент, что может существенно уменьшить количество обработчиков и улучшить производительность.
Работает с динамически создаваемыми элементами: Делегирование событий позволяет обрабатывать события на элементах, которые были добавлены в DOM после установки обработчика, что делает его особенно полезным для работы с динамически создаваемыми элементами.
Недостатки:
Сложнее определить целевой элемент: При обработке событий на родительском элементе может быть сложнее определить, на каком именно дочернем элементе произошло событие, особенно если у вас есть много разных дочерних элементов.
Не подходит для всех случаев: Делегирование событий может быть неудобным в случаях, когда необходимо обрабатывать события на конкретных дочерних элементах с разными обработчиками.
Пример:
// HTML
<ul id="myList">
  <li>Элемент 1</li>
  <li>Элемент 2</li>
  <li>Элемент 3</li>
</ul>
// JavaScript
document.getElementById('myList').addEventListener('click', function(event) {
  if (event.target.tagName === 'LI') {
    console.log('Вы нажали на элемент:', event.target.textContent);
  }
});
Заключение:
Делегирование событий - это мощный и эффективный паттерн в JavaScript, который позволяет управлять событиями более эффективно, особенно при работе с большим количеством элементов или динамически создаваемыми элементами. Однако важно учитывать его ограничения и правильно применять в контексте вашего приложения.

Timers
### Usage of setTimeout / setInterval.
Функции setTimeout() и setInterval() - это методы JavaScript, которые позволяют выполнить код через определенный интервал времени. Вот как они работают и как их использовать:
setTimeout():
setTimeout() используется для запуска выполнения функции один раз через определенный промежуток времени.
setTimeout(function() {
  console.log('Этот код выполнится один раз через 2 секунды');
}, 2000); // 2000 миллисекунд (2 секунды)
Применения setTimeout():
Запуск анимаций: Вы можете использовать setTimeout() для создания анимаций, изменяя стили элементов через определенные интервалы времени.
Обновление данных: Приложения могут использовать setTimeout() для периодического обновления данных с сервера или других источников данных без перезагрузки страницы.
setInterval():
setInterval() позволяет запускать выполнение функции регулярно через определенные интервалы времени.
setInterval(function() {
  console.log('Этот код будет выполняться каждые 3 секунды');
}, 3000); // 3000 миллисекунд (3 секунды)
Применения setInterval():
Автообновление: Используйте setInterval(), чтобы регулярно обновлять данные или состояние вашего приложения без необходимости вручную обновлять страницу.
Регулярные оповещения: Можно использовать setInterval(), чтобы создавать регулярные оповещения или уведомления для пользователя.
Преимущества и недостатки:
Преимущества:
Простота использования и понимания.
Удобство для выполнения операций через определенные промежутки времени.
Недостатки:
Различные проблемы с производительностью, особенно при использовании setInterval() для коротких интервалов или интенсивных операций.
Риск переполнения очереди событий, если код внутри setTimeout() или setInterval() выполняется дольше, чем интервал между вызовами.
Заключение:
setTimeout() и setInterval() - это мощные инструменты для выполнения кода через определенные промежутки времени в JavaScript. Однако необходимо использовать их осторожно, учитывая их влияние на производительность и потенциальные проблемы с обработкой событий.

### Clearing timers with clearTimeout / clearInterval.
clearTimeout() и clearInterval() используются для отмены выполнения кода, запланированного с помощью setTimeout() и setInterval() соответственно. Давайте рассмотрим их подробнее:
clearTimeout():
clearTimeout() используется для отмены выполнения кода, который был запланирован с помощью setTimeout().
const timerId = setTimeout(function() {
  console.log('Этот код не будет выполнен');
}, 2000);
clearTimeout(timerId); // Отмена выполнения кода, запланированного с setTimeout()
Примечания по clearTimeout():
clearTimeout() принимает один аргумент - идентификатор таймера, возвращаемый функцией setTimeout().
Если clearTimeout() вызывается до истечения времени, указанного в setTimeout(), то запланированный код не будет выполнен.
clearInterval():
clearInterval() используется для отмены выполнения кода, который был запланирован с помощью setInterval().
const intervalId = setInterval(function() {
  console.log('Этот код выполняется каждые 3 секунды');
}, 3000);
clearInterval(intervalId); // Отмена выполнения кода, запланированного с setInterval()
Примечания по clearInterval():
clearInterval() также принимает один аргумент - идентификатор таймера, возвращаемый функцией setInterval().
Если clearInterval() вызывается, то код, запланированный с помощью setInterval(), больше не будет выполняться с заданным интервалом.
Преимущества использования:
Позволяет управлять выполнением кода, запланированного с помощью таймеров, что может быть полезно при динамическом изменении времени выполнения или при необходимости остановки повторяющегося кода.
Заключение:
clearTimeout() и clearInterval() - это важные инструменты в JavaScript для управления таймерами и предотвращения выполнения запланированного кода. Правильное использование этих функций помогает избежать проблем с производительностью и ненужного выполнения кода.


Web Storage API & Cookies
### Differences between LocalStorage, SessionStorage, and Cookies.
LocalStorage, SessionStorage и Cookies - это три основных механизма для хранения данных на стороне клиента в веб-приложениях. Вот их подробное сравнение:
Cookies:
Хранение данных: Cookies хранят данные в виде пар ключ-значение в виде текста на стороне клиента. Каждое хранимое значение имеет свою длину ограниченную примерно 4 кб.
Использование: Cookies отправляются автоматически с каждым HTTP-запросом, что делает их подходящими для хранения данных, которые необходимо передавать между клиентом и сервером.
Хранение сроков действия: Можно задать срок действия для cookies, после которого они будут удалены. Они могут быть постоянными (сохраняются на диск клиента) или сеансовыми (удаляются при закрытии браузера).
LocalStorage:
Хранение данных: LocalStorage также хранит данные в виде пар ключ-значение, но в отличие от cookies, они хранятся в браузере без отправки на сервер. Максимальный размер хранимых данных составляет примерно 5-10 МБ для большинства браузеров.
Использование: LocalStorage может использоваться для хранения данных, которые должны сохраняться между сеансами браузера и не требуют отправки на сервер.
Срок хранения: Данные в LocalStorage сохраняются даже после закрытия браузера и могут быть доступны при последующих посещениях сайта.
SessionStorage:
Хранение данных: SessionStorage аналогичен LocalStorage, но хранит данные только на время сеанса. Это означает, что данные будут удалены, когда пользователь закроет вкладку или браузер.
Использование: SessionStorage полезен для хранения временных данных, которые должны быть доступны только в течение одного сеанса.
Сравнение:
Производительность: Cookies могут замедлить загрузку веб-страницы, так как они отправляются с каждым HTTP-запросом. LocalStorage и SessionStorage не влияют на производительность загрузки страницы.
Безопасность: Cookies можно защитить от доступа через определенные параметры. LocalStorage и SessionStorage доступны только для JavaScript на странице, поэтому могут быть менее безопасными.
Емкость: Cookies имеют меньший объем хранения данных по сравнению с LocalStorage и SessionStorage.
Использование:
Cookies часто используются для аутентификации, отслеживания сеансов и хранения предпочтений пользователя.
LocalStorage и SessionStorage используются для хранения состояния приложения, кэширования данных и других временных данных, которые не требуют отправки на сервер.
Заключение:
Каждый из механизмов хранения данных имеет свои преимущества и недостатки, и правильный выбор зависит от требований вашего веб-приложения. Cookies подходят для обмена данными между клиентом и сервером, в то время как LocalStorage и SessionStorage обеспечивают удобное хранение данных на стороне клиента для временного или постоянного использования.

Date & Time (optional)
### Working with the Date object.
Объект Date в JavaScript используется для работы с датами и временем. Он позволяет создавать объекты, представляющие дату и время, а также выполнять множество операций с ними. Вот подробное рассмотрение работы с объектом Date:

Создание объекта Date:
const currentDate = new Date(); // Создание объекта с текущей датой и временем
const specificDate = new Date('2022-12-31'); // Создание объекта с конкретной датой
const specificTime = new Date(2022, 11, 31, 12, 30, 0); // Создание объекта с конкретным временем
Получение компонентов даты и времени:
const year = currentDate.getFullYear(); // Получение года (четыре цифры)
const month = currentDate.getMonth(); // Получение месяца (0-11)
const date = currentDate.getDate(); // Получение дня месяца (1-31)
const hours = currentDate.getHours(); // Получение часов (0-23)
const minutes = currentDate.getMinutes(); // Получение минут (0-59)
const seconds = currentDate.getSeconds(); // Получение секунд (0-59)
Работа с датами и временем:
currentDate.setDate(currentDate.getDate() + 1); // Добавление одного дня
currentDate.setMonth(currentDate.getMonth() + 1); // Добавление одного месяца
currentDate.setHours(currentDate.getHours() + 1); // Добавление одного часа
Форматирование даты и времени:

const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
const formattedDate = currentDate.toLocaleDateString('en-US', options);
Получение времени в миллисекундах:
const currentTimeInMillis = currentDate.getTime();
Работа с разницей во времени:
const otherDate = new Date('2023-01-01');
const timeDifference = otherDate - currentDate; // Разница в миллисекундах между двумя датами
Пример использования:
const birthday = new Date('2000-10-15');
const today = new Date();
const age = today.getFullYear() - birthday.getFullYear();
Заключение:
Объект Date предоставляет широкий спектр методов для работы с датами и временем в JavaScript. Он позволяет создавать, форматировать, изменять и сравнивать даты, а также выполнять множество других операций. При использовании объекта Date важно учитывать его особенности, такие как нумерация месяцев с 0 и различия в поддержке методов между разными браузерами.

### Timezones and Internationalization in JavaScript (Intl).
Работа с часовыми поясами (Timezones) и интернационализацией (Internationalization) в JavaScript включает в себя использование объекта Intl для форматирования дат, времени, чисел и валют в соответствии с различными локализациями и часовыми поясами. Давайте подробнее рассмотрим использование Intl:

Форматирование даты и времени:
const now = new Date();
const dateFormatter = new Intl.DateTimeFormat('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
const formattedDate = dateFormatter.format(now); // Выводит дату в формате "Wednesday, April 6, 2022"
Форматирование чисел:
const number = 123456.789;
const numberFormatter = new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' });
const formattedNumber = numberFormatter.format(number); // Выводит число в формате "123.456,79 €"
Форматирование валюты:
const currency = 123456.78;
const currencyFormatter = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' });
const formattedCurrency = currencyFormatter.format(currency); // Выводит валюту в формате "$123,456.78"
Работа с часовыми поясами:
const timeZone = 'America/New_York';
const timeFormatter = new Intl.DateTimeFormat('en-US', { timeZone: timeZone, timeStyle: 'medium' });
const formattedTime = timeFormatter.format(now); // Выводит время в часовом поясе "America/New_York"
Локализация:
const language = 'fr-FR';
const dateFormatterFR = new Intl.DateTimeFormat(language, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
const formattedDateFR = dateFormatterFR.format(now); // Выводит дату на французском языке
Обработка ошибок:
try {
  const invalidDate = new Date('invalid');
} catch (error) {
  console.error('Invalid date:', error.message);
}
Заключение:
Объект Intl в JavaScript предоставляет мощные средства для форматирования дат, времени, чисел и валюты, а также для работы с часовыми поясами и локализацией. Он позволяет создавать приложения, которые могут адаптироваться к различным культурным и локальным настройкам, что делает его важным инструментом для международной разработки веб-приложений.

Design Patterns
Intermediate Knowledge
### Understanding and applying KISS, DRY, and YAGNI principles.

Coding tasks:

Coding Tasks Examples

### Array.flat Polyfill
Implement a polyfill for the Array.flat method. This method should flatten an array up to the specified depth, handling cases where the depth is not provided (default to 1) or when it's an infinite depth.

// Проверяем, существует ли метод flat в массивах
if (!Array.prototype.flat) {
    // Определяем полифилл для метода flat
    Array.prototype.flat = function(depth = 1) {
        // Создаем функцию flatten для рекурсивного сглаживания массива
        const flatten = (arr, currDepth) => {
            // Если текущая глубина достигла максимальной глубины или массив пуст, возвращаем массив
            if (currDepth === depth || arr.length === 0) {
                return arr;
            }

            // Используем метод reduce для сбора всех элементов массива в один массив
            return arr.reduce((acc, val) => {
                // Если текущий элемент является массивом, вызываем функцию flatten рекурсивно
                if (Array.isArray(val)) {
                    // Сглаживаем вложенный массив с увеличением текущей глубины на 1
                    acc.push(...flatten(val, currDepth + 1));
                } else {
                    // Если текущий элемент не является массивом, добавляем его в результирующий массив
                    acc.push(val);
                }
                return acc;
            }, []);
        };

        // Вызываем функцию flatten для текущего массива с начальной глубиной 0
        return flatten(this, 0);
    };
}

### Array.reduce Polyfill
Write a polyfill for the Array.reduce method. Ensure your implementation handles all the functionalities of the native reduce method, including the accumulator and current value parameters, as well as the optional initial value.
if (!Array.prototype.reduce) {
    // Если метод reduce еще не определен в прототипе массивов
    Array.prototype.reduce = function(callback, initialValue) {
        // Проверяем, что переданный callback является функцией
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        // Инициализируем переменные
        const array = this; // Получаем текущий массив
        let accumulator = initialValue !== undefined ? initialValue : array[0]; // Инициализируем аккумулятор начальным значением
        // Проходим по массиву и вызываем callback для каждого элемента
        for (let i = initialValue !== undefined ? 0 : 1; i < array.length; i++) {
            if (i in array) {
                accumulator = callback.call(undefined, accumulator, array[i], i, array);
            }
        }
        // Возвращаем итоговое значение аккумулятора
        return accumulator;
    };
}

### String Repeater
Create a method that extends the String prototype to repeat a given string a specified number of times. For example, calling 'hello world'.repeating(3) should return 'hello world hello world hello world'. The method should handle edge cases like non-integer repeat times and negative numbers.
String.prototype.repeating = function(times) {
    // Проверяем, является ли times числом и не является ли отрицательным
    if (typeof times !== 'number' || !Number.isInteger(times) || times <= 0) {
        throw new Error('Invalid repeat times');
    }
    // Инициализируем пустую строку, в которую будем добавлять повторения
    let repeatedString = '';
    // Повторяем исходную строку указанное количество раз
    for (let i = 0; i < times; i++) {
        repeatedString += this + ' '; // Добавляем пробел после каждого повторения
    }
    // Удаляем лишний пробел в конце строки
    repeatedString = repeatedString.trim();
    return repeatedString;
};
// Пример использования:
console.log('hello world'.repeating(3));


### String.prototype.padStart Polyfill
Write a polyfill for the String.prototype.padStart method. It should pad the current string from the start with another string (multiple times if necessary) until the resulting string reaches the given length.
if (!String.prototype.padStart) {
    String.prototype.padStart = function(targetLength, padString) {
        // Преобразуем текущую строку в строку
        let str = String(this);
        // Проверяем, если нужно добавлять пустые пространства
        if (padString === undefined) {
            padString = ' ';
        }
        // Проверяем, если строка уже длиннее или равна целевой длине
        if (str.length >= targetLength) {
            return str;
        }
        // Вычисляем, сколько символов нужно добавить
        const padLength = targetLength - str.length;
        // Строим строку с пустыми пространствами
        const padding = padString.repeat(Math.ceil(padLength / padString.length)).substring(0, padLength);
        // Возвращаем объединенную строку
        return padding + str;
    };
}
// Пример использования:
console.log('abc'.padStart(10)); // Выводит '       abc'
console.log('abc'.padStart(10, '123')); // Выводит '1231231abc'

### Custom setTimeout Implementation
Implement a custom version of setTimeout using only Date and a while loop, without using the native setTimeout function.
function customSetTimeout(callback, delay) {
    // Получаем текущее время
    const startTime = new Date().getTime();
    // Запускаем цикл, который будет выполняться, пока не истечет время ожидания
    while (new Date().getTime() < startTime + delay) {
        // Пустое тело цикла, ничего не делаем
    }
    // Как только время ожидания истекло, вызываем функцию обратного вызова
    callback();
}
// Пример использования:
console.log('Start');
customSetTimeout(() => {
    console.log('Hello after 2000 milliseconds');
}, 2000);
console.log('End');

### Memoization Function
Create a function that implements memoization to cache and return the results of expensive function calls.
function memoization(func) {
    const cache = {}; // Объект для кэширования результатов
    return function(...args) {
        const key = JSON.stringify(args); // Создаем ключ на основе аргументов функции
        if (!(key in cache)) { // Проверяем, есть ли результат в кэше
            cache[key] = func.apply(this, args); // Вызываем функцию с переданными аргументами и сохраняем результат в кэше
        }
        return cache[key]; // Возвращаем результат из кэша
    };
}

### Currying Logger:
Develop a curryLogger function that takes a logging function and returns a curried version of this function.
Функция "curryLogger" должна принимать функцию журналирования (например, console.log) и возвращать каррированную версию этой функции. Каррированная функция позволяет вызывать исходную функцию с частичным набором аргументов и возвращает новую функцию, которая ожидает оставшиеся аргументы.
Вот пример решения на JavaScript:
function curryLogger(logger) {
    return function(...args) {
        return function(...innerArgs) {
            logger(...args, ...innerArgs); // Вызываем функцию журналирования с аргументами и внутренними аргументами
        };
    };
}
В этом решении:
Функция curryLogger принимает функцию журналирования (logger) в качестве аргумента.
Возвращается анонимная функция, которая принимает аргументы (args).
Внутри анонимной функции создается еще одна анонимная функция, которая принимает внутренние аргументы (innerArgs).
Внутренняя анонимная функция вызывает функцию журналирования (logger) с объединенными внешними и внутренними аргументами.
Теперь мы можем использовать curryLogger для каррирования функции журналирования:
// Создаем каррированную версию функции журналирования console.log
const curriedLogger = curryLogger(console.log);
// Журналируем сообщение "Hello, World!" с использованием каррированной функции
curriedLogger("Hello, World!"); // Выводит "Hello, World!"
Таким образом, мы можем использовать curryLogger для создания каррированных версий любой функции журналирования, что позволяет нам удобно использовать ее с частичным набором аргументов.

### Arguments Reverser
Implement a function that reverses the order of arguments it receives, returning a new function with reversed arguments.
Для этой задачи вам нужно реализовать функцию, которая принимает другую функцию в качестве аргумента и возвращает новую функцию, которая принимает аргументы в обратном порядке.

Вот пример того, как это можно сделать на JavaScript:
function reverseArguments(func) {
    return function(...args) {
        return func(...args.reverse());
    };
}
Это решение включает в себя:
Функция reverseArguments, которая принимает функцию func в качестве аргумента.
Возвращение анонимной функции, которая принимает любое количество аргументов через оператор ...args.
Внутри анонимной функции вызывается функция func с аргументами, которые были развернуты с помощью метода reverse().
Теперь вы можете использовать эту функцию для создания новой функции с аргументами, переданными в обратном порядке:
function exampleFunc(a, b, c) {
    console.log(a, b, c);
}
const reversedFunc = reverseArguments(exampleFunc);
reversedFunc(1, 2, 3); // Выведет "3 2 1"

### Private Counter Closure
Craft a function that uses closures to create a private counter, which can only be modified through specific methods.
Для этой задачи вам нужно создать функцию, которая будет использовать замыкания для создания приватного счетчика, который может быть изменен только через определенные методы. Это означает, что счетчик будет доступен только внутри этой функции, и его значение можно будет изменить только с помощью специальных методов, которые мы предоставим.

Вот пример, как это можно сделать на JavaScript:
function createCounter() {
    let count = 0; // Приватная переменная счетчика

    return {
        increment: function() { // Метод для увеличения счетчика на 1
            count++;
        },
        decrement: function() { // Метод для уменьшения счетчика на 1
            count--;
        },
        getCount: function() { // Метод для получения текущего значения счетчика
            return count;
        }
    };
}
// Создаем экземпляр объекта счетчика
const counter = createCounter();
// Увеличиваем счетчик на 1
counter.increment();
console.log(counter.getCount()); // Выведет 1
// Уменьшаем счетчик на 1
counter.decrement();
console.log(counter.getCount()); // Выведет 0

### Rest Parameters Sum
Write a function that uses rest parameters to calculate and return the sum of an indefinite number of arguments.
Для решения этой задачи вам нужно создать функцию, которая использует rest-параметры для получения неопределенного количества аргументов и вычисления их суммы.
Вот пример такой функции на JavaScript:
function sum(...args) {
    return args.reduce((total, current) => total + current, 0);
}

### Object Freeze Deep
Create a function that deeply freezes an object, ensuring all nested objects are also frozen.
Для решения этой задачи вам нужно создать функцию, которая рекурсивно замораживает объект, включая все вложенные объекты внутри него.
Вот пример такой функции на JavaScript:
function deepFreeze(obj) {
    // Замораживаем текущий объект
    Object.freeze(obj);
    // Рекурсивно замораживаем все свойства объекта, которые являются объектами
    for (let key in obj) {
        if (obj.hasOwnProperty(key) && typeof obj[key] === 'object' && !Object.isFrozen(obj[key])) {
            deepFreeze(obj[key]);
        }
    }
    return obj;
}
Эта функция deepFreeze принимает объект obj и сначала замораживает его с помощью Object.freeze(). Затем она проходит через все свойства этого объекта и, если какое-то свойство является объектом и не заморожено, рекурсивно замораживает его вызовом deepFreeze.
Теперь вы можете использовать эту функцию, чтобы глубоко заморозить любой объект:
const obj = {
    a: 1,
    b: {
        c: 2,
        d: {
            e: 3
        }
    }
};
deepFreeze(obj);
// Попытка изменить значения объекта
obj.a = 10; // Не сработает, так как объект заморожен
obj.b.c = 20; // Не сработает, так как объект заморожен
obj.b.d.e = 30; // Не сработает, так как объект заморожен

### Array Chunker
Develop a function that divides an array into chunks of a specified size and returns them.
Для решения этой задачи вам нужно создать функцию, которая принимает массив и размер куска (чанка), на которые нужно разделить этот массив, и возвращает массив из чанков.
Вот пример такой функции на JavaScript:
function chunkArray(arr, size) {
    const chunkedArray = []; // Результирующий массив чанков
    for (let i = 0; i < arr.length; i += size) {
        chunkedArray.push(arr.slice(i, i + size)); // Добавляем чанк в результирующий массив
    }
    return chunkedArray;
}
Эта функция chunkArray принимает массив arr и размер size чанка. Затем она использует цикл for, чтобы проходить по массиву arr с шагом size и для каждого элемента массива вызывает метод slice, чтобы получить чанк заданного размера. Этот чанк затем добавляется в результирующий массив chunkedArray.
Теперь вы можете использовать эту функцию для разделения массива на чанки:
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const chunkedArray = chunkArray(array, 3);
console.log(chunkedArray); // Выведет [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
Таким образом, функция chunkArray позволяет разделить массив на чанки заданного размера.

### Custom Array Filter
Implement your own version of the array filter function without using the built-in Array.prototype.filter method.
Для решения этой задачи мы можем создать свою собственную функцию customFilter, которая будет принимать массив и функцию обратного вызова (callback) и возвращать новый массив, содержащий только те элементы, для которых функция обратного вызова возвращает true.
Вот пример такой функции на JavaScript:
function customFilter(arr, callback) {
    const filteredArray = []; // Результирующий массив
    // Проходим по каждому элементу массива
    for (let i = 0; i < arr.length; i++) {
        // Проверяем, соответствует ли текущий элемент условиям функции обратного вызова
        if (callback(arr[i], i, arr)) {
            filteredArray.push(arr[i]); // Добавляем элемент в результирующий массив
        }
    }

    return filteredArray;
}
Эта функция customFilter принимает массив arr и функцию обратного вызова callback. Затем она проходит по каждому элементу массива arr и вызывает функцию callback для каждого элемента с передачей текущего элемента, индекса и самого массива. Если функция callback вернет true для текущего элемента, то он добавляется в результирующий массив filteredArray.
Теперь вы можете использовать эту функцию для фильтрации массива:
const array = [1, 2, 3, 4, 5];
// Функция обратного вызова для проверки четности элементов
function isEven(num) {
    return num % 2 === 0;
}
const filteredArray = customFilter(array, isEven);
console.log(filteredArray); // Выведет [2, 4]
Таким образом, функция customFilter предоставляет альтернативный способ фильтрации массива без использования встроенного метода filter массива.

### DOM Element Selector
Write a function for selecting DOM elements with a specific data attribute and applying a given callback function to them.
Для решения этой задачи мы можем создать функцию selectElementsWithAttribute, которая будет принимать имя атрибута и значение этого атрибута, а также функцию обратного вызова (callback). Функция будет находить все элементы с указанным атрибутом и его значением, применять к ним функцию обратного вызова и возвращать их.
Вот пример такой функции на JavaScript:
function selectElementsWithAttribute(attribute, value, callback) {
    const elements = document.querySelectorAll(`[${attribute}="${value}"]`); // Находим элементы с указанным атрибутом и значением

    // Применяем callback к каждому найденному элементу
    elements.forEach(element => {
        callback(element);
    });
}
Теперь вы можете использовать эту функцию для выбора элементов по их атрибуту и значению, а затем применения к ним функции обратного вызова:
// Пример использования:
// Функция обратного вызова для добавления класса
function addClass(element) {
    element.classList.add('highlight');
}
// Выбираем все элементы с атрибутом data-type и значением 'button' и добавляем им класс 'highlight'
selectElementsWithAttribute('data-type', 'button', addClass);
Этот пример выберет все элементы, у которых атрибут data-type имеет значение 'button', и добавит им класс highlight.


### Что такое политика CORS про что она?

CORS (Cross-Origin Resource Sharing) — это механизм, предназначенный для обеспечения безопасности веб-приложений и позволяющий контролировать, как веб-страницы могут запрашивать ресурсы с других доменов, отличных от того, с которого была загружена текущая страница. CORS решает проблему Same-Origin Policy, которая безопасно ограничивает запросы к ресурсам на других доменах.

Политика CORS определяет, какие ресурсы с других доменов могут быть запрошены и загружены в браузере. Она использует HTTP-заголовки для определения разрешенных и недопустимых операций между разными источниками.

Некоторые ключевые заголовки CORS:
Origin: Определяет источник (origin) запроса.
Access-Control-Allow-Origin: Указывает, какие источники имеют право делать запрос на ресурс. Если значение этого заголовка равно "*", это означает, что любой источник разрешен.
Access-Control-Allow-Methods: Определяет разрешенные методы HTTP для запроса (например, GET, POST).
Access-Control-Allow-Headers: Определяет разрешенные заголовки HTTP.
Access-Control-Allow-Credentials: Указывает, могут ли запросы включать информацию аутентификации (например, куки).
Access-Control-Expose-Headers: Указывает, какие заголовки могут быть доступны в ответе.

CORS предотвращает атаки, такие как Cross-Site Request Forgery (CSRF), обеспечивая контроль того, какой код на странице имеет доступ к ресурсам на других доменах.

###  Если нужно хранить коллецию данных что использовать в зависимости от того какие это данные

В JavaScript существует несколько структур данных, которые могут использоваться для хранения коллекций данных в зависимости от особенностей этих данных и требований к их обработке. Вот несколько наиболее часто используемых структур данных:
Массивы (Array):
Используются для хранения упорядоченных коллекций элементов.
Обеспечивают быстрый доступ к элементам по индексу.
Хорошо подходят, когда порядок элементов важен.
Объекты (Object):
Используются для хранения неупорядоченных коллекций пар ключ-значение.
Позволяют быстро получать доступ к значениям по ключу.
Подходят для представления ассоциативных данных.
Map:
Предоставляет коллекцию пар ключ-значение, где ключи могут быть любого типа данных.
Поддерживает итерацию в порядке вставки.
Обеспечивает более гибкие возможности для определения ключей.
Set:
Предоставляет уникальные значения без дубликатов.
Обеспечивает быстрый поиск элементов.
Подходит, если нужно хранить только уникальные значения.

### Что такое виртуальный DOM в React
В React, виртуальный DOM (Virtual DOM) - это концепция, используемая для улучшения производительности обновления пользовательского интерфейса. Основная идея заключается в том, чтобы минимизировать количество фактических манипуляций с реальным DOM, что может быть ресурсоемким, и вместо этого работать с виртуальным представлением документа.
Процесс обновления виртуального DOM включает следующие шаги:
Изменение состояния:
Когда в React происходит изменение данных (например, изменение состояния компонента), React создает новое виртуальное дерево DOM, представляющее обновленное состояние.
Сравнение виртуальных деревьев:
React сравнивает новое виртуальное дерево DOM с предыдущим (предыдущим виртуальным деревом).
Нахождение различий (Diffing):
React вычисляет различия между двумя виртуальными деревьями, определяя, какие части дерева были добавлены, изменены или удалены.
Генерация пакета изменений (Reconciliation):
На основе вычисленных различий React создает минимальный пакет изменений, который нужно применить к реальному DOM, чтобы отобразить обновленное состояние.
Применение изменений к реальному DOM:
Только необходимые изменения применяются к реальному DOM, минимизируя операции на самом DOM и, таким образом, повышая производительность.
Использование виртуального DOM помогает избежать многих операций прямого взаимодействия с реальным DOM, что может быть медленным и затратным с точки зрения ресурсов. Реакт самостоятельно управляет обновлением и оптимизирует процесс, чтобы обеспечить более эффективные изменения интерфейса пользователя.

### Какие  хуки могут  оптимизировать React?

В React существует несколько хуков, которые могут быть использованы для оптимизации компонентов и улучшения производительности приложения. Ниже перечислены некоторые из таких хуков:
useMemo:
Хук useMemo используется для мемоизации (кэширования) результатов дорогостоящих вычислений.
Он принимает функцию и массив зависимостей и возвращает закэшированное значение, которое будет пересчитано только при изменении зависимостей.
useCallback:
useCallback мемоизирует колбэк-функции, предотвращая их пересоздание при каждом рендере компонента.
Это особенно полезно, когда колбэк используется в качестве зависимости для других хуков, чтобы избежать лишних повторных рендеров.
useEffect:
useEffect позволяет выполнять побочные эффекты в функциональных компонентах, например, подписку на внешние данные или обновление DOM.
Определенное использование useEffect может помочь избежать побочных эффектов и неопределенного поведения.
React.memo:
React.memo - это функция высшего порядка, которая мемоизирует компоненты на основе их пропсов.
Это предотвращает ненужные повторные рендеры компонентов, если их пропсы не изменились.
useRef:
useRef позволяет сохранять мутабельное значение между рендерами без вызова повторного рендера компонента.
Это может быть полезно для сохранения мутабельных данных или для обращения к DOM-элементам напрямую.
Использование этих хуков помогает уменьшить ненужные повторные рендеры, улучшая производительность React-приложений. Важно применять их с умом в зависимости от конкретных требований и контекста приложения.

### методы массива видоизменяющие и нет

Методы, **видоизменяющие** исходный массив:
splice(): Изменяет содержимое массива, удаляя или заменяя существующие элементы и/или добавляя новые элементы.
pop(): Удаляет последний элемент из массива.
push(): Добавляет один или несколько элементов в конец массива.
shift(): Удаляет первый элемент из массива.
unshift(): Добавляет один или несколько элементов в начало массива.
reverse(): Изменяет порядок элементов в массиве на противоположный.
sort(): Сортирует элементы массива.
fill(): Заполняет все элементы массива одним и тем же значением.
copyWithin(): Копирует последовательность элементов массива внутри него самого.
forEach(): Итерирует по элементам массива, применяя функцию к каждому элементу. Внутри функции обратного вызова можно изменять внешние переменные, что может повлиять на исходный массив.

Методы, **не видоизменяющие** исходный массив:
concat(): Создает новый массив, объединяя один или несколько массивов или значений.
slice(): Создает новый массив, выбирая элементы из исходного массива.
map(): Создает новый массив, применяя функцию к каждому элементу исходного массива.
filter(): Создает новый массив, включая только те элементы исходного массива, для которых функция возвращает true.
join(): Создает строку, объединяя все элементы массива с заданным разделителем.
reduce(): Применяет функцию редукции к элементам массива, чтобы получить единое значение. Этот метод возвращает результат редукции, но сам массив не изменяется.

 

1. What is JavaScript?
JavaScript is a high-level, interpreted programming language primarily used for
adding interactivity to web pages.
2. What are the data types in JavaScript?
JavaScript has six primitive data types: string, number, boolean, null, undefined, and
symbol, along with a complex data type called object.
3. What is the difference between null and undefined?
null represents the intentional absence of any object value, while undefined indicates
the absence of a value or an uninitialized variable.
4. What is the DOM in JavaScript?
The Document Object Model (DOM) is a programming interface that represents the
structure of HTML and XML documents. It allows JavaScript to access and manipulate
the content and structure of a webpage.
5. What is an event in JavaScript?
An event is an action or occurrence that happens in the browser, such as a button
click or page load. JavaScript can respond to these events by executing code in
response.
6. What is an anonymous function in JavaScript?
An anonymous function is a function without a name. It can be assigned to a
variable or passed as an argument to another function. They are often used for onetime or callback functions.
7. What are closures in JavaScript?
Closures are functions that have access to variables from an outer function, even
after the outer function has finished executing. They encapsulate data and provide a
way to maintain state between function calls.
8. What is the difference between == and === in JavaScript?
The == operator checks for equality after performing type coercion, while the ===
operator checks for equality without type coercion, ensuring both the value and type
match.
9. What is hoisting in JavaScript?
Hoisting is a JavaScript behavior where variable and function declarations are
moved to the top of their containing scope during the compilation phase, allowing
them to be used before they are declared.
10. What is the this keyword in JavaScript?
The this keyword refers to the object that is currently executing the code. Its value is
determined by how a function is called, and it provides a way to access object
properties and methods within a function.
11. What are the different ways to define a function in JavaScript?
Functions in JavaScript can be defined using function declarations, function
expressions, arrow functions, and methods within objects.
12. What is the purpose of the let keyword in JavaScript?
The let keyword is used to declare block-scoped variables in JavaScript. Variables
declared with let are only accessible within the block where they are defined.
13. What is the purpose of the const keyword in JavaScript?
The const keyword is used to declare block-scoped variables in JavaScript that
cannot be re-assigned. However, it does not make objects or arrays immutable.
14. What are template literals in JavaScript?
Template literals, denoted by backticks (`), are a way to create strings in JavaScript
that support interpolation of variables and multi-line strings.
15. What are JavaScript promises?
Promises are used for asynchronous programming in JavaScript. They represent the
eventual completion (or failure) of an asynchronous operation and allow chaining of
operations using .then() and .catch().
16. What is the async/await syntax in JavaScript?
The async/await syntax is a modern approach to handle asynchronous operations. It
allows writing asynchronous code in a more synchronous-like manner, making it
easier to read and maintain.
17. What are arrow functions in JavaScript?
Arrow functions are a concise syntax for defining functions in JavaScript. They have a
shorter syntax compared to traditional function expressions and inherit the this value
from the enclosing scope.
18. What is event delegation in JavaScript?
Event delegation is a technique where you attach an event listener to a parent
element instead of individual child elements. It allows handling events efficiently,
especially for dynamically added elements.
19. What is the purpose of the map() function in JavaScript?
The map() function is used to create a new array by applying a given function to
each element of an existing array. It allows transforming and manipulating array
elements easily.
20. What is the purpose of the filter() function in JavaScript?
The filter() function is used to create a new array containing elements that pass a
certain condition defined by a provided function. It allows filtering elements from an
array based on specific criteria.
21. What is the purpose of the reduce() function in JavaScript?
The reduce() function is used to reduce an array to a single value by applying a
function to each element and accumulating the result. It is often used to perform
calculations or transformations on arrays.
22. What is a callback function in JavaScript?
A callback function is a function that is passed as an argument to another function
and gets executed at a later time or in response to an event. It enables asynchronous
and event-driven programming.
23. What is the difference between let and var in JavaScript?
The let keyword declares block-scoped variables, while the var keyword declares
function-scoped variables. Variables declared with var are hoisted, while variables
declared with let are not.
24. What are JavaScript modules?
JavaScript modules are reusable pieces of code that encapsulate related
functionality. They allow for better organization, encapsulation, and code reuse in
larger JavaScript applications.
25. What is object destructuring in JavaScript?
Object destructuring is a feature that allows extracting properties from objects and
assigning them to variables. It provides a concise way to extract values and work
with object properties.
26. What are JavaScript classes?
JavaScript classes are a way to define objects with shared properties and behaviors.
They provide a template for creating multiple instances of objects with similar
characteristics.
27. What is inheritance in JavaScript?
Inheritance is a mechanism in JavaScript where an object can inherit properties and
methods from another object. It allows for code reuse and creating hierarchical
relationships between objects.
28. What are JavaScript getters and setters?
Getters and setters are special methods used to get and set the values of object
properties, respectively. They provide control over property access and enable data
validation and encapsulation.
29. What is the purpose of the try/catch statement in JavaScript?
The try/catch statement is used for error handling in JavaScript. It allows catching
and handling exceptions that occur during the execution of a block of code.
30. What is the difference between let and const in JavaScript?
The let keyword is used to declare variables that can be reassigned, while the const
keyword is used to declare variables that are read-only and cannot be reassigned.
31. What is the purpose of the forEach() function in JavaScript?
The forEach() function is used to execute a provided function once for each element
in an array. It provides an easy way to iterate over array elements and perform
operations on them.
32. What is the purpose of the localStorage object in JavaScript?
The localStorage object allows web applications to store key-value pairs locally
within the user's browser. It provides a simple way to store and retrieve data
persistently.
33. What are arrow functions? How are they different from regular functions?
Arrow functions are a concise syntax for defining functions in JavaScript. They have a
shorter syntax compared to regular functions and do not bind their own this value.
34. What is the purpose of the setTimeout() function in JavaScript?
The setTimeout() function is used to schedule the execution of a function after a
specified delay in milliseconds. It allows adding time-based delays to JavaScript
code.
35. What is event bubbling in JavaScript?
Event bubbling is a mechanism in which an event triggered on a specific element will
also trigger the same event on all of its parent elements. It starts from the innermost
element and propagates upwards in the DOM tree.
36. What is the purpose of the fetch() function in JavaScript?
The fetch() function is used to make HTTP requests and fetch resources from the
network. It provides a modern and flexible way to perform asynchronous network
requests.
37. What is the difference between null and undefined?
null is an explicitly assigned value that represents the absence of an object, while
undefined is a value assigned by the JavaScript engine to variables that have been
declared but have not been assigned a value.
38. What is event propagation in JavaScript?
Event propagation is the process of an event being triggered on an element and then
propagating to its parent elements or capturing down from its parent elements. It
allows handling events at different levels of the DOM hierarchy.
39. What is the purpose of the Object.keys() function in JavaScript?
The Object.keys() function is used to extract all the keys of an object and return them
as an array. It provides an easy way to iterate over an object's properties.
40. What is the difference between null and undefined in JavaScript?
null is an assigned value that represents the intentional absence of an object value,
while undefined represents an uninitialized or undefined value, often used as a
default initial value.
41. What is the purpose of the addEventListener() method in JavaScript?
The addEventListener() method is used to attach an event listener to an element. It
allows you to listen for specific events and execute a function when the event is
triggered.
42. What is the purpose of the parentNode property in JavaScript?
The parentNode property is used to access the parent node of an element in the
DOM. It allows traversal and manipulation of the DOM tree by accessing the
immediate parent of an element.
43. What is the purpose of the querySelector() method in JavaScript?
The querySelector() method is used to select the first element that matches a
specified CSS selector. It provides a powerful way to retrieve elements from the DOM
based on CSS selectors.
44. What is the purpose of the querySelectorAll() method in JavaScript?
The querySelectorAll() method is used to select all elements that match a specified
CSS selector. It returns a collection of elements that can be iterated over or accessed
using indexing.
45. What is the difference between querySelector() and getElementById()?
querySelector() is a more versatile method that allows selecting elements based on
any CSS selector, while getElementById() is specifically used to select an element by
its unique id attribute.
46. What is the difference between function declarations and function expressions in
JavaScript?
Function declarations are hoisted and can be called before they are defined, while
function expressions are not hoisted and must be defined before they are called.
47. What is the purpose of the bind() method in JavaScript?
The bind() method is used to create a new function with a specified this value and
initial arguments. It allows explicit binding of the this value within a function.
48. What is the purpose of the call() method in JavaScript?
The call() method is used to invoke a function with a specified this value and
arguments provided individually. It allows borrowing methods from other objects
and explicit invocation of functions.
49. What is the purpose of the apply() method in JavaScript?
The apply() method is used to invoke a function with a specified this value and
arguments provided as an array or an array-like object. It allows borrowing methods
from other objects and explicit invocation of functions.
50. What is the purpose of the Array.isArray() method in JavaScript?
The Array.isArray() method is used to determine whether a given value is an array or
not. It returns true if the value is an array, and false otherwise.
51. What is event capturing in JavaScript?
Event capturing is the process of an event being triggered on an element's parent
elements first, before reaching the target element. It allows capturing events at the
outermost level of the DOM hierarchy.
52. What is event delegation in JavaScript?
Event delegation is a technique where you attach an event listener to a parent
element instead of individual child elements. It allows handling events efficiently,
especially for dynamically added elements.
53. What is the purpose of the startsWith() method in JavaScript?
The startsWith() method is used to check if a string starts with a specified substring.
It returns true if the string starts with the substring, and false otherwise.
54. What is the purpose of the endsWith() method in JavaScript?
The endsWith() method is used to check if a string ends with a specified substring. It
returns true if the string ends with the substring, and false otherwise.
55. What is the purpose of the includes() method in JavaScript?
The includes() method is used to check if a string contains a specified substring. It
returns true if the substring is found, and false otherwise.
56. What is the purpose of the padStart() method in JavaScript?
The padStart() method is used to pad the beginning of a string with a specified
character until it reaches a desired length. It is often used for formatting purposes.
57. What is the purpose of the padEnd() method in JavaScript?
The padEnd() method is used to pad the end of a string with a specified character
until it reaches a desired length. It is often used for formatting purposes.
58. What is the purpose of the charAt() method in JavaScript?
The charAt() method is used to retrieve the character at a specified index in a string.
It returns the character at the specified index or an empty string if the index is out of
range.
59. What is the purpose of the charCodeAt() method in JavaScript?
The charCodeAt() method is used to retrieve the Unicode value of the character at a
specified index in a string. It returns the Unicode value of the character or NaN if the
index is out of range.
60. What is the purpose of the String.fromCharCode() method in JavaScript?
The String.fromCharCode() method is used to create a string from a sequence of
Unicode values. It allows converting Unicode values to their corresponding
characters.
61. What is the purpose of the JSON.stringify() method in JavaScript?
The JSON.stringify() method is used to convert a JavaScript object or value to a JSON
string. It is commonly used for data serialization and communication with web
servers.
62. What is the purpose of the JSON.parse() method in JavaScript?
The JSON.parse() method is used to parse a JSON string and convert it into a
JavaScript object or value. It is commonly used to deserialize JSON data received
from a server.
63. What is the purpose of the encodeURIComponent() function in JavaScript?
The encodeURIComponent() function is used to encode special characters in a URL
component. It ensures that the component can be included in a URL without causing
any parsing errors.
64. What is the purpose of the decodeURIComponent() function in JavaScript?
The decodeURIComponent() function is used to decode URL-encoded components.
It converts URL-encoded characters back to their original form.
65. What is the purpose of the Math.random() function in JavaScript?
The Math.random() function is used to generate a random floating-point number
between 0 (inclusive) and 1 (exclusive). It is often used to introduce randomness in
JavaScript programs.
66. What is the purpose of the Math.floor() function in JavaScript?
The Math.floor() function is used to round a number down to the nearest integer. It
removes the decimal part of the number and returns the largest integer less than or
equal to the given number.
67. What is the purpose of the Math.ceil() function in JavaScript?
The Math.ceil() function is used to round a number up to the nearest integer. It
increases the number to the next higher integer, regardless of the decimal part.
68. What is the purpose of the Math.round() function in JavaScript?
The Math.round() function is used to round a number to the nearest integer. It rounds
the number up or down based on the decimal part.
69. What is the purpose of the Math.max() function in JavaScript?
The Math.max() function is used to find the largest number among a list of
arguments. It returns the highest value passed as an argument.
70. What is the purpose of the Math.min() function in JavaScript?
The Math.min() function is used to find the smallest number among a list of
arguments. It returns the lowest value passed as an argument.
71. What is the purpose of the Math.pow() function in JavaScript?
The Math.pow() function is used to calculate the power of a number. It takes a base
and an exponent as arguments and returns the result of raising the base to the
exponent.
72. What is the purpose of the Math.sqrt() function in JavaScript?
The Math.sqrt() function is used to calculate the square root of a number. It returns
the positive square root of the given number.
73. What is the purpose of the Math.abs() function in JavaScript?
The Math.abs() function is used to calculate the absolute value of a number. It
returns the magnitude of the number without considering its sign.
74. What is the purpose of the Math.floor() and Math.random() functions together?
By combining Math.floor() and Math.random() functions, you can generate a
random integer within a specified range. For example, Math.floor(Math.random() *
10) generates a random integer between 0 and 9.
75. What is the purpose of the Date() constructor in JavaScript?
The Date() constructor is used to create a new JavaScript Date object that
represents a specific date and time. It allows working with dates and performing
various operations on them.
76. What is the purpose of the getFullYear() method in JavaScript Date objects?
The getFullYear() method is used to retrieve the four-digit year value of a JavaScript
Date object. It returns the year as a four-digit number, such as 2023.
77. What is the purpose of the getMonth() method in JavaScript Date objects?
The getMonth() method is used to retrieve the month value of a JavaScript Date
object. It returns a zero-based index, where January is represented by 0 and
December by 11.
78. What is the purpose of the getDate() method in JavaScript Date objects?
The getDate() method is used to retrieve the day of the month value of a JavaScript
Date object. It returns the day as a number between 1 and 31.
79. What is the purpose of the getDay() method in JavaScript Date objects?
The getDay() method is used to retrieve the day of the week value of a JavaScript
Date object. It returns a zero-based index, where Sunday is represented by 0 and
Saturday by 6.
80. What is the purpose of the getHours() method in JavaScript Date objects?
The getHours() method is used to retrieve the hour value of a JavaScript Date object.
It returns the hour as a number between 0 and 23.
81. What is the purpose of the getMinutes() method in JavaScript Date objects?
The getMinutes() method is used to retrieve the minute value of a JavaScript Date
object. It returns the minute as a number between 0 and 59.
82. What is the purpose of the getSeconds() method in JavaScript Date objects?
The getSeconds() method is used to retrieve the second value of a JavaScript Date
object. It returns the second as a number between 0 and 59.
83. What is the purpose of the getFullYear() and getMonth() methods together in
JavaScript Date objects?
By combining the getFullYear() and getMonth() methods, you can retrieve the full
date in a human-readable format. For example, const currentDate = new Date();
const year = currentDate.getFullYear(); const month = currentDate.getMonth();
console.log(year + '-' + (month + 1)); will print the current year and month in the
format 'YYYY-MM'.
84. What is the purpose of the setFullYear() method in JavaScript Date objects?
The setFullYear() method is used to set the year value of a JavaScript Date object. It
allows modifying the year component of a date.
85. What is the purpose of the setMonth() method in JavaScript Date objects?
The setMonth() method is used to set the month value of a JavaScript Date object. It
allows modifying the month component of a date.
86. What is the purpose of the setDate() method in JavaScript Date objects?
The setDate() method is used to set the day of the month value of a JavaScript Date
object. It allows modifying the day component of a date.
87. What is the purpose of the setHours() method in JavaScript Date objects?
The setHours() method is used to set the hour value of a JavaScript Date object. It
allows modifying the hour component of a date.
88. What is the purpose of the setMinutes() method in JavaScript Date objects?
The setMinutes() method is used to set the minute value of a JavaScript Date object.
It allows modifying the minute component of a date.
89. What is the purpose of the setSeconds() method in JavaScript Date objects?
The setSeconds() method is used to set the second value of a JavaScript Date
object. It allows modifying the second component of a date.
90. What is the purpose of the toLocaleString() method in JavaScript Date objects?
The toLocaleString() method is used to convert a JavaScript Date object to a
localized string representation based on the current locale. It considers the user's
time zone and regional settings to format the date and time.
91. What is the purpose of the toDateString() method in JavaScript Date objects?
The toDateString() method is used to convert the date portion of a JavaScript Date
object to a human-readable string representation. It returns the date in the format
'Day Mon DD YYYY', such as 'Thu Jun 24 2023'.
92. What is the purpose of the getTime() method in JavaScript Date objects?
The getTime() method is used to retrieve the timestamp value of a JavaScript Date
object. It returns the number of milliseconds elapsed since January 1, 1970, 00:00:00
UTC.
93. What is the purpose of the setTime() method in JavaScript Date objects?
The setTime() method is used to set the timestamp value of a JavaScript Date
object. It allows modifying the date and time by providing a new timestamp.
94. What is the purpose of the setTimeout() function in JavaScript?
The setTimeout() function is used to execute a specified function or a piece of code
after a delay specified in milliseconds. It is commonly used for delaying the
execution of code or creating timeouts.
95. What is the purpose of the setInterval() function in JavaScript?
The setInterval() function is used to repeatedly execute a specified function or a
piece of code at a fixed interval specified in milliseconds. It is commonly used for
creating intervals and timers.
96. What is the purpose of the clearTimeout() function in JavaScript?
The clearTimeout() function is used to cancel a timeout set by the setTimeout()
function. It clears the scheduled execution of a function before it is triggered.
97. What is the purpose of the clearInterval() function in JavaScript?
The clearInterval() function is used to cancel an interval set by the setInterval()
function. It stops the repeated execution of a function at a fixed interval.
98. What is the purpose of the isNaN() function in JavaScript?
The isNaN() function is used to check if a value is NaN (Not-a-Number). It returns
true if the value is NaN, and false otherwise.
99. What is the purpose of the isFinite() function in JavaScript?
The isFinite() function is used to check if a value is a finite number. It returns true if
the value is a finite number, and false otherwise. It also returns false for NaN, Infinity,
and -Infinity.
100. What is the purpose of the parseFloat() function in JavaScript?
The parseFloat() function is used to parse a string and extract a floating-point
number from it. It converts the initial portion of the string that represents a valid
floating-point number into a number value.



вопросы

Какая команда, сколько человек(не меньше 3х человек!)
Что за продукт? в идеале биг тех что-то или о чем ты знаешь что они существуют

Посмотреть есть ли коллега который умеет хорошо говорить, хотеть делиться знаниями, Как проверить? ниже
Как у вас организованы процессы?
Как вы релизитесь?
Какие у меня цели на пол года?
Кто у вас отвечает за Мое дольнейшее развитие? Как меня будут развивать?
У кого я буду спрашивать не понятные вопросы?
Буду ли я собесить?
Буду ли я менторить джунов?
Что я буду делать в компании? Какую роль я буду занимать?
Как будут оценивать результат моей работы?
(должны быть внятные ответы)

Какой технологический стек(должен быть актуальный на рынке)?
Акредитованная ли ай ти компания?
Есть ли в компании удаленная работа?
Согласны ли они на мою вилку?
Какие этапы собеса, что на них будут спрашивать? будут ли алгоритмы? будут ли практические задачи?
(если много этапов, много подготовки и маленькая вилка -)
